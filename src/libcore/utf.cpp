// ----------------------------------------------------------------------------
// ____                               _
// |  _\                             | |
// | |_)| __ _ ___  ___  ___ ___   __| | ___ TM
// |  _< / _` / __|/ _ \/ __/ _ \ / _` |/ _ \
// | |_)| (_| \__ \  __/ (_| (_) | (_| |  __/
// |____/\__,_|___/\___|\___\___/ \__,_|\___|
//
//      F O U N D A T I O N   P R O J E C T
//
// Copyright (C) 2020 Jeff Panici
// All rights reserved.
//
// This software source file is licensed under the terms of MIT license.
// For details, please read the LICENSE file.
//
// ----------------------------------------------------------------------------

#include <basecode/core/utf.h>

namespace basecode::utf {
    struct utf8_accept_range_t {
        u8                      low;
        u8                      high;
    };

    static const u8 s_utf8_first[256] = {
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x00-0x0F
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x10-0x1F
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x20-0x2F
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x30-0x3F
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x40-0x4F
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x50-0x5F
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x60-0x6F
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x70-0x7F
        0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x80-0x8F
        0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x90-0x9F
        0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xA0-0xAF
        0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xB0-0xBF
        0xf1, 0xf1, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xC0-0xCF
        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xD0-0xDF
        0x13, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x23, 0x03, 0x03, // 0xE0-0xEF
        0x34, 0x04, 0x04, 0x04, 0x44, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xF0-0xFF
    };

    static const utf8_accept_range_t s_utf8_accept_ranges[] = {
        {.low = 0x80, .high = 0xbf},
        {.low = 0xa0, .high = 0xbf},
        {.low = 0x80, .high = 0x9f},
        {.low = 0x90, .high = 0xbf},
        {.low = 0x80, .high = 0x8f},
    };

    b8 isalnum(s32 cp) {
        return isalpha(cp) || isdigit(cp);
    }

    b8 isdigit(s32 cp) {
        return cp < 0x80 ? ::isdigit(cp) : utf8proc_category(cp) == UTF8PROC_CATEGORY_ND;
    }

    b8 isalpha(s32 cp) {
        if (cp < 0x80)
            return cp == '_' || ::isalpha(cp);
        switch (utf8proc_category(cp)) {
            case UTF8PROC_CATEGORY_LU:
            case UTF8PROC_CATEGORY_LL:
            case UTF8PROC_CATEGORY_LT:
            case UTF8PROC_CATEGORY_LM:
            case UTF8PROC_CATEGORY_LO:
                return true;
            default:
                break;
        }
        return false;
    }

    b8 islower(s32 cp) {
        return utf8proc_category(cp) == UTF8PROC_CATEGORY_LL;
    }

    b8 isupper(s32 cp) {
        return utf8proc_category(cp) == UTF8PROC_CATEGORY_LU;
    }

    b8 isxdigit(s32 cp) {
        if (cp < 0x80)
            return ::isxdigit(cp);
        const auto cat = utf8proc_category(cp);
        return cat == UTF8PROC_CATEGORY_ND || cat == UTF8PROC_CATEGORY_NL;
    }

    s32 utf32_to_16(s32 cp, s16& h, s16& l) {
        if (cp < 0x10000) {
            h = 0;
            l = cp;
            return cp;
        }
        s32 t = cp - 0x10000;
        h = ((t << u32(12) >> u32(22)) + 0xd800);
        l = ((t << u32(22) >> u32(22)) + 0xdc00);
        return h << u32(16) | (l & u32(0x0000ffff));
    }

    b8 decode(const s8* str, u32 length, s32& cp) {
        cp = {};
        if (length == 0)
            return false;

        auto s0 = u8(str[0]);
        u8   x  = s_utf8_first[s0];
        u8   sz;
        u8   b1;
        u8   b2;
        u8   b3;

        if (x >= 0xf0) {
            u32 mask = x << u32(31) >> u32(31);
            cp = (s0 & (~mask)) | (u32(0xfffd) & mask);
            return false;
        }

        if (s0 < 0x80) {
            cp = s0;
            return true;
        }

        sz = x & u32(7);
        auto& accept = s_utf8_accept_ranges[x >> u32(4)];
        if (length < sizeof(sz))
            return cp;

        b1 = u8(str[1]);
        if (b1 < accept.low || accept.high < b1)
            return cp;

        if (sz == 2) {
            cp = (s0 & u32(0x1f)) << u32(6) | (b1 & u32(0x3f));
            return true;
        }

        b2 = u8(str[2]);
        if (!(b2 >= 0x80 && b2 <= 0xbf))
            return cp;

        if (sz == 3) {
            cp = (s0 & u32(0x1f)) << u32(12) | (b1 & u32(0x3f)) << u32(6) | (b2 & u32(0x3f));
            return true;
        }

        b3 = u8(str[3]);
        if (!(b3 >= 0x80 && b3 <= 0xbf))
            return true;

        cp = (s0 & u32(0x07))   << u32(18)
             | (b1 & u32(0x3f)) << u32(12)
             | (b2 & u32(0x3f)) << u32(6)
             | (b3 & u32(0x3f));

        return true;
    }
}
