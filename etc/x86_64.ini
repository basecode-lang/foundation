[AAA]
opcode       = 37
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "ASCII adjust AL after addition."

[AAD]
opcode       = D5 0A
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "ASCII adjust AX before division."

[AAD imm8]
opcode       = D5 ib
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Adjust AX before division to number base imm8."

[AAM]
opcode       = D4 0A
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "ASCII adjust AX after multiply."

[AAM imm8]
opcode       = D4 ib
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Adjust AX after multiply to number base imm8."

[AAS]
opcode       = 3F
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "ASCII adjust AL after subtraction."

[ADC AL, imm8]
opcode       = 14 ib
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCB
description  = "Add with carry imm8 to AL"

[ADC AX, imm16]
opcode       = 15 iw
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCW
description  = "Add with carry imm16 to AX."

[ADC EAX, imm32]
opcode       = 15 id
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCL
description  = "Add with carry imm32 to EAX."

[ADC RAX, imm32]
opcode       = REX.W+ 15 id
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADCQ
description  = "Add with carry imm32 sign extended to 64- bits to RAX."

[ADC r/m8, imm8]
opcode       = 80 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCB
description  = "Add with carry imm8 to r/m8."

[ADC r/m8, imm8]
opcode       = REX+ 80 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADCB
description  = "Add with carry imm8 to r/m8."

[ADC r/m16, imm16]
opcode       = 81 /2 iw
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCW
description  = "Add with carry imm16 to r/m16."

[ADC r/m32, imm32]
opcode       = 81 /2 id
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCL
description  = "Add with CF imm32 to r/m32."

[ADC r/m64, imm32]
opcode       = REX.W+ 81 /2 id
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADCQ
description  = "Add with CF imm32 sign extended to 64-bits to r/m64."

[ADC r/m16, imm8]
opcode       = 83 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADCW
description  = "Add with CF sign-extended imm8 to r/m16."

[ADC r/m32, imm8]
opcode       = 83 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADCL
description  = "Add with CF sign-extended imm8 into r/m32."

[ADC r/m64, imm8]
opcode       = REX.W+ 83 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ADCQ
description  = "Add with CF sign-extended imm8 into r/m64."

[ADC r/m8, r8]
opcode       = 10 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADCB
description  = "Add with carry byte register to r/m8."

[ADC r/m8, r8]
opcode       = REX+ 10 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ADCB
description  = "Add with carry byte register to r/m8."

[ADC r/m16, r16]
opcode       = 11 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADCW
description  = "Add with carry r16 to r/m16."

[ADC r/m32, r32]
opcode       = 11 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADCL
description  = "Add with CF r32 to r/m32."

[ADC r/m64, r64]
opcode       = REX.W+ 11 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ADCQ
description  = "Add with CF r64 to r/m64."

[ADC r8, r/m8]
opcode       = 12 /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCB
description  = "Add with carry r/m8 to byte register."

[ADC r8, r/m8]
opcode       = REX+ 12 /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADCB
description  = "Add with carry r/m64 to byte register."

[ADC r16, r/m16]
opcode       = 13 /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCW
description  = "Add with carry r/m16 to r16."

[ADC r32, r/m32]
opcode       = 13 /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADCL
description  = "Add with CF r/m32 to r32."

[ADC r64, r/m64]
opcode       = REX.W+ 13 /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADCQ
description  = "Add with CF r/m64 to r64."

[ADD AL, imm8]
opcode       = 04 ib
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDB
description  = "Add imm8 to AL."

[ADD AX, imm16]
opcode       = 05 iw
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDW
description  = "Add imm16 to AX."

[ADD EAX, imm32]
opcode       = 05 id
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDL
description  = "Add imm32 to EAX."

[ADD RAX, imm32]
opcode       = REX.W+ 05 id
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADDQ
description  = "Add imm32 sign-extended to 64-bits to RAX."

[ADD r/m8, imm8]
opcode       = 80 /0 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDB
description  = "Add imm8 to r/m8."

[ADD r/m8, imm8]
opcode       = REX+ 80 /0 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADDB
description  = "Add sign-extended imm8 to r/m64."

[ADD r/m16, imm16]
opcode       = 81 /0 iw
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDW
description  = "Add imm16 to r/m16."

[ADD r/m32, imm32]
opcode       = 81 /0 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDL
description  = "Add imm32 to r/m32."

[ADD r/m64, imm32]
opcode       = REX.W+ 81 /0 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADDQ
description  = "Add imm32 sign-extended to 64-bits to r/m64."

[ADD r/m16, imm8]
opcode       = 83 /0 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADDW
description  = "Add sign-extended imm8 to r/m16."

[ADD r/m32, imm8]
opcode       = 83 /0 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADDL
description  = "Add sign-extended imm8 to r/m32."

[ADD r/m64, imm8]
opcode       = REX.W+ 83 /0 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ADDQ
description  = "Add sign-extended imm8 to r/m64."

[ADD r/m8, r8]
opcode       = 00 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADDB
description  = "Add r8 to r/m8."

[ADD r/m8, r8]
opcode       = REX+ 00 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ADDB
description  = "Add r8 to r/m8."

[ADD r/m16, r16]
opcode       = 01 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADDW
description  = "Add r16 to r/m16."

[ADD r/m32, r32]
opcode       = 01 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ADDL
description  = "Add r32 to r/m32."

[ADD r/m64, r64]
opcode       = REX.W+ 01 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ADDQ
description  = "Add r64 to r/m64."

[ADD r8, r/m8]
opcode       = 02 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDB
description  = "Add r/m8 to r8."

[ADD r8, r/m8]
opcode       = REX+ 02 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADDB
description  = "Add r/m8 to r8."

[ADD r16, r/m16]
opcode       = 03 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDW
description  = "Add r/m16 to r16."

[ADD r32, r/m32]
opcode       = 03 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ADDL
description  = "Add r/m32 to r32."

[ADD r64, r/m64]
opcode       = REX.W+ 03 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ADDQ
description  = "Add r/m64 to r64."

[ADDPD xmm1, xmm2/m128]
opcode       = 66 0F 58 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = ADDPD
description  = "Add packed double-precision floating-point values from xmm2/m128 to xmm1."

[VADDPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 58 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDPD
description  = "Add packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."

[VADDPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 58 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDPD
description  = "Add packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."

[ADDPS xmm1, xmm2/m128]
opcode       = 0F 58 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = ADDPS
description  = "Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1."

[VADDPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 58 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDPS
description  = "Add packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."

[VADDPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 58 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDPS
description  = "Add packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."

[ADDSD xmm1, xmm2/m64]
opcode       = F2 0F 58 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = ADDSD
description  = "Add the low double-precision floating-point value from xmm2/m64 to xmm1."

[VADDSD xmm1, xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 58 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDSD
description  = "Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."

[ADDSS xmm1, xmm2/m32]
opcode       = F3 0F 58 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = ADDSS
description  = "Add the low single-precision floating-point value from xmm2/m32 to xmm1."

[VADDSS xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 58 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDSS
description  = "Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."

[ADDSUBPD xmm1, xmm2/m128]
opcode       = 66 0F D0 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = ADDSUBPD
description  = "Add/subtract double-precision floating-point values from xmm2/m128 to xmm1."

[VADDSUBPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D0 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDSUBPD
description  = "Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."

[VADDSUBPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG D0 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDSUBPD
description  = "Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."

[ADDSUBPS xmm1, xmm2/m128]
opcode       = F2 0F D0 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = ADDSUBPS
description  = "Add/subtract single-precision floating-point values from xmm2/m128 to xmm1."

[VADDSUBPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.F2.0F.WIG D0 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDSUBPS
description  = "Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."

[VADDSUBPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.F2.0F.WIG D0 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VADDSUBPS
description  = "Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."

[AESDEC xmm1, xmm2/m128]
opcode       = 66 0F 38 DE /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES
preferred    = 0
att_mnemonic = AESDEC
description  = "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."

[VAESDEC xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG DE /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES AVX
preferred    = 0
att_mnemonic = VAESDEC
description  = "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."

[AESDECLAST xmm1, xmm2/m128]
opcode       = 66 0F 38 DF /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES
preferred    = 0
att_mnemonic = AESDECLAST
description  = "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."

[VAESDECLAST xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG DF /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES AVX
preferred    = 0
att_mnemonic = VAESDECLAST
description  = "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."

[AESENC xmm1, xmm2/m128]
opcode       = 66 0F 38 DC /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES
preferred    = 0
att_mnemonic = AESENC
description  = "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."

[VAESENC xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG DC /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES AVX
preferred    = 0
att_mnemonic = VAESENC
description  = "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1."

[AESENCLAST xmm1, xmm2/m128]
opcode       = 66 0F 38 DD /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES
preferred    = 0
att_mnemonic = AESENCLAST
description  = "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."

[VAESENCLAST xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG DD /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES AVX
preferred    = 0
att_mnemonic = VAESENCLAST
description  = "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1."

[AESIMC xmm1, xmm2/m128]
opcode       = 66 0F 38 DB /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES
preferred    = 0
att_mnemonic = AESIMC
description  = "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."

[VAESIMC xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.WIG DB /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES AVX
preferred    = 0
att_mnemonic = VAESIMC
description  = "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."

[AESKEYGENASSIST xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A DF /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES
preferred    = 0
att_mnemonic = AESKEYGENASSIST
description  = "Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."

[VAESKEYGENASSIST xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.WIG DF /r ib
operand      = RMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AES AVX
preferred    = 0
att_mnemonic = VAESKEYGENASSIST
description  = "Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."

[AND AL, imm8]
opcode       = 24 ib
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDB
description  = "AL AND imm8."

[AND AX, imm16]
opcode       = 25 iw
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDW
description  = "AX AND imm16."

[AND EAX, imm32]
opcode       = 25 id
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDL
description  = "EAX AND imm32."

[AND RAX, imm32]
opcode       = REX.W+ 25 id
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ANDQ
description  = "RAX AND imm32 sign-extended to 64-bits."

[AND r/m8, imm8]
opcode       = 80 /4 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDB
description  = "r/m8 AND imm8."

[AND r/m8, imm8]
opcode       = REX+ 80 /4 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ANDB
description  = "r/m8 AND imm8."

[AND r/m16, imm16]
opcode       = 81 /4 iw
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDW
description  = "r/m16 AND imm16."

[AND r/m32, imm32]
opcode       = 81 /4 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDL
description  = "r/m32 AND imm32."

[AND r/m64, imm32]
opcode       = REX.W+ 81 /4 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ANDQ
description  = "r/m64 AND imm32 sign extended to 64-bits."

[AND r/m16, imm8]
opcode       = 83 /4 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ANDW
description  = "r/m16 AND imm8 (sign-extended)."

[AND r/m32, imm8]
opcode       = 83 /4 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ANDL
description  = "r/m32 AND imm8 (sign-extended)."

[AND r/m64, imm8]
opcode       = REX.W+ 83 /4 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ANDQ
description  = "r/m64 AND imm8 (sign-extended)."

[AND r/m8, r8]
opcode       = 20 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ANDB
description  = "r/m8 AND r8."

[AND r/m8, r8]
opcode       = REX+ 20 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ANDB
description  = "r/m64 AND r8 (sign-extended)."

[AND r/m16, r16]
opcode       = 21 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ANDW
description  = "r/m16 AND r16."

[AND r/m32, r32]
opcode       = 21 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ANDL
description  = "r/m32 AND r32."

[AND r/m64, r64]
opcode       = REX.W+ 21 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ANDQ
description  = "r/m64 AND r32."

[AND r8, r/m8]
opcode       = 22 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDB
description  = "r8 AND r/m8."

[AND r8, r/m8]
opcode       = REX+ 22 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ANDB
description  = "r/m64 AND r8 (sign-extended)."

[AND r16, r/m16]
opcode       = 23 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDW
description  = "r16 AND r/m16."

[AND r32, r/m32]
opcode       = 23 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ANDL
description  = "r32 AND r/m32."

[AND r64, r/m64]
opcode       = REX.W+ 23 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ANDQ
description  = "r64 AND r/m64."

[ANDN r32a, r32b, r/m32]
opcode       = VEX.NDS.LZ.0F38.W0 F2 /r
operand      = RVM
props        = W, R, R
iwrite       = E.SF E.ZF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = ANDNL
description  = "Bitwise AND of inverted r32b with r/m32, store result in r32a"

[ANDN r64a, r64b, r/m64]
opcode       = VEX.NDS.LZ.0F38.W1 F2 /r
operand      = RVM
props        = W, R, R
iwrite       = E.SF E.ZF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = ANDNQ
description  = "Bitwise AND of inverted r64b with r/m64, store result in r64a"

[ANDPD xmm1, xmm2/m128]
opcode       = 66 0F 54 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = ANDPD
description  = "Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128."

[VANDPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 54 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDPD
description  = "Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem."

[VANDPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 54 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDPD
description  = "Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem."

[ANDPS xmm1, xmm2/m128]
opcode       = 0F 54 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = ANDPS
description  = "Bitwise logical AND of xmm2/m128 and xmm1."

[VANDPS xmm1,xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 54 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDPS
description  = "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem."

[VANDPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 54 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDPS
description  = "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem."

[ANDNPD xmm1, xmm2/m128]
opcode       = 66 0F 55 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = ANDNPD
description  = "Bitwise logical AND NOT of xmm2/m128 and xmm1."

[VANDNPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 55 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDNPD
description  = "Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem."

[VANDNPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 55 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDNPD
description  = "Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem."

[ANDNPS xmm1, xmm2/m128]
opcode       = 0F 55 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = ANDNPS
description  = "Bitwise logical AND NOT of xmm2/m128 and xmm1."

[VANDNPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 55 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDNPS
description  = "Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem."

[VANDNPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 55 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VANDNPS
description  = "Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem."

[ARPL r/m16, r16]
opcode       = 63 /r
useful       = 1
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Adjust RPL of r/m16 to not less than RPL of r16."

[BLENDPD xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 0D /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = BLENDPD
description  = "Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."

[VBLENDPD xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 0D /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDPD
description  = "Select packed double-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."

[VBLENDPD ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.WIG 0D /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDPD
description  = "Select packed double-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."

[BEXTR r32a, r/m32, r32b]
opcode       = VEX.NDS.LZ.0F38.W0 F7 /r
operand      = RMV
props        = W, R, R
iwrite       = E.ZF E.OF E.CF
iundef       = E.AF E.SF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BEXTRL
description  = "Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a."

[BEXTR r64a, r/m64, r64b]
opcode       = VEX.NDS.LZ.0F38.W1 F7 /r
operand      = RMV
props        = W, R, R
iwrite       = E.ZF E.OF E.CF
iundef       = E.AF E.SF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BEXTRQ
description  = "Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a"

[BLENDPS xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 0C /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = BLENDPS
description  = "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."

[VBLENDPS xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 0C /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDPS
description  = "Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."

[VBLENDPS ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.WIG 0C /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDPS
description  = "Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."

[BLENDVPD xmm1, xmm2/m128, <XMM0>]
opcode       = 66 0F 38 15 /r
operand      = RM0
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = BLENDVPD
description  = "Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1."

[VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4]
opcode       = VEX.NDS.128.66.0F3A.W0 4B /r /is4
operand      = RVMR
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDVPD
description  = "Conditionally copy double-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4."

[VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4]
opcode       = VEX.NDS.256.66.0F3A.W0 4B /r /is4
operand      = RVMR
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDVPD
description  = "Conditionally copy double-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4."

[BLENDVPS xmm1, xmm2/m128, <XMM0>]
opcode       = 66 0F 38 14 /r
operand      = RM0
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = BLENDVPS
description  = "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1."

[VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4]
opcode       = VEX.NDS.128.66.0F3A.W0 4A /r /is4
operand      = RVMR
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDVPS
description  = "Conditionally copy single-precision floating- point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4."

[VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4]
opcode       = VEX.NDS.256.66.0F3A.W0 4A /r /is4
operand      = RVMR
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBLENDVPS
description  = "Conditionally copy single-precision floating- point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4."

[BLSI r32, r/m32]
opcode       = VEX.NDD.LZ.0F38.W0 F3 /3
operand      = VM
props        = RW, R
iwrite       = E.ZF E.SF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BLSIL
description  = "Extract lowest set bit from r/m32 and set that bit in r32."

[BLSI r64, r/m64]
opcode       = VEX.NDD.LZ.0F38.W1 F3 /3
operand      = VM
props        = RW, R
iwrite       = E.ZF E.SF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BLSIQ
description  = "Extract lowest set bit from r/m64, and set that bit in r64."

[BLSMSK r32, r/m32]
opcode       = VEX.NDD.LZ.0F38.W0 F3 /2
operand      = VM
props        = RW, R
iwrite       = E.ZF E.SF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BLSMSKL
description  = "Set all lower bits in r32 to "1" starting from bit 0 to lowest set bit in r/m32"

[BLSMSK r64, r/m64]
opcode       = VEX.NDD.LZ.0F38.W1 F3 /2
operand      = VM
props        = RW, R
iwrite       = E.ZF E.SF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BLSMSKQ
description  = "Set all lower bits in r64 to "1" starting from bit 0 to lowest set bit in r/m64"

[BLSR r32, r/m32]
opcode       = VEX.NDD.LZ.0F38.W0 F3 /1
operand      = VM
props        = W, R
iwrite       = E.ZF E.SF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BLSRL
description  = "Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32."

[BLSR r64, r/m64]
opcode       = VEX.NDD.LZ.0F38.W1 F3 /1
operand      = VM
props        = W, R
iwrite       = E.ZF E.SF E.OF E.CF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = BLSRQ
description  = "Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64."

[BOUND r16, m16&16]
opcode       = 62 /r
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Check if r16 (array index) is within bounds specified by m16&16."

[BOUND r32, m32&32]
opcode       = 62 /r
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Check if r32 (array index) is within bounds specified by m16&16."

[BSF r16, r/m16]
opcode       = 0F BC /r
operand      = RM
props        = uw, R
iwrite       = E.ZF
iundef       = E.CF E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BSFW
description  = "Bit scan forward on r/m16."

[BSF r32, r/m32]
opcode       = 0F BC /r
operand      = RM
props        = uz, R
iwrite       = E.ZF
iundef       = E.CF E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BSFL
description  = "Bit scan forward on r/m32."

[BSF r64, r/m64]
opcode       = REX.W+ 0F BC
operand      = RM
props        = uw, R
iwrite       = E.ZF
iundef       = E.CF E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BSFQ
description  = "Bit scan forward on r/m64."

[BSR r16, r/m16]
opcode       = 0F BD /r
operand      = RM
props        = uw, R
iwrite       = E.ZF
iundef       = E.CF E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BSRW
description  = "Bit scan reverse on r/m16."

[BSR r32, r/m32]
opcode       = 0F BD /r
operand      = RM
props        = uz, R
iwrite       = E.ZF
iundef       = E.CF E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BSRL
description  = "Bit scan reverse on r/m32."

[BSR r64, r/m64]
opcode       = REX.W+ 0F BD
operand      = RM
props        = uw, R
iwrite       = E.ZF
iundef       = E.CF E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BSRQ
description  = "Bit scan reverse on r/m64."

[BSWAP r32]
opcode       = 0F C8 +rd
operand      = O
props        = RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BSWAP
description  = "Reverses the byte order of a 32-bit register."

[BSWAP r64]
opcode       = REX.W+ 0F C8 +rd
operand      = O
props        = RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BSWAP
description  = "Reverses the byte order of a 64-bit register."

[BT r/m16, r16]
opcode       = 0F A3
operand      = MR
props        = R, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTW
description  = "Store selected bit in CF flag."

[BT r/m32, r32]
opcode       = 0F A3
operand      = MR
props        = R, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTL
description  = "Store selected bit in CF flag."

[BT r/m64, r64]
opcode       = REX.W+ 0F A3
operand      = MR
props        = R, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTQ
description  = "Store selected bit in CF flag."

[BT r/m16, imm8]
opcode       = 0F BA /4 ib
operand      = MI
props        = R, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTW
description  = "Store selected bit in CF flag."

[BT r/m32, imm8]
opcode       = 0F BA /4 ib
operand      = MI
props        = R, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTL
description  = "Store selected bit in CF flag."

[BT r/m64, imm8]
opcode       = REX.W+ 0F BA /4 ib
operand      = MI
props        = R, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTQ
description  = "Store selected bit in CF flag."

[BTC r/m16, r16]
opcode       = 0F BB
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTCW
description  = "Store selected bit in CF flag and complement."

[BTC r/m32, r32]
opcode       = 0F BB
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTCL
description  = "Store selected bit in CF flag and complement."

[BTC r/m64, r64]
opcode       = REX.W+ 0F BB
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTCQ
description  = "Store selected bit in CF flag and complement."

[BTC r/m16, imm8]
opcode       = 0F BA /7 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTCW
description  = "Store selected bit in CF flag and complement."

[BTC r/m32, imm8]
opcode       = 0F BA /7 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTCL
description  = "Store selected bit in CF flag and complement."

[BTC r/m64, imm8]
opcode       = REX.W+ 0F BA /7 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTCQ
description  = "Store selected bit in CF flag and complement."

[BTR r/m16, r16]
opcode       = 0F B3
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTRW
description  = "Store selected bit in CF flag and clear."

[BTR r/m32, r32]
opcode       = 0F B3
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTRL
description  = "Store selected bit in CF flag and clear."

[BTR r/m64, r64]
opcode       = REX.W+ 0F B3
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTRQ
description  = "Store selected bit in CF flag and clear."

[BTR r/m16, imm8]
opcode       = 0F BA /6 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTRW
description  = "Store selected bit in CF flag and clear."

[BTR r/m32, imm8]
opcode       = 0F BA /6 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTRL
description  = "Store selected bit in CF flag and clear."

[BTR r/m64, imm8]
opcode       = REX.W+ 0F BA /6 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTRQ
description  = "Store selected bit in CF flag and clear."

[BTS r/m16, r16]
opcode       = 0F AB
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTSW
description  = "Store selected bit in CF flag and set."

[BTS r/m32, r32]
opcode       = 0F AB
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTSL
description  = "Store selected bit in CF flag and set."

[BTS r/m64, r64]
opcode       = REX.W+ 0F AB
operand      = MR
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTSQ
description  = "Store selected bit in CF flag and set."

[BTS r/m16, imm8]
opcode       = 0F BA /5 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTSW
description  = "Store selected bit in CF flag and set."

[BTS r/m32, imm8]
opcode       = 0F BA /5 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = BTSL
description  = "Store selected bit in CF flag and set."

[BTS r/m64, imm8]
opcode       = REX.W+ 0F BA /5 ib
operand      = MI
props        = RW, R
iwrite       = E.CF
iundef       = E.OF E.SF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = BTSQ
description  = "Store selected bit in CF flag and set."

[BZHI r32a, r/m32, r32b]
opcode       = VEX.NDS.LZ.0F38.W0 F5 /r
operand      = RMV
props        = W, R, R
iwrite       = E.ZF E.CF E.SF E.OF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = BZHIL
description  = "Zero bits in r/m32 starting with the position in r32b, write result to r32a."

[BZHI r64a, r/m64, r64b]
opcode       = VEX.NDS.LZ.0F38.W1 F5 /r
operand      = RMV
props        = W, R, R
iwrite       = E.ZF E.CF E.SF E.OF
iundef       = E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = BZHIQ
description  = "Zero bits in r/m64 starting with the position in r64b, write result to r64a."

[CALL rel16]
opcode       = E8 cw
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Call near, relative, displacement relative to next instruction."

[CALL rel32]
opcode       = E8 cd
operand      = D
props        = R
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CALLQ
description  = "Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode."

[CALL r/m16]
opcode       = FF /2
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Call near, absolute indirect, address given in r/m16."

[CALL r/m32]
opcode       = FF /2
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Call near, absolute indirect, address given in r/m32."

[CALL r/m64]
opcode       = FF /2
operand      = M
props        = R
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CALLQ
description  = "Call near, absolute indirect, address given in r/m64."

[CALL ptr16:16]
opcode       = 9A cd
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Call far, absolute, address given in operand."

[CALL ptr16:32]
opcode       = 9A cp
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Call far, absolute, address given in operand."

[CALL m16:16]
opcode       = FF /3
operand      = M
props        = R
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CALLQ
description  = "Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16- bit offset from far pointer referenced in the instruction."

[CALL m16:32]
opcode       = FF /3
operand      = M
props        = R
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CALLQ
description  = "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction."

[CALL m16:64]
opcode       = REX.W+ FF /3
operand      = M
props        = R
iread        = rdi rsi rdx rcx r8 r9 rax xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7
iwrite       = RAX RDX XMM0 XMM1
iundef       = RDI RSI RCX R8 R9 R10 R11 XMM2 XMM3 XMM4 XMM5 XMM6 XMM7 XMM8 XMM9 XMM10 XMM11 XMM12 XMM13 XMM14 XMM15
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CALLQ
description  = "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction."

[CBW]
opcode       = PREF.66+ 98
operand      = NP
iread        = AL
iwrite       = AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CBTW
description  = "AX = sign-extend of AL."

[CWDE]
opcode       = 98
operand      = NP
iread        = AX
iwrite       = RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CWTL
description  = "EAX = sign-extend of AX."

[CDQE]
opcode       = REX.W+ 98
operand      = NP
iread        = EAX
iwrite       = RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CLTQ
description  = "RAX = sign-extend of EAX."

[CLC]
opcode       = F8
operand      = NP
iwrite       = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CLC
description  = "Clear CF flag."

[CLD]
opcode       = FC
operand      = NP
iwrite       = E.DF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CLD
description  = "Clear DF flag."

[CLFLUSH m8]
opcode       = 0F AE /7
operand      = M
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CLFLUSH
preferred    = 0
att_mnemonic = CLFLUSH
description  = "Flushes cache line containing m8."

[CLI]
opcode       = FA
operand      = NP
iread        = E.VM E.IOPL E.VIP
iwrite       = e.if e.vif
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CLI
description  = "Clear interrupt flag; interrupts disabled when interrupt flag cleared."

[CLTS]
opcode       = 0F 06
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Clears TS flag in CR0."

[CMC]
opcode       = F5
operand      = NP
iread        = E.CF
iwrite       = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMC
description  = "Complement CF flag."

[CMOVA r16, r/m16]
opcode       = 0F 47 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVAW
description  = "Move if above (CF=0 and ZF=0)."

[CMOVA r32, r/m32]
opcode       = 0F 47 /r
operand      = RM
props        = z, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVAL
description  = "Move if above (CF=0 and ZF=0)."

[CMOVA r64, r/m64]
opcode       = REX.W+ 0F 47 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVAQ
description  = "Move if above (CF=0 and ZF=0)."

[CMOVAE r16, r/m16]
opcode       = 0F 43 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVAEW
description  = "Move if above or equal (CF=0)."

[CMOVAE r32, r/m32]
opcode       = 0F 43 /r
operand      = RM
props        = z, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVAEL
description  = "Move if above or equal (CF=0)."

[CMOVAE r64, r/m64]
opcode       = REX.W+ 0F 43 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVAEQ
description  = "Move if above or equal (CF=0)."

[CMOVB r16, r/m16]
opcode       = 0F 42 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVBW
description  = "Move if below (CF=1)."

[CMOVB r32, r/m32]
opcode       = 0F 42 /r
operand      = RM
props        = z, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVBL
description  = "Move if below (CF=1)."

[CMOVB r64, r/m64]
opcode       = REX.W+ 0F 42 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVBQ
description  = "Move if below (CF=1)."

[CMOVBE r16, r/m16]
opcode       = 0F 46 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVBEW
description  = "Move if below or equal (CF=1 or ZF=1)."

[CMOVBE r32, r/m32]
opcode       = 0F 46 /r
operand      = RM
props        = z, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVBEL
description  = "Move if below or equal (CF=1 or ZF=1)."

[CMOVBE r64, r/m64]
opcode       = REX.W+ 0F 46 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVBEQ
description  = "Move if below or equal (CF=1 or ZF=1)."

[CMOVC r16, r/m16]
opcode       = 0F 42 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVCW
description  = "Move if carry (CF=1)."

[CMOVC r32, r/m32]
opcode       = 0F 42 /r
operand      = RM
props        = z, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVCL
description  = "Move if carry (CF=1)."

[CMOVC r64, r/m64]
opcode       = REX.W+ 0F 42 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVCQ
description  = "Move if carry (CF=1)."

[CMOVE r16, r/m16]
opcode       = 0F 44 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVEW
description  = "Move if equal (ZF=1)."

[CMOVE r32, r/m32]
opcode       = 0F 44 /r
operand      = RM
props        = z, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVEL
description  = "Move if equal (ZF=1)."

[CMOVE r64, r/m64]
opcode       = REX.W+ 0F 44 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVEQ
description  = "Move if equal (ZF=1)."

[CMOVG r16, r/m16]
opcode       = 0F 4F /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVGW
description  = "Move if greater (ZF=0 and SF=OF)."

[CMOVG r32, r/m32]
opcode       = 0F 4F /r
operand      = RM
props        = z, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVGL
description  = "Move if greater (ZF=0 and SF=OF)."

[CMOVG r64, r/m64]
opcode       = REX.W+ 0F 4F /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVGQ
description  = "Move if greater (ZF=0 and SF=OF)."

[CMOVGE r16, r/m16]
opcode       = 0F 4D /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVGEW
description  = "Move if greater or equal (SF=OF)."

[CMOVGE r32, r/m32]
opcode       = 0F 4D /r
operand      = RM
props        = z, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVGEL
description  = "Move if greater or equal (SF=OF)."

[CMOVGE r64, r/m64]
opcode       = REX.W+ 0F 4D /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVGEQ
description  = "Move if greater or equal (SF=OF)."

[CMOVL r16, r/m16]
opcode       = 0F 4C /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVLW
description  = "Move if less (SF != OF)."

[CMOVL r32, r/m32]
opcode       = 0F 4C /r
operand      = RM
props        = z, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVLL
description  = "Move if less (SF!= OF)."

[CMOVL r64, r/m64]
opcode       = REX.W+ 0F 4C /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVLQ
description  = "Move if less (SF!= OF)."

[CMOVLE r16, r/m16]
opcode       = 0F 4E /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVLEW
description  = "Move if less or equal (ZF=1 or SF!= OF)."

[CMOVLE r32, r/m32]
opcode       = 0F 4E /r
operand      = RM
props        = z, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVLEL
description  = "Move if less or equal (ZF=1 or SF!= OF)."

[CMOVLE r64, r/m64]
opcode       = REX.W+ 0F 4E /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVLEQ
description  = "Move if less or equal (ZF=1 or SF!= OF)."

[CMOVNA r16, r/m16]
opcode       = 0F 46 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNAW
description  = "Move if not above (CF=1 or ZF=1)."

[CMOVNA r32, r/m32]
opcode       = 0F 46 /r
operand      = RM
props        = z, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNAL
description  = "Move if not above (CF=1 or ZF=1)."

[CMOVNA r64, r/m64]
opcode       = REX.W+ 0F 46 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNAQ
description  = "Move if not above (CF=1 or ZF=1)."

[CMOVNAE r16, r/m16]
opcode       = 0F 42 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNAEW
description  = "Move if not above or equal (CF=1)."

[CMOVNAE r32, r/m32]
opcode       = 0F 42 /r
operand      = RM
props        = z, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNAEL
description  = "Move if not above or equal (CF=1)."

[CMOVNAE r64, r/m64]
opcode       = REX.W+ 0F 42 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNAEQ
description  = "Move if not above or equal (CF=1)."

[CMOVNB r16, r/m16]
opcode       = 0F 43 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNBW
description  = "Move if not below (CF=0)."

[CMOVNB r32, r/m32]
opcode       = 0F 43 /r
operand      = RM
props        = z, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNBL
description  = "Move if not below (CF=0)."

[CMOVNB r64, r/m64]
opcode       = REX.W+ 0F 43 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNBQ
description  = "Move if not below (CF=0)."

[CMOVNBE r16, r/m16]
opcode       = 0F 47 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNBEW
description  = "Move if not below or equal (CF=0 and ZF=0)."

[CMOVNBE r32, r/m32]
opcode       = 0F 47 /r
operand      = RM
props        = z, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNBEL
description  = "Move if not below or equal (CF=0 and ZF=0)."

[CMOVNBE r64, r/m64]
opcode       = REX.W+ 0F 47 /r
operand      = RM
props        = w, R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNBEQ
description  = "Move if not below or equal (CF=0 and ZF=0)."

[CMOVNC r16, r/m16]
opcode       = 0F 43 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNCW
description  = "Move if not carry (CF=0)."

[CMOVNC r32, r/m32]
opcode       = 0F 43 /r
operand      = RM
props        = z, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNCL
description  = "Move if not carry (CF=0)."

[CMOVNC r64, r/m64]
opcode       = REX.W+ 0F 43 /r
operand      = RM
props        = w, R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNCQ
description  = "Move if not carry (CF=0)."

[CMOVNE r16, r/m16]
opcode       = 0F 45 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNEW
description  = "Move if not equal (ZF=0)."

[CMOVNE r32, r/m32]
opcode       = 0F 45 /r
operand      = RM
props        = z, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNEL
description  = "Move if not equal (ZF=0)."

[CMOVNE r64, r/m64]
opcode       = REX.W+ 0F 45 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNEQ
description  = "Move if not equal (ZF=0)."

[CMOVNG r16, r/m16]
opcode       = 0F 4E /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNGW
description  = "Move if not greater (ZF=1 or SF!= OF)."

[CMOVNG r32, r/m32]
opcode       = 0F 4E /r
operand      = RM
props        = z, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNGL
description  = "Move if not greater (ZF=1 or SF!= OF)."

[CMOVNG r64, r/m64]
opcode       = REX.W+ 0F 4E /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNGQ
description  = "Move if not greater (ZF=1 or SF!= OF)."

[CMOVNGE r16, r/m16]
opcode       = 0F 4C /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNGEW
description  = "Move if not greater or equal (SF!= OF)."

[CMOVNGE r32, r/m32]
opcode       = 0F 4C /r
operand      = RM
props        = z, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNGEL
description  = "Move if not greater or equal (SF!= OF)."

[CMOVNGE r64, r/m64]
opcode       = REX.W+ 0F 4C /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNGEQ
description  = "Move if not greater or equal (SF!= OF)."

[CMOVNL r16, r/m16]
opcode       = 0F 4D /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNLW
description  = "Move if not less (SF=OF)."

[CMOVNL r32, r/m32]
opcode       = 0F 4D /r
operand      = RM
props        = z, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNLL
description  = "Move if not less (SF=OF)."

[CMOVNL r64, r/m64]
opcode       = REX.W+ 0F 4D /r
operand      = RM
props        = w, R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNLQ
description  = "Move if not less (SF=OF)."

[CMOVNLE r16, r/m16]
opcode       = 0F 4F /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNLEW
description  = "Move if not less or equal (ZF=0 and SF=OF)."

[CMOVNLE r32, r/m32]
opcode       = 0F 4F /r
operand      = RM
props        = z, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNLEL
description  = "Move if not less or equal (ZF=0 and SF=OF)."

[CMOVNLE r64, r/m64]
opcode       = REX.W+ 0F 4F /r
operand      = RM
props        = w, R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNLEQ
description  = "Move if not less or equal (ZF=0 and SF=OF)."

[CMOVNO r16, r/m16]
opcode       = 0F 41 /r
operand      = RM
props        = w, R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNOW
description  = "Move if not overflow (OF=0)."

[CMOVNO r32, r/m32]
opcode       = 0F 41 /r
operand      = RM
props        = z, R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNOL
description  = "Move if not overflow (OF=0)."

[CMOVNO r64, r/m64]
opcode       = REX.W+ 0F 41 /r
operand      = RM
props        = w, R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNOQ
description  = "Move if not overflow (OF=0)."

[CMOVNP r16, r/m16]
opcode       = 0F 4B /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNPW
description  = "Move if not parity (PF=0)."

[CMOVNP r32, r/m32]
opcode       = 0F 4B /r
operand      = RM
props        = z, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNPL
description  = "Move if not parity (PF=0)."

[CMOVNP r64, r/m64]
opcode       = REX.W+ 0F 4B /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNPQ
description  = "Move if not parity (PF=0)."

[CMOVNS r16, r/m16]
opcode       = 0F 49 /r
operand      = RM
props        = w, R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNSW
description  = "Move if not sign (SF=0)."

[CMOVNS r32, r/m32]
opcode       = 0F 49 /r
operand      = RM
props        = z, R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNSL
description  = "Move if not sign (SF=0)."

[CMOVNS r64, r/m64]
opcode       = REX.W+ 0F 49 /r
operand      = RM
props        = w, R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNSQ
description  = "Move if not sign (SF=0)."

[CMOVNZ r16, r/m16]
opcode       = 0F 45 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNZW
description  = "Move if not zero (ZF=0)."

[CMOVNZ r32, r/m32]
opcode       = 0F 45 /r
operand      = RM
props        = z, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNZL
description  = "Move if not zero (ZF=0)."

[CMOVNZ r64, r/m64]
opcode       = REX.W+ 0F 45 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVNZQ
description  = "Move if not zero (ZF=0)."

[CMOVO r16, r/m16]
opcode       = 0F 40 /r
operand      = RM
props        = w, R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVOW
description  = "Move if overflow (OF=1)."

[CMOVO r32, r/m32]
opcode       = 0F 40 /r
operand      = RM
props        = z, R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVOL
description  = "Move if overflow (OF=1)."

[CMOVO r64, r/m64]
opcode       = REX.W+ 0F 40 /r
operand      = RM
props        = w, R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVOQ
description  = "Move if overflow (OF=1)."

[CMOVP r16, r/m16]
opcode       = 0F 4A /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPW
description  = "Move if parity (PF=1)."

[CMOVP r32, r/m32]
opcode       = 0F 4A /r
operand      = RM
props        = z, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPL
description  = "Move if parity (PF=1)."

[CMOVP r64, r/m64]
opcode       = REX.W+ 0F 4A /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPQ
description  = "Move if parity (PF=1)."

[CMOVPE r16, r/m16]
opcode       = 0F 4A /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPEW
description  = "Move if parity even (PF=1)."

[CMOVPE r32, r/m32]
opcode       = 0F 4A /r
operand      = RM
props        = z, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPEL
description  = "Move if parity even (PF=1)."

[CMOVPE r64, r/m64]
opcode       = REX.W+ 0F 4A /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPEQ
description  = "Move if parity even (PF=1)."

[CMOVPO r16, r/m16]
opcode       = 0F 4B /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPOW
description  = "Move if parity odd (PF=0)."

[CMOVPO r32, r/m32]
opcode       = 0F 4B /r
operand      = RM
props        = z, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPOL
description  = "Move if parity odd (PF=0)."

[CMOVPO r64, r/m64]
opcode       = REX.W+ 0F 4B /r
operand      = RM
props        = w, R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVPOQ
description  = "Move if parity odd (PF=0)."

[CMOVS r16, r/m16]
opcode       = 0F 48 /r
operand      = RM
props        = w, R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVSW
description  = "Move if sign (SF=1)."

[CMOVS r32, r/m32]
opcode       = 0F 48 /r
operand      = RM
props        = z, R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVSL
description  = "Move if sign (SF=1)."

[CMOVS r64, r/m64]
opcode       = REX.W+ 0F 48 /r
operand      = RM
props        = w, R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVSQ
description  = "Move if sign (SF=1)."

[CMOVZ r16, r/m16]
opcode       = 0F 44 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVZW
description  = "Move if zero (ZF=1)."

[CMOVZ r32, r/m32]
opcode       = 0F 44 /r
operand      = RM
props        = z, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVZL
description  = "Move if zero (ZF=1)."

[CMOVZ r64, r/m64]
opcode       = REX.W+ 0F 44 /r
operand      = RM
props        = w, R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CMOV
preferred    = 0
att_mnemonic = CMOVZQ
description  = "Move if zero (ZF=1)."

[CMP AL, imm8]
opcode       = 3C ib
operand      = I
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPB
description  = "Compare imm8 with AL."

[CMP AX, imm16]
opcode       = 3D iw
operand      = I
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPW
description  = "Compare imm16 with AX."

[CMP EAX, imm32]
opcode       = 3D id
operand      = I
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPL
description  = "Compare imm32 with EAX."

[CMP RAX, imm32]
opcode       = REX.W+ 3D id
operand      = I
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPQ
description  = "Compare imm32 sign-extended to 64-bits with RAX."

[CMP r/m8, imm8]
opcode       = 80 /7 ib
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPB
description  = "Compare imm8 with r/m8."

[CMP r/m8, imm8]
opcode       = REX+ 80 /7 ib
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPB
description  = "Compare imm8 with r/m8."

[CMP r/m16, imm16]
opcode       = 81 /7 iw
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPW
description  = "Compare imm16 with r/m16."

[CMP r/m32, imm32]
opcode       = 81 /7 id
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPL
description  = "Compare imm32 with r/m32."

[CMP r/m64, imm32]
opcode       = REX.W+ 81 /7 id
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPQ
description  = "Compare imm32 sign-extended to 64-bits with r/m64."

[CMP r/m16, imm8]
opcode       = 83 /7 ib
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = CMPW
description  = "Compare imm8 with r/m16."

[CMP r/m32, imm8]
opcode       = 83 /7 ib
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = CMPL
description  = "Compare imm8 with r/m32."

[CMP r/m64, imm8]
opcode       = REX.W+ 83 /7 ib
operand      = MI
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = CMPQ
description  = "Compare imm8 with r/m64."

[CMP r/m8, r8]
opcode       = 38 /r
operand      = MR
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = CMPB
description  = "Compare r8 with r/m8."

[CMP r/m8, r8]
opcode       = REX+ 38 /r
operand      = MR
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = CMPB
description  = "Compare r8 with r/m8."

[CMP r/m16, r16]
opcode       = 39 /r
operand      = MR
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = CMPW
description  = "Compare r16 with r/m16."

[CMP r/m32, r32]
opcode       = 39 /r
operand      = MR
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = CMPL
description  = "Compare r32 with r/m32."

[CMP r/m64, r64]
opcode       = REX.W+ 39 /r
operand      = MR
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = CMPQ
description  = "Compare r64 with r/m64."

[CMP r8, r/m8]
opcode       = 3A /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPB
description  = "Compare r/m8 with r8."

[CMP r8, r/m8]
opcode       = REX+ 3A /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPB
description  = "Compare r/m8 with r8."

[CMP r16, r/m16]
opcode       = 3B /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPW
description  = "Compare r/m16 with r16."

[CMP r32, r/m32]
opcode       = 3B /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPL
description  = "Compare r/m32 with r32."

[CMP r64, r/m64]
opcode       = REX.W+ 3B /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPQ
description  = "Compare r/m64 with r64."

[CMPPD xmm1, xmm2/m128, imm8]
opcode       = 66 0F C2 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CMPPD
description  = "Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate."

[VCMPPD xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F.WIG C2 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCMPPD
description  = "Compare packed double-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."

[VCMPPD ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F.WIG C2 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCMPPD
description  = "Compare packed double-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."

[CMPPS xmm1, xmm2/m128, imm8]
opcode       = 0F C2 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CMPPS
description  = "Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate."

[VCMPPS xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.0F.WIG C2 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCMPPS
description  = "Compare packed single-precision floating- point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."

[VCMPPS ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.0F.WIG C2 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCMPPS
description  = "Compare packed single-precision floating- point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."

[CMPS m8, m8]
opcode       = A6
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPS
description  = "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."

[CMPS m16, m16]
opcode       = A7
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPS
description  = "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."

[CMPS m32, m32]
opcode       = A7
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPS
description  = "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly."

[CMPS m64, m64]
opcode       = REX.W+ A7
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPS
description  = "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."

[CMPSB]
opcode       = A6
operand      = NP
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPSB
description  = "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64- bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."

[CMPSW]
opcode       = PREF.66+ A7
operand      = NP
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPSW
description  = "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64- bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."

[CMPSD]
opcode       = A7
operand      = NP
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPSL
description  = "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."

[CMPSQ]
opcode       = REX.W+ A7
operand      = NP
iread        = E.DF ESI rsi EDI rdi
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPSQ
description  = "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."

[CMPSD xmm1, xmm2/m64, imm8]
opcode       = F2 0F C2 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CMPSD
description  = "Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate."

[VCMPSD xmm1, xmm2, xmm3/m64, imm8]
opcode       = VEX.NDS.LIG.F2.0F.WIG C2 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCMPSD
description  = "Compare low double precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate."

[CMPSS xmm1, xmm2/m32, imm8]
opcode       = F3 0F C2 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CMPSS
description  = "Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate."

[VCMPSS xmm1, xmm2, xmm3/m32, imm8]
opcode       = VEX.NDS.LIG.F3.0F.WIG C2 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCMPSS
description  = "Compare low single precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate."

[CMPXCHG r/m8, r8]
opcode       = 0F B0 /r
operand      = MR
props        = Rw, R
iread        = AL
iwrite       = al E.ZF E.CF E.PF E.AF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPXCHGB
description  = "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."

[CMPXCHG r/m8,r8]
opcode       = REX+ 0F B0 /r
operand      = MR
props        = Rw, R
iread        = AL
iwrite       = al E.ZF E.CF E.PF E.AF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPXCHGB
description  = "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."

[CMPXCHG r/m16, r16]
opcode       = 0F B1 /r
operand      = MR
props        = Rw, R
iread        = AX
iwrite       = ax E.ZF E.CF E.PF E.AF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPXCHGW
description  = "Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX."

[CMPXCHG r/m32, r32]
opcode       = 0F B1 /r
operand      = MR
props        = Rz, R
iread        = EAX
iwrite       = rax E.ZF E.CF E.PF E.AF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CMPXCHGL
description  = "Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX."

[CMPXCHG r/m64, r64]
opcode       = REX.W+ 0F B1 /r
operand      = MR
props        = Rw, R
iread        = RAX
iwrite       = Rax E.ZF E.CF E.PF E.AF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CMPXCHGQ
description  = "Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX."

[CMPXCHG8B m64]
opcode       = 0F C7 /1
operand      = M
props        = Rw
iread        = EAX EDX
iwrite       = rax rbx rcx rdx E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = CX8
preferred    = 0
att_mnemonic = CMPXCHG8B
description  = "Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX."

[CMPXCHG16B m128]
opcode       = REX.W+ 0F C7 /1
operand      = M
props        = Rw
iread        = RAX RDX
iwrite       = rax rbx rcx rdx E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = CX16
preferred    = 0
att_mnemonic = CMPXCHG16B
description  = "Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX."

[COMISD xmm1, xmm2/m64]
opcode       = 66 0F 2F /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = COMISD
description  = "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."

[VCOMISD xmm1, xmm2/m64]
opcode       = VEX.LIG.66.0F.WIG 2F /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCOMISD
description  = "Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."

[COMISS xmm1, xmm2/m32]
opcode       = 0F 2F /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = COMISS
description  = "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."

[VCOMISS xmm1, xmm2/m32]
opcode       = VEX.LIG.0F.WIG 2F /r
operand      = RM
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCOMISS
description  = "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."

[CPUID]
opcode       = 0F A2
operand      = NP
iread        = EAX ecx
iwrite       = RAX RBX RCX RDX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CPUID
description  = "Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well)."

[CRC32 r32, r/m8]
opcode       = F2 0F 38 F0 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CRC32B
description  = "Accumulate CRC32 on r/m8."

[CRC32 r32, r/m8]
opcode       = F2 REX+ 0F 38 F0 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CRC32B
description  = "Accumulate CRC32 on r/m8."

[CRC32 r32, r/m16]
opcode       = F2 0F 38 F1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CRC32W
description  = "Accumulate CRC32 on r/m16."

[CRC32 r32, r/m32]
opcode       = F2 0F 38 F1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CRC32L
description  = "Accumulate CRC32 on r/m32."

[CRC32 r64, r/m8]
opcode       = F2 REX.W+ 0F 38 F0 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CRC32B
description  = "Accumulate CRC32 on r/m8."

[CRC32 r64, r/m64]
opcode       = F2 REX.W+ 0F 38 F1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CRC32Q
description  = "Accumulate CRC32 on r/m64."

[CVTDQ2PD xmm1, xmm2/m64]
opcode       = F3 0F E6
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTDQ2PD
description  = "Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1."

[VCVTDQ2PD xmm1, xmm2/m64]
opcode       = VEX.128.F3.0F.WIG E6 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTDQ2PD
description  = "Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."

[VCVTDQ2PD ymm1, xmm2/m128]
opcode       = VEX.256.F3.0F.WIG E6 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTDQ2PD
description  = "Convert four packed signed doubleword integers from ymm2/mem to four packed double-precision floating-point values in ymm1."

[CVTDQ2PS xmm1, xmm2/m128]
opcode       = 0F 5B /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTDQ2PS
description  = "Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1."

[VCVTDQ2PS xmm1, xmm2/m128]
opcode       = VEX.128.0F.WIG 5B /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTDQ2PS
description  = "Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1."

[VCVTDQ2PS ymm1, ymm2/m256]
opcode       = VEX.256.0F.WIG 5B /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTDQ2PS
description  = "Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1."

[CVTPD2DQ xmm1, xmm2/m128]
opcode       = F2 0F E6
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTPD2DQ
description  = "Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1."

[VCVTPD2DQ xmm1, xmm2/m128]
opcode       = VEX.128.F2.0F.WIG E6 /r
operand      = RM
props        = Z, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPD2DQ
description  = "Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1."

[VCVTPD2DQ xmm1, ymm2/m256]
opcode       = VEX.256.F2.0F.WIG E6 /r
operand      = RM
props        = Z, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPD2DQ
description  = "Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1."

[CVTPD2PI mm, xmm/m128]
opcode       = 66 0F 2D /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CVTPD2PI
description  = "Convert two packed double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm."

[CVTPD2PS xmm1, xmm2/m128]
opcode       = 66 0F 5A /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTPD2PS
description  = "Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1."

[VCVTPD2PS xmm1, xmm2/m128]
opcode       = VEX.128.66.0F.WIG 5A /r
operand      = RM
props        = Z, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPD2PS
description  = "Convert two packed double-precision floating- point values in xmm2/mem to two single- precision floating-point values in xmm1."

[VCVTPD2PS xmm1, ymm2/m256]
opcode       = VEX.256.66.0F.WIG 5A /r
operand      = RM
props        = Z, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPD2PS
description  = "Convert four packed double-precision floating- point values in ymm2/mem to four single- precision floating-point values in xmm1."

[CVTPI2PD xmm, mm/m64]
opcode       = 66 0F 2A /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CVTPI2PD
description  = "Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm."

[CVTPI2PS xmm, mm/m64]
opcode       = 0F 2A /r
operand      = RM
props        = RW, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CVTPI2PS
description  = "Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm."

[CVTPS2DQ xmm1, xmm2/m128]
opcode       = 66 0F 5B /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTPS2DQ
description  = "Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1."

[VCVTPS2DQ xmm1, xmm2/m128]
opcode       = VEX.128.66.0F.WIG 5B /r
operand      = RM
props        = Z, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPS2DQ
description  = "Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1."

[VCVTPS2DQ ymm1, ymm2/m256]
opcode       = VEX.256.66.0F.WIG 5B /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPS2DQ
description  = "Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1."

[CVTPS2PD xmm1, xmm2/m64]
opcode       = 0F 5A /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTPS2PD
description  = "Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."

[VCVTPS2PD xmm1, xmm2/m64]
opcode       = VEX.128.0F.WIG 5A /r
operand      = RM
props        = Z, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPS2PD
description  = "Convert two packed single-precision floating- point values in xmm2/mem to two packed double-precision floating-point values in xmm1."

[VCVTPS2PD ymm1, xmm2/m128]
opcode       = VEX.256.0F.WIG 5A /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTPS2PD
description  = "Convert four packed single-precision floating- point values in xmm2/mem to four packed double-precision floating-point values in ymm1."

[CVTPS2PI mm, xmm/m64]
opcode       = 0F 2D /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CVTPS2PI
description  = "Convert two packed single-precision floating- point values from xmm/m64 to two packed signed doubleword integers in mm."

[CVTSD2SI r32, xmm/m64]
opcode       = F2 0F 2D /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTSD2SI
description  = "Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32."

[CVTSD2SI r64, xmm/m64]
opcode       = F2 REX.W+ 0F 2D /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTSD2SI
description  = "Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64."

[VCVTSD2SI r32, xmm1/m64]
opcode       = VEX.LIG.F2.0F.W0 2D /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSD2SI
description  = "Convert one double precision floating-point value from xmm1/m64 to one signed doubleword integer r32."

[VCVTSD2SI r64, xmm1/m64]
opcode       = VEX.LIG.F2.0F.W1 2D /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSD2SI
description  = "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64."

[CVTSD2SS xmm1, xmm2/m64]
opcode       = F2 0F 5A /r
operand      = RM
props        = RW, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTSD2SS
description  = "Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1."

[VCVTSD2SS xmm1,xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 5A /r
operand      = RVM
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSD2SS
description  = "Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2."

[CVTSI2SD xmm, r/m32]
opcode       = F2 0F 2A /r
operand      = RM
props        = RW, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTSI2SDL
description  = "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm."

[CVTSI2SD xmm, r/m64]
opcode       = F2 REX.W+ 0F 2A /r
operand      = RM
props        = RW, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTSI2SDQ
description  = "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm."

[VCVTSI2SD xmm1, xmm2, r/m32]
opcode       = VEX.NDS.LIG.F2.0F.W0 2A /r
operand      = RVM
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSI2SDL
description  = "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1."

[VCVTSI2SD xmm1, xmm2, r/m64]
opcode       = VEX.NDS.LIG.F2.0F.W1 2A /r
operand      = RVM
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSI2SDQ
description  = "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."

[CVTSI2SS xmm, r/m32]
opcode       = F3 0F 2A /r
operand      = RM
props        = RW, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CVTSI2SSL
description  = "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm."

[CVTSI2SS xmm, r/m64]
opcode       = F3 REX.W+ 0F 2A /r
operand      = RM
props        = RW, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CVTSI2SSQ
description  = "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm."

[VCVTSI2SS xmm1, xmm2, r/m32]
opcode       = VEX.NDS.LIG.F3.0F.W0 2A /r
operand      = RVM
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSI2SSL
description  = "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."

[VCVTSI2SS xmm1, xmm2, r/m64]
opcode       = VEX.NDS.LIG.F3.0F.W1 2A /r
operand      = RVM
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSI2SSQ
description  = "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."

[CVTSS2SD xmm1, xmm2/m32]
opcode       = F3 0F 5A /r
operand      = RM
props        = RW, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTSS2SD
description  = "Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1."

[VCVTSS2SD xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 5A /r
operand      = RVM
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSS2SD
description  = "Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2."

[CVTSS2SI r32, xmm/m32]
opcode       = F3 0F 2D /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CVTSS2SI
description  = "Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32."

[CVTSS2SI r64, xmm/m32]
opcode       = F3 REX.W+ 0F 2D /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CVTSS2SI
description  = "Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64."

[VCVTSS2SI r32, xmm1/m32]
opcode       = VEX.LIG.F3.0F.W0 2D /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSS2SI
description  = "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."

[VCVTSS2SI r64, xmm1/m32]
opcode       = VEX.LIG.F3.0F.W1 2D /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTSS2SI
description  = "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."

[CVTTPD2DQ xmm1, xmm2/m128]
opcode       = 66 0F E6
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTTPD2DQ
description  = "Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation."

[VCVTTPD2DQ xmm1, xmm2/m128]
opcode       = VEX.128.66.0F.WIG E6 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTPD2DQ
description  = "Convert two packed double-precision floating- point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."

[VCVTTPD2DQ xmm1, ymm2/m256]
opcode       = VEX.256.66.0F.WIG E6 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTPD2DQ
description  = "Convert four packed double-precision floating- point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation."

[CVTTPD2PI mm, xmm/m128]
opcode       = 66 0F 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CVTTPD2PI
description  = "Convert two packer double-precision floating- point values from xmm/m128 to two packed signed doubleword integers in mm using truncation."

[CVTTPS2DQ xmm1, xmm2/m128]
opcode       = F3 0F 5B /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTTPS2DQ
description  = "Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation."

[VCVTTPS2DQ xmm1, xmm2/m128]
opcode       = VEX.128.F3.0F.WIG 5B /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTPS2DQ
description  = "Convert four packed single precision floating- point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."

[VCVTTPS2DQ ymm1, ymm2/m256]
opcode       = VEX.256.F3.0F.WIG 5B /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTPS2DQ
description  = "Convert eight packed single precision floating- point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation."

[CVTTPS2PI mm, xmm/m64]
opcode       = 0F 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CVTTPS2PI
description  = "Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation."

[CVTTSD2SI r32, xmm/m64]
opcode       = F2 0F 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTTSD2SI
description  = "Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation."

[CVTTSD2SI r64, xmm/m64]
opcode       = F2 REX.W+ 0F 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = CVTTSD2SI
description  = "Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation."

[VCVTTSD2SI r32, xmm1/m64]
opcode       = VEX.LIG.F2.0F.W0 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTSD2SI
description  = "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."

[VCVTTSD2SI r64, xmm1/m64]
opcode       = VEX.LIG.F2.0F.W1 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTSD2SI
description  = "Convert one double precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."

[CVTTSS2SI r32, xmm/m32]
opcode       = F3 0F 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CVTTSS2SI
description  = "Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation."

[CVTTSS2SI r64, xmm/m32]
opcode       = F3 REX.W+ 0F 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = CVTTSS2SI
description  = "Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation."

[VCVTTSS2SI r32, xmm1/m32]
opcode       = VEX.LIG.F3.0F.W0 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTSS2SI
description  = "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."

[VCVTTSS2SI r64, xmm1/m32]
opcode       = VEX.LIG.F3.0F.W1 2C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VCVTTSS2SI
description  = "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."

[CWD]
opcode       = PREF.66+ 99
operand      = NP
iread        = AX
iwrite       = DX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CWTD
description  = "DX:AX = sign-extend of AX."

[CDQ]
opcode       = 99
operand      = NP
iread        = EAX
iwrite       = RDX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = CLTD
description  = "EDX:EAX = sign-extend of EAX."

[CQO]
opcode       = REX.W+ 99
operand      = NP
iread        = RAX
iwrite       = RDX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = CQTO
description  = "RDX:RAX = sign-extend of RAX."

[DAA]
opcode       = 27
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Decimal adjust AL after addition."

[DAS]
opcode       = 2F
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Decimal adjust AL after subtraction."

[DEC r/m8]
opcode       = FE /1
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = DECB
description  = "Decrement r/m8 by 1."

[DEC r/m8]
opcode       = REX+ FE /1
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = DECB
description  = "Decrement r/m8 by 1."

[DEC r/m16]
opcode       = FF /1
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = DECW
description  = "Decrement r/m16 by 1."

[DEC r/m32]
opcode       = FF /1
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = DECL
description  = "Decrement r/m32 by 1."

[DEC r/m64]
opcode       = REX.W+ FF /1
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = DECQ
description  = "Decrement r/m64 by 1."

[DEC r16]
opcode       = 48 +rw
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Decrement r16 by 1."

[DEC r32]
opcode       = 48 +rd
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Decrement r32 by 1."

[DIV r/m8]
opcode       = F6 /6
operand      = M
props        = R
iread        = AX
iwrite       = AX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = DIVB
description  = "Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder."

[DIV r/m8]
opcode       = REX+ F6 /6
operand      = M
props        = R
iread        = AX
iwrite       = AX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = DIVB
description  = "Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder."

[DIV r/m16]
opcode       = F7 /6
operand      = M
props        = R
iread        = AX DX
iwrite       = AX DX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = DIVW
description  = "Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder."

[DIV r/m32]
opcode       = F7 /6
operand      = M
props        = R
iread        = EAX EDX
iwrite       = RAX RDX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = DIVL
description  = "Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder."

[DIV r/m64]
opcode       = REX.W+ F7 /6
operand      = M
props        = R
iread        = RAX RDX
iwrite       = RAX RDX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = DIVQ
description  = "Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder."

[DIVPD xmm1, xmm2/m128]
opcode       = 66 0F 5E /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = DIVPD
description  = "Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128."

[VDIVPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 5E /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDIVPD
description  = "Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem."

[VDIVPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 5E /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDIVPD
description  = "Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem."

[DIVPS xmm1, xmm2/m128]
opcode       = 0F 5E /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = DIVPS
description  = "Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128."

[VDIVPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 5E /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDIVPS
description  = "Divide packed single-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem."

[VDIVPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 5E /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDIVPS
description  = "Divide packed single-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem."

[DIVSD xmm1, xmm2/m64]
opcode       = F2 0F 5E /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = DIVSD
description  = "Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64."

[VDIVSD xmm1, xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 5E /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDIVSD
description  = "Divide low double-precision floating point values in xmm2 by low double precision floating-point value in xmm3/mem64."

[DIVSS xmm1, xmm2/m32]
opcode       = F3 0F 5E /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = DIVSS
description  = "Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32."

[VDIVSS xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 5E /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDIVSS
description  = "Divide low single-precision floating point value in xmm2 by low single precision floating-point value in xmm3/m32."

[DPPD xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 41 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = DPPD
description  = "Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1."

[VDPPD xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 41 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDPPD
description  = "Selectively multiply packed DP floating-point values from xmm2 with packed DP floating- point values from xmm3, add and selectively store the packed DP floating-point values to xmm1."

[DPPS xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 40 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = DPPS
description  = "Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1."

[VDPPS xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 40 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDPPS
description  = "Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1."

[VDPPS ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.WIG 40 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VDPPS
description  = "Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1."

[EMMS]
opcode       = 0F 77
operand      = NP
iwrite       = TAG(*)
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = EMMS
description  = "Set the x87 FPU tag word to empty."

[ENTER 0, imm16]
opcode       = C8 ib iw
operand      = II
props        = R, R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ENTERQ
description  = "Create a stack frame for a procedure."

[ENTER 1, imm16]
opcode       = C8 ib iw
operand      = II
props        = R, R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ENTERQ
description  = "Create a nested stack frame for a procedure."

[ENTER imm8, imm16]
opcode       = C8 ib iw
operand      = II
props        = R, R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ENTERQ
description  = "Create a nested stack frame for a procedure."

[EXTRACTPS reg/m32, xmm2, imm8]
opcode       = 66 0F 3A 17 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = EXTRACTPS
description  = "Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64."

[VEXTRACTPS r/m32, xmm1, imm8]
opcode       = VEX.128.66.0F3A.WIG 17 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VEXTRACTPS
description  = "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."

[F2XM1]
opcode       = D9 F0
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = F2XM1
description  = "Replace ST(0) with (2^(ST(0)) - 1)."

[FABS]
opcode       = D9 E1
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FABS
description  = "Replace ST with its absolute value."

[FADD m32fp]
opcode       = D8 /0
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FADDS
description  = "Add m32fp to ST(0) and store result in ST(0)."

[FADD m64fp]
opcode       = DC /0
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FADDL
description  = "Add m64fp to ST(0) and store result in ST(0)."

[FADD ST(0), ST(i)]
opcode       = D8 C0 +i
operand      = TO
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FADD
description  = "Add ST(0) to ST(i) and store result in ST(0)."

[FADD ST(i), ST(0)]
opcode       = DC C0 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FADD
description  = "Add ST(i) to ST(0) and store result in ST(i)."

[FADDP ST(i), ST(0)]
opcode       = DE C0 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FADDP
description  = "Add ST(0) to ST(i), store result in ST(i), and pop the register stack."

[FADDP]
opcode       = DE C1
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FADDP
description  = "Add ST(0) to ST(1), store result in ST(1), and pop the register stack."

[FIADD m32int]
opcode       = DA /0
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIADDL
description  = "Add m32int to ST(0) and store result in ST(0)."

[FIADD m16int]
opcode       = DE /0
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIADD
description  = "Add m16int to ST(0) and store result in ST(0)."

[FBLD m80bcd]
opcode       = DF /4
operand      = M
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FBLD
description  = "Convert BCD value to floating-point and push onto the FPU stack."

[FBSTP m80bcd]
opcode       = DF /6
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FBSTP
description  = "Store ST(0) in m80bcd and pop ST(0)."

[FCHS]
opcode       = D9 E0
iread        = ST(0)
iwrite       = ST(0)
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCHS
description  = "Complements sign of ST(0)."

[FCLEX]
opcode       = 9B DB E2
iwrite       = S.PE S.UE S.OE S.ZE S.DE S.IE S.ES S.SF S.B
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCLEX
description  = "Clear floating-point exception flags after checking for pending unmasked floating-point exceptions."

[FNCLEX]
opcode       = DB E2
iwrite       = S.PE S.UE S.OE S.ZE S.DE S.IE S.ES S.SF S.B
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNCLEX
description  = "Clear floating-point exception flags without checking for pending unmasked floating-point exceptions."

[FCMOVB ST(0), ST(i)]
opcode       = DA C0 +i
operand      = TO
props        = w, R
iread        = E.CF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVB
description  = "Move if below (CF=1)."

[FCMOVE ST(0), ST(i)]
opcode       = DA C8 +i
operand      = TO
props        = w, R
iread        = E.ZF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVE
description  = "Move if equal (ZF=1)."

[FCMOVBE ST(0), ST(i)]
opcode       = DA D0 +i
operand      = TO
props        = w, R
iread        = E.CF E.ZF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVBE
description  = "Move if below or equal (CF=1 or ZF=1)."

[FCMOVU ST(0), ST(i)]
opcode       = DA D8 +i
operand      = TO
props        = w, R
iread        = E.PF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVU
description  = "Move if unordered (PF=1)."

[FCMOVNB ST(0), ST(i)]
opcode       = DB C0 +i
operand      = TO
props        = w, R
iread        = E.CF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVNB
description  = "Move if not below (CF=0)."

[FCMOVNE ST(0), ST(i)]
opcode       = DB C8 +i
operand      = TO
props        = w, R
iread        = E.ZF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVNE
description  = "Move if not equal (ZF=0)."

[FCMOVNBE ST(0), ST(i)]
opcode       = DB D0 +i
operand      = TO
props        = w, R
iread        = E.CF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVNBE
description  = "Move if not below or equal (CF=0 and ZF=0)."

[FCMOVNU ST(0), ST(i)]
opcode       = DB D8 +i
operand      = TO
props        = w, R
iread        = E.PF
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU CMOV
preferred    = 0
att_mnemonic = FCMOVNU
description  = "Move if not unordered (PF=0)."

[FCOM m32fp]
opcode       = D8 /2
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMS
description  = "Compare ST(0) with m32fp."

[FCOM m64fp]
opcode       = DC /2
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOML
description  = "Compare ST(0) with m64fp."

[FCOM ST(i)]
opcode       = D8 D0 +i
operand      = O
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOM
description  = "Compare ST(0) with ST(i)."

[FCOM]
opcode       = D8 D1
iread        = ST(0) ST(1)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOM
description  = "Compare ST(0) with ST(1)."

[FCOMP m32fp]
opcode       = D8 /3
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMPS
description  = "Compare ST(0) with m32fp and pop register stack."

[FCOMP m64fp]
opcode       = DC /3
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMPL
description  = "Compare ST(0) with m64fp and pop register stack."

[FCOMP ST(i)]
opcode       = D8 D8 +i
operand      = O
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMP
description  = "Compare ST(0) with ST(i) and pop register stack."

[FCOMP]
opcode       = D8 D9
iread        = ST(0) ST(1)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMP
description  = "Compare ST(0) with ST(1) and pop register stack."

[FCOMPP]
opcode       = DE D9
iread        = ST(0) ST(1)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMPP
description  = "Compare ST(0) with ST(1) and pop register stack twice."

[FCOMI ST, ST(i)]
opcode       = DB F0 +i
operand      = TO
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF S.C1
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMI
description  = "Compare ST(0) with ST(i) and set status flags accordingly."

[FCOMIP ST, ST(i)]
opcode       = DF F0 +i
operand      = TO
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF S.C1
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOMIP
description  = "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."

[FUCOMI ST, ST(i)]
opcode       = DB E8 +i
operand      = TO
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF S.C1
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FUCOMI
description  = "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."

[FUCOMIP ST, ST(i)]
opcode       = DF E8 +i
operand      = TO
props        = R, R
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF S.C1
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FUCOMIP
description  = "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."

[FCOS]
opcode       = D9 FF
iread        = ST(0)
iwrite       = ST(0) s.c1 S.C2
iundef       = s.c1 S.C0 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FCOS
description  = "Replace ST(0) with its cosine."

[FDECSTP]
opcode       = D9 F6
iread        = S.TOP
iwrite       = S.TOP S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDECSTP
description  = "Decrement TOP field in FPU status word."

[FDIV m32fp]
opcode       = D8 /6
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVS
description  = "Divide ST(0) by m32fp and store result in ST(0)."

[FDIV m64fp]
opcode       = DC /6
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVL
description  = "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."

[FDIV ST(0), ST(i)]
opcode       = D8 F0 +i
operand      = TO
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIV
description  = "Divide ST(0) by ST(i) and store result in ST(0)."

[FDIV ST(i), ST(0)]
opcode       = DC F0 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIV
description  = "Divide ST(i) by ST(0) and store result in ST(i)."

[FDIVP ST(i), ST(0)]
opcode       = DE F0 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVP
description  = "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."

[FDIVP]
opcode       = DE F1
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVP
description  = "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack."

[FIDIV m32int]
opcode       = DA /6
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIDIVL
description  = "Divide ST(0) by m32int and store result in ST(0)."

[FIDIV m16int]
opcode       = DE /6
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIDIV
description  = "Divide ST(0) by m64int and store result in ST(0)."

[FDIVR m32fp]
opcode       = D8 /7
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVRS
description  = "Divide m32fp by ST(0) and store result in ST(0)."

[FDIVR m64fp]
opcode       = DC /7
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVRL
description  = "Divide m64fp by ST(0) and store result in ST(0)."

[FDIVR ST(0), ST(i)]
opcode       = D8 F8 +i
operand      = TO
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVR
description  = "Divide ST(i) by ST(0) and store result in ST(0)."

[FDIVR ST(i), ST(0)]
opcode       = DC F8 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVR
description  = "Divide ST(0) by ST(i) and store result in ST(i)."

[FDIVRP ST(i), ST(0)]
opcode       = DE F8 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVRP
description  = "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."

[FDIVRP]
opcode       = DE F9
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FDIVRP
description  = "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack."

[FIDIVR m32int]
opcode       = DA /7
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIDIVRL
description  = "Divide m32int by ST(0) and store result in ST(0)."

[FIDIVR m16int]
opcode       = DE /7
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIDIVR
description  = "Divide m16int by ST(0) and store result in ST(0)."

[FFREE ST(i)]
opcode       = DD C0 +i
operand      = O
props        = I
iundef       = S.C0 S.C1 s.c2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FFREEP
description  = "Sets tag for ST(i) to empty."

[FICOM m16int]
opcode       = DE /2
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FICOM
description  = "Compare ST(0) with m16int."

[FICOM m32int]
opcode       = DA /2
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FICOML
description  = "Compare ST(0) with m32int."

[FICOMP m16int]
opcode       = DE /3
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FICOMP
description  = "Compare ST(0) with m16int and pop stack register."

[FICOMP m32int]
opcode       = DA /3
operand      = M
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FICOMPL
description  = "Compare ST(0) with m32int and pop stack register."

[FILD m16int]
opcode       = DF /0
operand      = M
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FILD
description  = "Push m16int onto the FPU register stack."

[FILD m32int]
opcode       = DB /0
operand      = M
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FILDL
description  = "Push m32int onto the FPU register stack."

[FILD m64int]
opcode       = DF /5
operand      = M
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FILDLL
description  = "Push m64int onto the FPU register stack."

[FINCSTP]
opcode       = D9 F7
iread        = S.TOP
iwrite       = S.TOP S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FINCSTP
description  = "Increment the TOP field in the FPU status register."

[FINIT]
opcode       = 9B DB E3
iwrite       = S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FINIT
description  = "Initialize FPU after checking for pending unmasked floating-point exceptions."

[FNINIT]
opcode       = DB E3
iwrite       = S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNINIT
description  = "Initialize FPU without checking for pending unmasked floating-point exceptions."

[FIST m16int]
opcode       = DF /2
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIST
description  = "Store ST(0) in m16int."

[FIST m32int]
opcode       = DB /2
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISTL
description  = "Store ST(0) in m32int."

[FISTP m16int]
opcode       = DF /3
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISTP
description  = "Store ST(0) in m16int and pop register stack."

[FISTP m32int]
opcode       = DB /3
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISTPL
description  = "Store ST(0) in m32int and pop register stack."

[FISTP m64int]
opcode       = DF /7
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISTPLL
description  = "Store ST(0) in m64int and pop register stack."

[FISTTP m16int]
opcode       = DF /1
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISTTP
description  = "Store ST(0) in m16int with truncation."

[FISTTP m32int]
opcode       = DB /1
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISTTPL
description  = "Store ST(0) in m32int with truncation."

[FISTTP m64int]
opcode       = DD /1
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISTTPLL
description  = "Store ST(0) in m64int with truncation."

[FLD m32fp]
opcode       = D9 /0
operand      = M
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDS
description  = "Push m32fp onto the FPU register stack."

[FLD m64fp]
opcode       = DD /0
operand      = M
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDL
description  = "Push m64fp onto the FPU register stack."

[FLD m80fp]
opcode       = DB /5
operand      = M
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDT
description  = "Push m80fp onto the FPU register stack."

[FLD ST(i)]
opcode       = D9 C0 +i
operand      = O
props        = R
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLD
description  = "Push ST(i) onto the FPU register stack."

[FLD1]
opcode       = D9 E8
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLD1
description  = "Push +1.0 onto the FPU register stack."

[FLDL2T]
opcode       = D9 E9
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDL2T
description  = "Push log210 onto the FPU register stack."

[FLDL2E]
opcode       = D9 EA
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDL2E
description  = "Push log2e onto the FPU register stack."

[FLDPI]
opcode       = D9 EB
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDPI
description  = "Push pi onto the FPU register stack."

[FLDLG2]
opcode       = D9 EC
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDLG2
description  = "Push log102 onto the FPU register stack."

[FLDLN2]
opcode       = D9 ED
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDLN2
description  = "Push loge2 onto the FPU register stack."

[FLDZ]
opcode       = D9 EE
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDZ
description  = "Push +0.0 onto the FPU register stack."

[FLDCW m2byte]
opcode       = D9 /5
operand      = M
props        = R
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDCW
description  = "Load FPU control word from m2byte."

[FLDENV m28byte]
opcode       = D9 /4
operand      = M
props        = R
iwrite       = S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FLDENVL
description  = "Load FPU environment from m14byte or m28byte."

[FMUL m32fp]
opcode       = D8 /1
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FMULS
description  = "Multiply ST(0) by m32fp and store result in ST(0)."

[FMUL m64fp]
opcode       = DC /1
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FMULL
description  = "Multiply ST(0) by m64fp and store result in ST(0)."

[FMUL ST(0), ST(i)]
opcode       = D8 C8 +i
operand      = TO
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FMUL
description  = "Multiply ST(0) by ST(i) and store result in ST(0)."

[FMUL ST(i), ST(0)]
opcode       = DC C8 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FMUL
description  = "Multiply ST(i) by ST(0) and store result in ST(i)."

[FMULP ST(i), ST(0)]
opcode       = DE C8 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FMULP
description  = "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."

[FMULP]
opcode       = DE C9
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FMULP
description  = "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack."

[FIMUL m32int]
opcode       = DA /1
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIMULL
description  = "Multiply ST(0) by m32int and store result in ST(0)."

[FIMUL m16int]
opcode       = DE /1
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FIMUL
description  = "Multiply ST(0) by m16int and store result in ST(0)."

[FNOP]
opcode       = D9 D0
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNOP
description  = "No operation is performed."

[FPATAN]
opcode       = D9 F3
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FPATAN
description  = "Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack."

[FPREM]
opcode       = D9 F8
iread        = ST(0) ST(1)
iwrite       = ST(0) S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FPREM
description  = "Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1)."

[FPREM1]
opcode       = D9 F5
iread        = ST(0) ST(1)
iwrite       = ST(0) S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FPREM1
description  = "Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1)."

[FPTAN]
opcode       = D9 F2
iread        = ST(0)
iwrite       = ST(0) S.C1 S.C2
iundef       = S.C0 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FPTAN
description  = "Replace ST(0) with its tangent and push 1 onto the FPU stack."

[FRNDINT]
opcode       = D9 FC
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FRNDINT
description  = "Round ST(0) to an integer."

[FRSTOR m108byte]
opcode       = DD /4
operand      = M
props        = R
iwrite       = ST(*) TAG(*) FPUDATA FPUINSTR S.* M.*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FRSTOR
description  = "Load FPU state from m94byte or m108byte."

[FSAVE m108byte]
opcode       = 9B DD /6
operand      = M
props        = W
iread        = ST(*) S.* FPUDATA FPUINSTR FPUOPCODE
iwrite       = ST(*) TAG(*) S.* FPUDATA FPUINSTR FPUOPCODE
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSAVE
description  = "Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."

[FNSAVE m108byte]
opcode       = DD /6
operand      = M
props        = W
iread        = ST(*) S.* FPUDATA FPUINSTR FPUOPCODE
iwrite       = ST(*) TAG(*) S.* FPUDATA FPUINSTR FPUOPCODE
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNSAVE
description  = "Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."

[FSCALE]
opcode       = D9 FD
iread        = ST(0) ST(1)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSCALE
description  = "Scale ST(0) by ST(1)."

[FSIN]
opcode       = D9 FE
iread        = ST(0)
iwrite       = ST(0) S.C1 S.C2
iundef       = S.C0 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSIN
description  = "Replace ST(0) with its sine."

[FSINCOS]
opcode       = D9 FB
iread        = ST(0)
iwrite       = ST(0) S.C1 S.C2
iundef       = S.C0 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSINCOS
description  = "Compute the sine and cosine of ST(0); replace ST(0) with the sine, and push the cosine onto the register stack."

[FSQRT]
opcode       = D9 FA
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSQRT
description  = "Computes square root of ST(0) and stores the result in ST(0)."

[FST m32fp]
opcode       = D9 /2
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTS
description  = "Copy ST(0) to m32fp."

[FST m64fp]
opcode       = DD /2
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTL
description  = "Copy ST(0) to m64fp."

[FST ST(i)]
opcode       = DD D0 +i
operand      = O
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FST
description  = "Copy ST(0) to ST(i)."

[FSTP m32fp]
opcode       = D9 /3
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTPS
description  = "Copy ST(0) to m32fp and pop register stack."

[FSTP m64fp]
opcode       = DD /3
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTPL
description  = "Copy ST(0) to m64fp and pop register stack."

[FSTP m80fp]
opcode       = DB /7
operand      = M
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTPT
description  = "Copy ST(0) to m80fp and pop register stack."

[FSTP ST(i)]
opcode       = DD D8 +i
operand      = O
props        = W
iread        = ST(0)
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTP
description  = "Copy ST(0) to ST(i) and pop register stack."

[FSTCW m2byte]
opcode       = 9B D9 /7
operand      = M
props        = W
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTCW
description  = "Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions."

[FNSTCW m2byte]
opcode       = D9 /7
operand      = M
props        = W
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNSTCW
description  = "Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions."

[FSTENV m28byte]
opcode       = 9B D9 /6
operand      = M
props        = W
iwrite       = S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTENVL
description  = "Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."

[FNSTENV m28byte]
opcode       = D9 /6
operand      = M
props        = W
iwrite       = S.* TAG(*) FPUDATA FPUINSTR FPUOPCODE
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNSTENVL
description  = "Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."

[FSTSW m2byte]
opcode       = 9B DD /7
operand      = M
props        = W
iwrite       = S.*
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTSW
description  = "Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions."

[FSTSW AX]
opcode       = 9B DF E0
props        = W
iwrite       = S.*
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSTSW
description  = "Store FPU status word in AX register after checking for pending unmasked floating-point exceptions."

[FNSTSW m2byte]
opcode       = DD /7
operand      = M
props        = W
iwrite       = S.*
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNSTSW
description  = "Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions."

[FNSTSW AX]
opcode       = DF E0
props        = W
iwrite       = S.*
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FNSTSW
description  = "Store FPU status word in AX register without checking for pending unmasked floating-point exceptions."

[FSUB m32fp]
opcode       = D8 /4
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBS
description  = "Subtract m32fp from ST(0) and store result in ST(0)."

[FSUB m64fp]
opcode       = DC /4
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBL
description  = "Subtract m64fp from ST(0) and store result in ST(0)."

[FSUB ST(0), ST(i)]
opcode       = D8 E0 +i
operand      = TO
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUB
description  = "Subtract ST(i) from ST(0) and store result in ST(0)."

[FSUB ST(i), ST(0)]
opcode       = DC E0 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUB
description  = "Subtract ST(0) from ST(i) and store result in ST(i)."

[FSUBP ST(i), ST(0)]
opcode       = DE E0 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBP
description  = "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."

[FSUBP]
opcode       = DE E1
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBP
description  = "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack."

[FISUB m32int]
opcode       = DA /4
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISUBL
description  = "Subtract m32int from ST(0) and store result in ST(0)."

[FISUB m16int]
opcode       = DE /4
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISUB
description  = "Subtract m16int from ST(0) and store result in ST(0)."

[FSUBR m32fp]
opcode       = D8 /5
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBRS
description  = "Subtract ST(0) from m32fp and store result in ST(0)."

[FSUBR m64fp]
opcode       = DC /5
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBRL
description  = "Subtract ST(0) from m64fp and store result in ST(0)."

[FSUBR ST(0), ST(i)]
opcode       = D8 E8 +i
operand      = TO
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBR
description  = "Subtract ST(0) from ST(i) and store result in ST(0)."

[FSUBR ST(i), ST(0)]
opcode       = DC E8 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBR
description  = "Subtract ST(i) from ST(0) and store result in ST(i)."

[FSUBRP ST(i), ST(0)]
opcode       = DE E8 +i
operand      = OT
props        = RW, R
iwrite       = S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = FSUBRP
description  = "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."

[FSUBRP]
opcode       = DE E9
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FSUBRP
description  = "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack."

[FISUBR m32int]
opcode       = DA /5
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISUBRL
description  = "Subtract ST(0) from m32int and store result in ST(0)."

[FISUBR m16int]
opcode       = DE /5
operand      = M
props        = R
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FISUBR
description  = "Subtract ST(0) from m16int and store result in ST(0)."

[FTST]
opcode       = D9 E4
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FTST
description  = "Compare ST(0) with 0.0."

[FUCOM ST(i)]
opcode       = DD E0 +i
operand      = O
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FUCOM
description  = "Compare ST(0) with ST(i)."

[FUCOM]
opcode       = DD E1
iread        = ST(0) ST(1)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FUCOM
description  = "Compare ST(0) with ST(1)."

[FUCOMP ST(i)]
opcode       = DD E8 +i
operand      = O
props        = R
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FUCOMP
description  = "Compare ST(0) with ST(i) and pop register stack."

[FUCOMP]
opcode       = DD E9
iread        = ST(0) ST(1)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FUCOMP
description  = "Compare ST(0) with ST(1) and pop register stack."

[FUCOMPP]
opcode       = DA E9
iread        = ST(0) ST(1)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FUCOMPP
description  = "Compare ST(0) with ST(1) and pop register stack twice."

[FXAM]
opcode       = D9 E5
iread        = ST(0)
iwrite       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FXAM
description  = "Classify value or number in ST(0)."

[FXCH ST(i)]
opcode       = D9 C8 +i
operand      = O
props        = RW
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FXCH
description  = "Exchange the contents of ST(0) and ST(i)."

[FXCH]
opcode       = D9 C9
iread        = ST(0) ST(1)
iwrite       = ST(0) ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FXCH
description  = "Exchange the contents of ST(0) and ST(1)."

[FXRSTOR m512byte]
opcode       = 0F AE /1
operand      = M
props        = R
iwrite       = ST(*) MM* XMM* CS DS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU FXSR
preferred    = 0
att_mnemonic = FXRSTOR
description  = "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."

[FXRSTOR64 m512byte]
opcode       = REX.W+ 0F AE /1
operand      = M
props        = R
iwrite       = ST(*) MM* XMM*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = FPU FXSR
preferred    = 0
att_mnemonic = FXRSTOR64
description  = "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."

[FXSAVE m512byte]
opcode       = 0F AE /0
operand      = M
props        = W
iread        = ST(*) MM* XMM* M.* CS DS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU FXSR
preferred    = 0
att_mnemonic = FXSAVE
description  = "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."

[FXSAVE64 m512byte]
opcode       = REX.W+ 0F AE /0
operand      = M
props        = W
iread        = ST(*) MM* XMM* M.*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = FPU FXSR
preferred    = 0
att_mnemonic = FXSAVE64
description  = "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."

[FXTRACT]
opcode       = D9 F4
iread        = ST(0)
iwrite       = ST(0) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FXTRACT
description  = "Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack."

[FYL2X]
opcode       = D9 F1
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FYL2X
description  = "Replace ST(1) with (ST(1) * log2ST(0)) and pop the register stack."

[FYL2XP1]
opcode       = D9 F9
iread        = ST(0) ST(1)
iwrite       = ST(1) S.C1
iundef       = S.C0 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FYL2XP1
description  = "Replace ST(1) with ST(1) * log2(ST(0) + 1.0) and pop the register stack."

[HADDPD xmm1, xmm2/m128]
opcode       = 66 0F 7C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = HADDPD
description  = "Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1."

[VHADDPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 7C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHADDPD
description  = "Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem."

[VHADDPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 7C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHADDPD
description  = "Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem."

[HADDPS xmm1, xmm2/m128]
opcode       = F2 0F 7C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = HADDPS
description  = "Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1."

[VHADDPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.F2.0F.WIG 7C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHADDPS
description  = "Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem."

[VHADDPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.F2.0F.WIG 7C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHADDPS
description  = "Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem."

[HLT]
opcode       = F4
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Halt"

[HSUBPD xmm1, xmm2/m128]
opcode       = 66 0F 7D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = HSUBPD
description  = "Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1."

[VHSUBPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 7D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHSUBPD
description  = "Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem."

[VHSUBPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 7D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHSUBPD
description  = "Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem."

[HSUBPS xmm1, xmm2/m128]
opcode       = F2 0F 7D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = HSUBPS
description  = "Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1."

[VHSUBPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.F2.0F.WIG 7D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHSUBPS
description  = "Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem."

[VHSUBPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.F2.0F.WIG 7D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VHSUBPS
description  = "Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem."

[IDIV r/m8]
opcode       = F6 /7
operand      = M
props        = R
iread        = AX
iwrite       = AX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IDIVB
description  = "Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder."

[IDIV r/m8]
opcode       = REX+ F6 /7
operand      = M
props        = R
iread        = AX
iwrite       = AX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = IDIVB
description  = "Signed divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder."

[IDIV r/m16]
opcode       = F7 /7
operand      = M
props        = R
iread        = AX DX
iwrite       = AX DX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IDIVW
description  = "Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder."

[IDIV r/m32]
opcode       = F7 /7
operand      = M
props        = R
iread        = EAX EDX
iwrite       = RAX RDX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IDIVL
description  = "Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder."

[IDIV r/m64]
opcode       = REX.W+ F7 /7
operand      = M
props        = R
iread        = RAX RDX
iwrite       = RAX RDX
iundef       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = IDIVQ
description  = "Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder."

[IMUL r/m8]
opcode       = F6 /5
operand      = M
props        = R
iread        = AL
iwrite       = AX E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULB
description  = "AX= AL * r/m byte."

[IMUL r/m8]
opcode       = REX+ F6 /5
operand      = M
props        = R
iread        = AL
iwrite       = AX E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULB
description  = "AX= AL * r/m byte."

[IMUL r/m16]
opcode       = F7 /5
operand      = M
props        = R
iread        = AX
iwrite       = AX DX E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULW
description  = "DX:AX = AX * r/m word."

[IMUL r/m32]
opcode       = F7 /5
operand      = M
props        = R
iread        = EAX
iwrite       = RAX RDX E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULL
description  = "EDX:EAX = EAX * r/m32."

[IMUL r/m64]
opcode       = REX.W+ F7 /5
operand      = M
props        = R
iread        = RAX
iwrite       = RAX RDX E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = IMULQ
description  = "RDX:RAX = RAX * r/m64."

[IMUL r16, r/m16]
opcode       = 0F AF /r
operand      = RM
props        = RW, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULW
description  = "word register = word register * r/m16."

[IMUL r32, r/m32]
opcode       = 0F AF /r
operand      = RM
props        = RW, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULL
description  = "doubleword register = doubleword register *  r/m32."

[IMUL r64, r/m64]
opcode       = REX.W+ 0F AF /r
operand      = RM
props        = RW, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = IMULQ
description  = "Quadword register = Quadword register *  r/m64."

[IMUL r16, r/m16, imm8]
opcode       = 6B /r ib
operand      = RMI
props        = W, R, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULW
description  = "word register = r/m16 * sign-extended immediate byte."

[IMUL r32, r/m32, imm8]
opcode       = 6B /r ib
operand      = RMI
props        = W, R, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULL
description  = "doubleword register = r/m32 * sign- extended immediate byte."

[IMUL r64, r/m64, imm8]
opcode       = REX.W+ 6B /r ib
operand      = RMI
props        = W, R, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = IMULQ
description  = "Quadword register = r/m64 * sign-extended  immediate byte."

[IMUL r16, r/m16, imm16]
opcode       = 69 /r iw
operand      = RMI
props        = W, R, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULW
description  = "word register = r/m16 * immediate word."

[IMUL r32, r/m32, imm32]
opcode       = 69 /r id
operand      = RMI
props        = W, R, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IMULL
description  = "doubleword register = r/m32 * immediate doubleword."

[IMUL r64, r/m64, imm32]
opcode       = REX.W+ 69 /r id
operand      = RMI
props        = W, R, R
iwrite       = E.CF E.OF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = IMULQ
description  = "Quadword register = r/m64 * immediate doubleword."

[IN AL, imm8]
opcode       = E4 ib
operand      = I
props        = W, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INB
description  = "Input byte from imm8 I/O port address into AL."

[IN AX, imm8]
opcode       = E5 ib
operand      = I
props        = W, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INW
description  = "Input word from imm8 I/O port address into AX."

[IN EAX, imm8]
opcode       = E5 ib
operand      = I
props        = W, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INL
description  = "Input dword from imm8 I/O port address into EAX."

[IN AL,DX]
opcode       = EC
operand      = NP
props        = W, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INB
description  = "Input byte from I/O port in DX into AL."

[IN AX,DX]
opcode       = ED
operand      = NP
props        = W, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INW
description  = "Input word from I/O port in DX into AX."

[IN EAX,DX]
opcode       = ED
operand      = NP
props        = W, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INL
description  = "Input doubleword from I/O port in DX into EAX."

[INC r/m8]
opcode       = FE /0
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INCB
description  = "Increment r/m byte by 1."

[INC r/m8]
opcode       = REX+ FE /0
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = INCB
description  = "Increment r/m byte by 1."

[INC r/m16]
opcode       = FF /0
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INCW
description  = "Increment r/m word by 1."

[INC r/m32]
opcode       = FF /0
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INCL
description  = "Increment r/m doubleword by 1."

[INC r/m64]
opcode       = REX.W+ FF /0
operand      = M
props        = RW
iwrite       = E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = INCQ
description  = "Increment r/m quadword by 1."

[INC r16]
opcode       = 40 +rw
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Increment word register by 1."

[INC r32]
opcode       = 40 +rd
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Increment doubleword register by 1."

[INS m8, DX]
opcode       = 6C
operand      = NP
props        = I, R
iread        = E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INS
description  = "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI."

[INS m16, DX]
opcode       = 6D
operand      = NP
props        = I, R
iread        = E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INS
description  = "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI."

[INS m32, DX]
opcode       = 6D
operand      = NP
props        = I, R
iread        = E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INS
description  = "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI."

[INSB]
opcode       = 6C
operand      = NP
iread        = E.IOPL E.VM E.DF DX RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INSB
description  = "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI."

[INSW]
opcode       = PREF.66+ 6D
operand      = NP
iread        = E.IOPL E.VM E.DF DX RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INSW
description  = "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI."

[INSD]
opcode       = 6D
operand      = NP
iread        = E.IOPL E.VM E.DF DX RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INSL
description  = "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI."

[INSERTPS xmm1, xmm2/m32, imm8]
opcode       = 66 0F 3A 21 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = INSERTPS
description  = "Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8."

[VINSERTPS xmm1, xmm2, xmm3/m32, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 21 /r ib
operand      = RVMI
props        = RZ, RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VINSERTPS
description  = "Insert a single precision floating point value selected by imm8 from xmm3/m32 and merge into xmm2 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8."

[INT 3]
opcode       = CC
operand      = NP
props        = R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INT
description  = "Interrupt 3-trap to debugger."

[INT imm8]
opcode       = CD ib
operand      = I
props        = R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = INT
description  = "Interrupt vector number specified by immediate byte."

[INTO]
opcode       = CE
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Interrupt 4-if overflow flag is 1."

[INVD]
opcode       = 0F 08
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Flush internal caches; initiate flushing of external caches."

[INVLPG m]
opcode       = 0F 01 /7
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Invalidate TLB Entry for page that contains m."

[INVPCID r32, m128]
opcode       = 66 0F 38 82 /r
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
cpuid_flags  = INVPCID
preferred    = 0
description  = "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r32 and descriptor in m128."

[INVPCID r64, m128]
opcode       = 66 0F 38 82 /r
operand      = RM
props        = R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = INVPCID
preferred    = 0
att_mnemonic = INVPCID
description  = "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128."

[IRET]
opcode       = PREF.66+ CF
operand      = NP
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IRETW
description  = "Interrupt return (16-bit operand size)."

[IRETD]
opcode       = CF
operand      = NP
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = IRETL
description  = "Interrupt return (32-bit operand size)."

[IRETQ]
opcode       = REX.W+ CF
operand      = NP
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = IRETQ
description  = "Interrupt return (64-bit operand size)."

[JA rel8]
opcode       = 77 cb
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JA
description  = "Jump short if above (CF=0 and ZF=0)."

[JAE rel8]
opcode       = 73 cb
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JAE
description  = "Jump short if above or equal (CF=0)."

[JB rel8]
opcode       = 72 cb
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JB
description  = "Jump short if below (CF=1)."

[JBE rel8]
opcode       = 76 cb
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JBE
description  = "Jump short if below or equal (CF=1 or ZF=1)."

[JC rel8]
opcode       = 72 cb
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JC
description  = "Jump short if carry (CF=1)."

[JCXZ rel8]
opcode       = E3 cb
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Jump short if CX register is 0."

[JECXZ rel8]
opcode       = E3 cb
operand      = D
props        = R
iread        = ECX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JECXZ
description  = "Jump short if ECX register is 0."

[JRCXZ rel8]
opcode       = E3 cb
operand      = D
props        = R
iread        = RCX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = JRCXZ
description  = "Jump short if RCX register is 0."

[JE rel8]
opcode       = 74 cb
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JE
description  = "Jump short if equal (ZF=1)."

[JG rel8]
opcode       = 7F cb
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JG
description  = "Jump short if greater (ZF=0 and SF=OF)."

[JGE rel8]
opcode       = 7D cb
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JGE
description  = "Jump short if greater or equal (SF=OF)."

[JL rel8]
opcode       = 7C cb
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JL
description  = "Jump short if less (SF!= OF)."

[JLE rel8]
opcode       = 7E cb
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JLE
description  = "Jump short if less or equal (ZF=1 or SF!= OF)."

[JNA rel8]
opcode       = 76 cb
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNA
description  = "Jump short if not above (CF=1 or ZF=1)."

[JNAE rel8]
opcode       = 72 cb
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNAE
description  = "Jump short if not above or equal (CF=1)."

[JNB rel8]
opcode       = 73 cb
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNB
description  = "Jump short if not below (CF=0)."

[JNBE rel8]
opcode       = 77 cb
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNBE
description  = "Jump short if not below or equal (CF=0 and ZF=0)."

[JNC rel8]
opcode       = 73 cb
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNC
description  = "Jump short if not carry (CF=0)."

[JNE rel8]
opcode       = 75 cb
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNE
description  = "Jump short if not equal (ZF=0)."

[JNG rel8]
opcode       = 7E cb
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNG
description  = "Jump short if not greater (ZF=1 or SF!= OF)."

[JNGE rel8]
opcode       = 7C cb
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNGE
description  = "Jump short if not greater or equal (SF!= OF)."

[JNL rel8]
opcode       = 7D cb
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNL
description  = "Jump short if not less (SF=OF)."

[JNLE rel8]
opcode       = 7F cb
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNLE
description  = "Jump short if not less or equal (ZF=0 and SF=OF)."

[JNO rel8]
opcode       = 71 cb
operand      = D
props        = R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNO
description  = "Jump short if not overflow (OF=0)."

[JNP rel8]
opcode       = 7B cb
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNP
description  = "Jump short if not parity (PF=0)."

[JNS rel8]
opcode       = 79 cb
operand      = D
props        = R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNS
description  = "Jump short if not sign (SF=0)."

[JNZ rel8]
opcode       = 75 cb
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNZ
description  = "Jump short if not zero (ZF=0)."

[JO rel8]
opcode       = 70 cb
operand      = D
props        = R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JO
description  = "Jump short if overflow (OF=1)."

[JP rel8]
opcode       = 7A cb
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JP
description  = "Jump short if parity (PF=1)."

[JPE rel8]
opcode       = 7A cb
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JPE
description  = "Jump short if parity even (PF=1)."

[JPO rel8]
opcode       = 7B cb
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JPO
description  = "Jump short if parity odd (PF=0)."

[JS rel8]
opcode       = 78 cb
operand      = D
props        = R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JS
description  = "Jump short if sign (SF=1)."

[JZ rel8]
opcode       = 74 cb
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JZ
description  = "Jump short if zero (ZF = 1)."

[JA rel16]
opcode       = 0F 87 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode."

[JA rel32]
opcode       = 0F 87 cd
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JA
description  = "Jump near if above (CF=0 and ZF=0)."

[JAE rel16]
opcode       = 0F 83 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if above or equal (CF=0). Not supported in 64-bit mode."

[JAE rel32]
opcode       = 0F 83 cd
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JAE
description  = "Jump near if above or equal (CF=0)."

[JB rel16]
opcode       = 0F 82 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if below (CF=1). Not supported in 64-bit mode."

[JB rel32]
opcode       = 0F 82 cd
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JB
description  = "Jump near if below (CF=1)."

[JBE rel16]
opcode       = 0F 86 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if below or equal (CF=1 or ZF=1). Not supported in 64-bit mode."

[JBE rel32]
opcode       = 0F 86 cd
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JBE
description  = "Jump near if below or equal (CF=1 or ZF=1)."

[JC rel16]
opcode       = 0F 82 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if carry (CF=1). Not supported in 64-bit mode."

[JC rel32]
opcode       = 0F 82 cd
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JC
description  = "Jump near if carry (CF=1)."

[JE rel16]
opcode       = 0F 84 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if equal (ZF=1). Not supported in 64-bit mode."

[JE rel32]
opcode       = 0F 84 cd
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JE
description  = "Jump near if 0 (ZF=1)."

[JG rel16]
opcode       = 0F 8F cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode."

[JG rel32]
opcode       = 0F 8F cd
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JG
description  = "Jump near if greater (ZF=0 and SF=OF)."

[JGE rel16]
opcode       = 0F 8D cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if greater or equal (SF=OF). Not supported in 64-bit mode."

[JGE rel32]
opcode       = 0F 8D cd
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JGE
description  = "Jump near if greater or equal (SF=OF)."

[JL rel16]
opcode       = 0F 8C cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if less (SF!= OF). Not supported in  64-bit mode."

[JL rel32]
opcode       = 0F 8C cd
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JL
description  = "Jump near if less (SF!= OF)."

[JLE rel16]
opcode       = 0F 8E cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if less or equal (ZF=1 or SF!= OF).  Not supported in 64-bit mode."

[JLE rel32]
opcode       = 0F 8E cd
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JLE
description  = "Jump near if less or equal (ZF=1 or SF!= OF)."

[JNA rel16]
opcode       = 0F 86 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode."

[JNA rel32]
opcode       = 0F 86 cd
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNA
description  = "Jump near if not above (CF=1 or ZF=1)."

[JNAE rel16]
opcode       = 0F 82 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not above or equal (CF=1). Not supported in 64-bit mode."

[JNAE rel32]
opcode       = 0F 82 cd
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNAE
description  = "Jump near if not above or equal (CF=1)."

[JNB rel16]
opcode       = 0F 83 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not below (CF=0). Not supported in 64-bit mode."

[JNB rel32]
opcode       = 0F 83 cd
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNB
description  = "Jump near if not below (CF=0)."

[JNBE rel16]
opcode       = 0F 87 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode."

[JNBE rel32]
opcode       = 0F 87 cd
operand      = D
props        = R
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNBE
description  = "Jump near if not below or equal (CF=0 and ZF=0)."

[JNC rel16]
opcode       = 0F 83 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not carry (CF=0). Not supported in 64-bit mode."

[JNC rel32]
opcode       = 0F 83 cd
operand      = D
props        = R
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNC
description  = "Jump near if not carry (CF=0)."

[JNE rel16]
opcode       = 0F 85 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not equal (ZF=0). Not supported in 64-bit mode."

[JNE rel32]
opcode       = 0F 85 cd
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNE
description  = "Jump near if not equal (ZF=0)."

[JNG rel16]
opcode       = 0F 8E cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not greater (ZF=1 or SF != OF). Not supported in 64-bit mode."

[JNG rel32]
opcode       = 0F 8E cd
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNG
description  = "Jump near if not greater (ZF=1 or SF != OF)."

[JNGE rel16]
opcode       = 0F 8C cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not greater or equal (SF != OF). Not supported in 64-bit mode."

[JNGE rel32]
opcode       = 0F 8C cd
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNGE
description  = "Jump near if not greater or equal (SF != OF)."

[JNL rel16]
opcode       = 0F 8D cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not less (SF=OF). Not supported in 64-bit mode."

[JNL rel32]
opcode       = 0F 8D cd
operand      = D
props        = R
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNL
description  = "Jump near if not less (SF=OF)."

[JNLE rel16]
opcode       = 0F 8F cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode."

[JNLE rel32]
opcode       = 0F 8F cd
operand      = D
props        = R
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNLE
description  = "Jump near if not less or equal (ZF=0 and SF=OF)."

[JNO rel16]
opcode       = 0F 81 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not overflow (OF=0). Not supported in 64-bit mode."

[JNO rel32]
opcode       = 0F 81 cd
operand      = D
props        = R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNO
description  = "Jump near if not overflow (OF=0)."

[JNP rel16]
opcode       = 0F 8B cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not parity (PF=0). Not supported in 64-bit mode."

[JNP rel32]
opcode       = 0F 8B cd
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNP
description  = "Jump near if not parity (PF=0)."

[JNS rel16]
opcode       = 0F 89 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not sign (SF=0). Not supported in 64-bit mode."

[JNS rel32]
opcode       = 0F 89 cd
operand      = D
props        = R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNS
description  = "Jump near if not sign (SF=0)."

[JNZ rel16]
opcode       = 0F 85 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if not zero (ZF=0). Not supported in 64-bit mode."

[JNZ rel32]
opcode       = 0F 85 cd
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JNZ
description  = "Jump near if not zero (ZF=0)."

[JO rel16]
opcode       = 0F 80 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if overflow (OF=1). Not supported in 64-bit mode."

[JO rel32]
opcode       = 0F 80 cd
operand      = D
props        = R
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JO
description  = "Jump near if overflow (OF=1)."

[JP rel16]
opcode       = 0F 8A cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if parity (PF=1). Not supported in 64-bit mode."

[JP rel32]
opcode       = 0F 8A cd
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JP
description  = "Jump near if parity (PF=1)."

[JPE rel16]
opcode       = 0F 8A cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if parity even (PF=1). Not supported in 64-bit mode."

[JPE rel32]
opcode       = 0F 8A cd
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JPE
description  = "Jump near if parity even (PF=1)."

[JPO rel16]
opcode       = 0F 8B cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if parity odd (PF=0). Not supported in 64-bit mode."

[JPO rel32]
opcode       = 0F 8B cd
operand      = D
props        = R
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JPO
description  = "Jump near if parity odd (PF=0)."

[JS rel16]
opcode       = 0F 88 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if sign (SF=1). Not supported in 64-bit mode."

[JS rel32]
opcode       = 0F 88 cd
operand      = D
props        = R
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JS
description  = "Jump near if sign (SF=1)."

[JZ rel16]
opcode       = 0F 84 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near if 0 (ZF=1). Not supported in 64-bit mode."

[JZ rel32]
opcode       = 0F 84 cd
operand      = D
props        = R
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JZ
description  = "Jump near if 0 (ZF=1)."

[JMP rel8]
opcode       = EB cb
operand      = D
props        = R
iwrite       = RIP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JMPQ
description  = "Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits"

[JMP rel16]
opcode       = E9 cw
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode."

[JMP rel32]
opcode       = E9 cd
operand      = D
props        = R
iwrite       = RIP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JMPQ
description  = "Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits"

[JMP r/m16]
opcode       = FF /4
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near, absolute indirect, address = zero-extended r/m16. Not supported in 64-bit mode."

[JMP r/m32]
opcode       = FF /4
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
preferred    = 0
description  = "Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode."

[JMP r/m64]
opcode       = FF /4
operand      = M
props        = R
iwrite       = RIP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = JMPQ
description  = "Jump near, absolute indirect, RIP = 64-Bit offset from register or memory"

[JMP ptr16:16]
opcode       = EA cd
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Jump far, absolute, address given in operand"

[JMP ptr16:32]
opcode       = EA cp
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Jump far, absolute, address given in operand"

[JMP m16:16]
opcode       = FF /5
operand      = D
props        = R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JMPQ
description  = "Jump far, absolute indirect, address given in m16:16"

[JMP m16:32]
opcode       = FF /5
operand      = D
props        = R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = JMPQ
description  = "Jump far, absolute indirect, address given in m16:32."

[JMP m16:64]
opcode       = REX.W+ FF /5
operand      = D
props        = R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = JMPQ
description  = "Jump far, absolute indirect, address given in m16:64."

[LAHF]
opcode       = 9F
operand      = NP
iread        = E.SF E.ZF E.PF E.AF E.CF
iwrite       = AH
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = LAHF_LM
preferred    = 0
att_mnemonic = LAHF
description  = "Load: AH = EFLAGS(SF:ZF:0:AF:0:PF:1:CF)."

[LAR r16, r16/m16]
opcode       = 0F 02 /r
operand      = RM
props        = W, R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LARW
description  = "r16 = access rights referenced by r16/m16"

[LAR r32, r32/m16]
opcode       = 0F 02 /r
operand      = RM
props        = W, R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LAR
description  = "reg = access rights referenced by r32/m16"

[LAR r64, r32/m16]
opcode       = REX.W+ 0F 02 /r
operand      = RM
props        = W, R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LAR
description  = "reg = access rights referenced by r32/m16"

[LDDQU xmm1, m128]
opcode       = F2 0F F0 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = LDDQU
description  = "Load unaligned data from mem and return double quadword in xmm1."

[VLDDQU xmm1, m128]
opcode       = VEX.128.F2.0F.WIG F0 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VLDDQU
description  = "Load unaligned packed integer values from mem to xmm1."

[VLDDQU ymm1, m256]
opcode       = VEX.256.F2.0F.WIG F0 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VLDDQU
description  = "Load unaligned packed integer values from mem to ymm1."

[LDMXCSR m32]
opcode       = 0F AE /2
operand      = M
props        = R
iwrite       = M.*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = LDMXCSR
description  = "Load MXCSR register from m32."

[VLDMXCSR m32]
opcode       = VEX.LZ.0F.WIG AE /2
operand      = M
props        = R
iwrite       = M.*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VLDMXCSR
description  = "Load MXCSR register from m32."

[LDS r16, m16:16]
opcode       = C5 /r
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Load DS:r16 with far pointer from memory."

[LDS r32, m16:32]
opcode       = C5 /r
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Load DS:r32 with far pointer from memory."

[LSS r16, m16:16]
opcode       = 0F B2 /r
operand      = RM
props        = W, R
iwrite       = SS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LSSW
description  = "Load SS:r16 with far pointer from memory."

[LSS r32, m16:32]
opcode       = 0F B2 /r
operand      = RM
props        = W, R
iwrite       = SS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LSSL
description  = "Load SS:r32 with far pointer from memory."

[LSS r64, m16:64]
opcode       = REX.W+ 0F B2 /r
operand      = RM
props        = W, R
iwrite       = SS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = LSS
description  = "Load SS:r64 with far pointer from memory."

[LES r16, m16:16]
opcode       = C4 /r
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Load ES:r16 with far pointer from memory."

[LES r32, m16:32]
opcode       = C4 /r
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Load ES:r32 with far pointer from memory."

[LFS r16, m16:16]
opcode       = 0F B4 /r
operand      = RM
props        = W, R
iwrite       = FS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LFSW
description  = "Load FS:r16 with far pointer from memory."

[LFS r32, m16:32]
opcode       = 0F B4 /r
operand      = RM
props        = W, R
iwrite       = FS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LFSL
description  = "Load FS:r32 with far pointer from memory."

[LFS r64, m16:64]
opcode       = REX.W+ 0F B4 /r
operand      = RM
props        = W, R
iwrite       = FS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = LFS
description  = "Load FS:r64 with far pointer from memory."

[LGS r16, m16:16]
opcode       = 0F B5 /r
operand      = RM
props        = W, R
iwrite       = GS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LGSW
description  = "Load GS:r16 with far pointer from memory."

[LGS r32, m16:32]
opcode       = 0F B5 /r
operand      = RM
props        = W, R
iwrite       = GS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LGSL
description  = "Load GS:r32 with far pointer from memory."

[LGS r64, m16:64]
opcode       = REX.W+ 0F B5 /r
operand      = RM
props        = W, R
iwrite       = GS
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = LGS
description  = "Load GS:r64 with far pointer from memory."

[LEA r16, m]
opcode       = 8D /r
operand      = RM
props        = W, I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LEAW
description  = "Store effective address for m in register r16."

[LEA r32, m]
opcode       = 8D /r
operand      = RM
props        = W, I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LEAL
description  = "Store effective address for m in register r32."

[LEA r64, m]
opcode       = REX.W+ 8D /r
operand      = RM
props        = W, I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = LEAQ
description  = "Store effective address for m in register r64."

[LEAVE p66]
opcode       = PREF.66+ C9
operand      = NP
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LEAVEW
description  = "Set SP to BP, then pop BP."

[LEAVE]
opcode       = C9
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Set ESP to EBP, then pop EBP."

[LEAVE]
opcode       = C9
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = LEAVEQ
description  = "Set RSP to RBP, then pop RBP."

[LFENCE]
opcode       = 0F AE E8
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LFENCE
description  = "Serializes load operations."

[LGDT m16&32]
opcode       = 0F 01 /2
useful       = 0
protected    = 1
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Load m into GDTR."

[LIDT m16&32]
opcode       = 0F 01 /3
useful       = 0
protected    = 1
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Load m into IDTR."

[LGDT m16&64]
opcode       = 0F 01 /2
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Load m into GDTR."

[LIDT m16&64]
opcode       = 0F 01 /3
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Load m into IDTR."

[LLDT r/m16]
opcode       = 0F 00 /2
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Load segment selector r/m16 into LDTR."

[LMSW r/m16]
opcode       = 0F 01 /6
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Loads r/m16 in machine status word of CR0."

[LOCK]
opcode       = F0
operand      = NP
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LOCK
description  = "Asserts LOCK# signal for duration of the accompanying instruction."

[LODS m8]
opcode       = AC
operand      = NP
props        = I
iread        = E.DF SI rsi
iwrite       = AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LODS
description  = "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."

[LODS m16]
opcode       = AD
operand      = NP
props        = I
iread        = E.DF SI rsi
iwrite       = AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LODS
description  = "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."

[LODS m32]
opcode       = AD
operand      = NP
props        = I
iread        = E.DF SI rsi
iwrite       = EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LODS
description  = "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."

[LODS m64]
opcode       = REX.W+ AD
operand      = NP
props        = I
iread        = E.DF SI rsi
iwrite       = RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = LODS
description  = "Load qword at address (R)SI into RAX."

[LODSB]
opcode       = AC
operand      = NP
iread        = E.DF SI rsi
iwrite       = AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LODSB
description  = "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."

[LODSW]
opcode       = PREF.66+ AD
operand      = NP
iread        = E.DF SI rsi
iwrite       = AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LODSW
description  = "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."

[LODSD]
opcode       = AD
operand      = NP
iread        = E.DF SI rsi
iwrite       = EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LODSL
description  = "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."

[LODSQ]
opcode       = REX.W+ AD
operand      = NP
iread        = E.DF SI rsi
iwrite       = RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = LODSQ
description  = "Load qword at address (R)SI into RAX."

[LOOP rel8]
opcode       = E2 cb
operand      = D
props        = R
iread        = RCX E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LOOP
description  = "Decrement count; jump short if count != 0."

[LOOPE rel8]
opcode       = E0 cb
operand      = D
props        = R
iread        = RCX E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LOOPE
description  = "Decrement count; jump short if count != 0 and  ZF = 1."

[LOOPNE rel8]
opcode       = E0 cb
operand      = D
props        = R
iread        = RCX E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LOOPNE
description  = "Decrement count; jump short if count != 0 and  ZF = 0."

[LSL r16, r16/m16]
opcode       = 0F 03 /r
operand      = RM
props        = W, R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LSLW
description  = "Load: r16 = segment limit, selector r16/m16."

[LSL r32, r32/m16]
opcode       = 0F 03 /r
operand      = RM
props        = W, R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LSL
description  = "Load: r32 = segment limit, selector r32/m16."

[LSL r64, r32/m16]
opcode       = REX.W+ 0F 03 /r
operand      = RM
props        = W, R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LSL
description  = "Load: r64 = segment limit, selector r32/m16"

[LTR r/m16]
opcode       = 0F 00 /3
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Load r/m16 into task register."

[LZCNT r16, r/m16]
opcode       = F3 0F BD /r
operand      = RM
props        = W, R
iwrite       = E.ZF E.CF
iundef       = E.AF E.PF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = LZCNTW
description  = "Count the number of leading zero bits in r/m16, return result in r16"

[LZCNT r32, r/m32]
opcode       = F3 0F BD /r
operand      = RM
props        = W, R
iwrite       = E.ZF E.CF
iundef       = E.AF E.PF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = LZCNTL
description  = "Count the number of leading zero bits in r/m32, return result in r32"

[LZCNT r64, r/m64]
opcode       = REX.W+ F3 0F BD /r
operand      = RM
props        = W, R
iwrite       = E.ZF E.CF
iundef       = E.AF E.PF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = LZCNTQ
description  = "Count the number of leading zero bits in r/m64, return result in r64"

[MASKMOVDQU xmm1, xmm2]
opcode       = 66 0F F7 /r
operand      = RM
props        = R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MASKMOVDQU
description  = "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."

[VMASKMOVDQU xmm1, xmm2]
opcode       = VEX.128.66.0F.WIG F7 /r
operand      = RM
props        = R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVDQU
description  = "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."

[MASKMOVQ mm1, mm2]
opcode       = 0F F7 /r
operand      = RM
props        = R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MASKMOVQ
description  = "Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI."

[MAXPD xmm1, xmm2/m128]
opcode       = 66 0F 5F /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MAXPD
description  = "Return the maximum double-precision floating-point values between xmm2/m128 and xmm1."

[VMAXPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 5F /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMAXPD
description  = "Return the maximum double-precision floating-point values between xmm2 and xmm3/mem."

[VMAXPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 5F /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMAXPD
description  = "Return the maximum packed double-precision floating-point values between ymm2 and ymm3/mem."

[MAXPS xmm1, xmm2/m128]
opcode       = 0F 5F /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MAXPS
description  = "Return the maximum single-precision floating-point values between xmm2/m128 and xmm1."

[VMAXPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 5F /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMAXPS
description  = "Return the maximum single-precision floating-point values between xmm2 and xmm3/mem."

[VMAXPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 5F /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMAXPS
description  = "Return the maximum single double-precision floating-point values between ymm2 and ymm3/mem."

[MAXSD xmm1, xmm2/m64]
opcode       = F2 0F 5F /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MAXSD
description  = "Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1."

[VMAXSD xmm1, xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 5F /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMAXSD
description  = "Return the maximum scalar double-precision floating-point value between xmm3/mem64 and xmm2."

[MAXSS xmm1, xmm2/m32]
opcode       = F3 0F 5F /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MAXSS
description  = "Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1."

[VMAXSS xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 5F /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMAXSS
description  = "Return the maximum scalar single-precision floating-point value between xmm3/mem32 and xmm2."

[MFENCE]
opcode       = 0F AE F0
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MFENCE
description  = "Serializes load and store operations."

[MINPD xmm1, xmm2/m128]
opcode       = 66 0F 5D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MINPD
description  = "Return the minimum double-precision floating-point values between xmm2/m128 and xmm1."

[VMINPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 5D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMINPD
description  = "Return the minimum double-precision floating-point values between xmm2 and xmm3/mem."

[VMINPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 5D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMINPD
description  = "Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem."

[MINPS xmm1, xmm2/m128]
opcode       = 0F 5D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MINPS
description  = "Return the minimum single-precision floating-point values between xmm2/m128 and xmm1."

[VMINPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 5D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMINPS
description  = "Return the minimum single-precision floating-point values between xmm2 and xmm3/mem."

[VMINPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 5D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMINPS
description  = "Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem."

[MINSD xmm1, xmm2/m64]
opcode       = F2 0F 5D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MINSD
description  = "Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1."

[VMINSD xmm1, xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 5D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMINSD
description  = "Return the minimum scalar double precision floating-point value between xmm3/mem64 and xmm2."

[MINSS xmm1, xmm2/m32]
opcode       = F3 0F 5D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MINSS
description  = "Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1."

[VMINSS xmm1,xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 5D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMINSS
description  = "Return the minimum scalar single precision floating-point value between xmm3/mem32 and xmm2."

[MONITOR]
opcode       = 0F 01 C8
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MONITOR
preferred    = 0
att_mnemonic = MONITOR
description  = "Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The address is DS:EAX (DS:RAX in 64-bit mode)."

[MOV r/m8, r8]
opcode       = 88 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = MOVB
description  = "Move r8 to r/m8."

[MOV r/m8, r8]
opcode       = REX+ 88 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = MOVB
description  = "Move r8 to r/m8."

[MOV r/m16, r16]
opcode       = 89 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = MOVW
description  = "Move r16 to r/m16."

[MOV r/m32, r32]
opcode       = 89 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = MOVL
description  = "Move r32 to r/m32."

[MOV r/m64, r64]
opcode       = REX.W+ 89 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = MOVQ
description  = "Move r64 to r/m64."

[MOV r8, r/m8]
opcode       = 8A /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVB
description  = "Move r/m8 to r8."

[MOV r8, r/m8]
opcode       = REX+ 8A /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVB
description  = "Move r/m8 to r8."

[MOV r16, r/m16]
opcode       = 8B /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVW
description  = "Move r/m16 to r16."

[MOV r32, r/m32]
opcode       = 8B /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVL
description  = "Move r/m32 to r32."

[MOV r64, r/m64]
opcode       = REX.W+ 8B /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVQ
description  = "Move r/m64 to r64."

[MOV r/m16, Sreg]
opcode       = 8C /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVW
description  = "Move segment register to r/m16."

[MOV r/m64, Sreg]
opcode       = REX.W+ 8C /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVQ
description  = "Move zero extended 16-bit segment register to r/m64."

[MOV Sreg, r/m16]
opcode       = 8E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOV
description  = "Move r/m16 to segment register."

[MOV Sreg, r/m64]
opcode       = REX.W+ 8E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOV
description  = "Move lower 16 bits of r/m64 to segment register."

[MOV AL, moffs8]
opcode       = A0
operand      = FD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVABSB
description  = "Move byte at (seg:offset) to AL."

[MOV AL, moffs8, pw]
opcode       = REX.W+ A0
operand      = FD
props        = W, R, I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVABSB
description  = "Move byte at (offset) to AL."

[MOV AX, moffs16]
opcode       = A1
operand      = FD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVABSW
description  = "Move word at (seg:offset) to AX."

[MOV EAX, moffs32]
opcode       = A1
operand      = FD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVABSL
description  = "Move doubleword at (seg:offset) to EAX."

[MOV RAX, moffs64]
opcode       = REX.W+ A1
operand      = FD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVABSQ
description  = "Move quadword at (offset) to RAX."

[MOV moffs8, AL]
opcode       = A2
operand      = TD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVABSB
description  = "Move AL to (seg:offset)."

[MOV moffs8, AL, pw]
opcode       = REX.W+ A2
operand      = TD
props        = W, R, I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVABSB
description  = "Move AL to (offset)."

[MOV moffs16, AX]
opcode       = A3
operand      = TD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVABSW
description  = "Move AX to (seg:offset)."

[MOV moffs32, EAX]
opcode       = A3
operand      = TD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVABSL
description  = "Move EAX to (seg:offset)."

[MOV moffs64, RAX]
opcode       = REX.W+ A3
operand      = TD
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVABSQ
description  = "Move RAX to (offset)."

[MOV r8, imm8]
opcode       = B0 +rb
operand      = OI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = MOVB
description  = "Move imm8 to r8."

[MOV r8, imm8]
opcode       = REX+ B0 +rb
operand      = OI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = MOVB
description  = "Move imm8 to r8."

[MOV r16, imm16]
opcode       = B8 +rw
operand      = OI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = MOVW
description  = "Move imm16 to r16."

[MOV r32, imm32]
opcode       = B8 +rd
operand      = OI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = MOVL
description  = "Move imm32 to r32."

[MOV r64, imm64]
opcode       = REX.W+ B8 +rd
operand      = OI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVQ
description  = "Move imm64 to r64."

[MOV r/m8, imm8]
opcode       = C6 /0
operand      = MI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVB
description  = "Move imm8 to r/m8."

[MOV r/m8, imm8]
opcode       = REX+ C6 /0
operand      = MI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVB
description  = "Move imm8 to r/m8."

[MOV r/m16, imm16]
opcode       = C7 /0
operand      = MI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVW
description  = "Move imm16 to r/m16."

[MOV r/m32, imm32]
opcode       = C7 /0
operand      = MI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVL
description  = "Move imm32 to r/m32."

[MOV r/m64, imm32]
opcode       = REX.W+ C7 /0
operand      = MI
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = MOVQ
description  = "Move imm32 sign extended to 64-bits to r/m64."

[MOV r32, CR0-CR7]
opcode       = 0F 20 /r
useful       = 0
protected    = 1
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Move control register to r32."

[MOV r64, CR0-CR7]
opcode       = 0F 20 /r
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Move extended control register to r64."

[MOV r64, CR8]
opcode       = REX.R+ 0F 20
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Move extended CR8 to r64.1"

[MOV CR0-CR7, r32]
opcode       = 0F 22 /r
useful       = 0
protected    = 1
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Move r32 to control register."

[MOV CR0-CR7, r64]
opcode       = 0F 22 /r
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Move r64 to extended control register."

[MOV CR8, r64]
opcode       = REX.R+ 0F 22
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Move r64 to extended CR8.1"

[MOV r32, DR0-DR7]
opcode       = 0F 21 /r
useful       = 0
protected    = 1
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Move debug register to r32."

[MOV r64, DR0-DR7]
opcode       = 0F 21 /r
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Move extended debug register to r64."

[MOV DR0-DR7, r32]
opcode       = 0F 23 /r
useful       = 0
protected    = 1
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Move r32 to debug register."

[MOV DR0-DR7, r64]
opcode       = 0F 23 /r
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = NE
preferred    = 0
description  = "Move r64 to extended debug register."

[MOVAPD xmm1, xmm2/m128]
opcode       = 66 0F 28 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVAPD
description  = "Move packed double-precision floating-point values from xmm2/m128 to xmm1."

[MOVAPD xmm2/m128, xmm1]
opcode       = 66 0F 29 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVAPD
description  = "Move packed double-precision floating-point values from xmm1 to xmm2/m128."

[VMOVAPD xmm1, xmm2/m128]
opcode       = VEX.128.66.0F.WIG 28 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVAPD
description  = "Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."

[VMOVAPD xmm2/m128, xmm1]
opcode       = VEX.128.66.0F.WIG 29 /r
operand      = MR
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVAPD
description  = "Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."

[VMOVAPD ymm1, ymm2/m256]
opcode       = VEX.256.66.0F.WIG 28 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVAPD
description  = "Move aligned packed double-precision floating-point values from ymm2/mem to ymm1."

[VMOVAPD ymm2/m256, ymm1]
opcode       = VEX.256.66.0F.WIG 29 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVAPD
description  = "Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem."

[MOVAPS xmm1, xmm2/m128]
opcode       = 0F 28 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVAPS
description  = "Move packed single-precision floating-point values from xmm2/m128 to xmm1."

[MOVAPS xmm2/m128, xmm1]
opcode       = 0F 29 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 1
att_mnemonic = MOVAPS
description  = "Move packed single-precision floating-point values from xmm1 to xmm2/m128."

[VMOVAPS xmm1, xmm2/m128]
opcode       = VEX.128.0F.WIG 28 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVAPS
description  = "Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."

[VMOVAPS xmm2/m128, xmm1]
opcode       = VEX.128.0F.WIG 29 /r
operand      = MR
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVAPS
description  = "Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."

[VMOVAPS ymm1, ymm2/m256]
opcode       = VEX.256.0F.WIG 28 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVAPS
description  = "Move aligned packed single-precision floating-point values from ymm2/mem to ymm1."

[VMOVAPS ymm2/m256, ymm1]
opcode       = VEX.256.0F.WIG 29 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVAPS
description  = "Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem."

[MOVBE r16, m16]
opcode       = 0F 38 F0 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MOVBE
preferred    = 0
att_mnemonic = MOVBEW
description  = "Reverse byte order in m16 and move to r16"

[MOVBE r32, m32]
opcode       = 0F 38 F0 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MOVBE
preferred    = 0
att_mnemonic = MOVBEL
description  = "Reverse byte order in m32 and move to r32"

[MOVBE r64, m64]
opcode       = REX.W+ 0F 38 F0 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = MOVBE
preferred    = 0
att_mnemonic = MOVBEQ
description  = "Reverse byte order in m64 and move to r64."

[MOVBE m16, r16]
opcode       = 0F 38 F1 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MOVBE
preferred    = 0
att_mnemonic = MOVBEW
description  = "Reverse byte order in r16 and move to m16"

[MOVBE m32, r32]
opcode       = 0F 38 F1 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MOVBE
preferred    = 0
att_mnemonic = MOVBEL
description  = "Reverse byte order in r32 and move to m32"

[MOVBE m64, r64]
opcode       = REX.W+ 0F 38 F1 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = MOVBE
preferred    = 0
att_mnemonic = MOVBEQ
description  = "Reverse byte order in r64 and move to m64."

[MOVD mm, r/m32]
opcode       = 0F 6E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = MOVD
description  = "Move doubleword from r/m32 to mm."

[MOVQ mm, r/m64]
opcode       = REX.W+ 0F 6E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = MMX
preferred    = 1
att_mnemonic = MOVQ
description  = "Move quadword from r/m64 to mm."

[MOVD r/m32, mm]
opcode       = 0F 7E /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = MOVD
description  = "Move doubleword from mm to r/m32."

[MOVQ r/m64, mm]
opcode       = REX.W+ 0F 7E /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = MMX
preferred    = 1
att_mnemonic = MOVQ
description  = "Move quadword from mm to r/m64."

[VMOVD xmm1, r32/m32]
opcode       = VEX.128.66.0F.W0 6E /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVD
description  = "Move doubleword from r/m32 to xmm1."

[VMOVQ xmm1, r64/m64]
opcode       = VEX.128.66.0F.W1 6E /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVQ
description  = "Move quadword from r/m64 to xmm1."

[MOVD xmm, r/m32]
opcode       = 66 0F 6E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVD
description  = "Move doubleword from r/m32 to xmm."

[MOVQ xmm, r/m64]
opcode       = 66 REX.W+ 0F 6E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVQ
description  = "Move quadword from r/m64 to xmm."

[MOVD r/m32, xmm]
opcode       = 66 0F 7E /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVD
description  = "Move doubleword from xmm register to r/m32."

[MOVQ r/m64, xmm]
opcode       = 66 REX.W+ 0F 7E /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVQ
description  = "Move quadword from xmm register to r/m64."

[VMOVD r32/m32, xmm1]
opcode       = VEX.128.66.0F.W0 7E /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVD
description  = "Move doubleword from xmm1 register to r/m32."

[VMOVQ r64/m64, xmm1]
opcode       = VEX.128.66.0F.W1 7E /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVQ
description  = "Move quadword from xmm1 register to r/m64."

[MOVDDUP xmm1, xmm2/m64]
opcode       = F2 0F 12 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = MOVDDUP
description  = "Move one double-precision floating-point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate."

[VMOVDDUP xmm1, xmm2/m64]
opcode       = VEX.128.F2.0F.WIG 12 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVDDUP
description  = "Move double-precision floating-point values from xmm2/mem and duplicate into xmm1."

[VMOVDDUP ymm1, ymm2/m256]
opcode       = VEX.256.F2.0F.WIG 12 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVDDUP
description  = "Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1."

[MOVDQA xmm1, xmm2/m128]
opcode       = 66 0F 6F /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVDQA
description  = "Move aligned double quadword from xmm2/m128 to xmm1."

[MOVDQA xmm2/m128, xmm1]
opcode       = 66 0F 7F /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVDQA
description  = "Move aligned double quadword from xmm1 to xmm2/m128."

[VMOVDQA xmm1, xmm2/m128]
opcode       = VEX.128.66.0F.WIG 6F /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVDQA
description  = "Move aligned packed integer values from xmm2/mem to xmm1."

[VMOVDQA xmm2/m128, xmm1]
opcode       = VEX.128.66.0F.WIG 7F /r
operand      = MR
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVDQA
description  = "Move aligned packed integer values from xmm1 to xmm2/mem."

[VMOVDQA ymm1, ymm2/m256]
opcode       = VEX.256.66.0F.WIG 6F /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVDQA
description  = "Move aligned packed integer values from ymm2/mem to ymm1."

[VMOVDQA ymm2/m256, ymm1]
opcode       = VEX.256.66.0F.WIG 7F /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVDQA
description  = "Move aligned packed integer values from ymm1 to ymm2/mem."

[MOVDQU xmm1, xmm2/m128]
opcode       = F3 0F 6F /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVDQU
description  = "Move unaligned double quadword from xmm2/m128 to xmm1."

[MOVDQU xmm2/m128, xmm1]
opcode       = F3 0F 7F /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVDQU
description  = "Move unaligned double quadword from xmm1 to xmm2/m128."

[VMOVDQU xmm1, xmm2/m128]
opcode       = VEX.128.F3.0F.WIG 6F /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVDQU
description  = "Move unaligned packed integer values from xmm2/mem to xmm1."

[VMOVDQU xmm2/m128, xmm1]
opcode       = VEX.128.F3.0F.WIG 7F /r
operand      = MR
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVDQU
description  = "Move unaligned packed integer values from xmm1 to xmm2/mem."

[VMOVDQU ymm1, ymm2/m256]
opcode       = VEX.256.F3.0F.WIG 6F /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVDQU
description  = "Move unaligned packed integer values from ymm2/mem to ymm1."

[VMOVDQU ymm2/m256, ymm1]
opcode       = VEX.256.F3.0F.WIG 7F /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVDQU
description  = "Move unaligned packed integer values from ymm1 to ymm2/mem."

[MOVDQ2Q mm, xmm]
opcode       = F2 0F D6
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = MOVDQ2Q
description  = "Move low quadword from xmm to mmx register."

[MOVHLPS xmm1, xmm2]
opcode       = 0F 12 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVHLPS
description  = "Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1."

[VMOVHLPS xmm1, xmm2, xmm3]
opcode       = VEX.NDS.128.0F.WIG 12 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVHLPS
description  = "Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2."

[MOVHPD xmm, m64]
opcode       = 66 0F 16 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVHPD
description  = "Move double-precision floating-point value from m64 to high quadword of xmm."

[MOVHPD m64, xmm]
opcode       = 66 0F 17 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVHPD
description  = "Move double-precision floating-point value from high quadword of xmm to m64."

[VMOVHPD xmm2, xmm1, m64]
opcode       = VEX.NDS.128.66.0F.WIG 16 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVHPD
description  = "Merge double-precision floating-point value from m64 and the low quadword of xmm1."

[VMOVHPD m64, xmm1]
opcode       = VEX128.66.0F.WIG 17 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVHPD
description  = "Move double-precision floating-point values from high quadword of xmm1 to m64."

[MOVHPS xmm, m64]
opcode       = 0F 16 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVHPS
description  = "Move two packed single-precision floating-point values from m64 to high quadword of xmm."

[MOVHPS m64, xmm]
opcode       = 0F 17 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVHPS
description  = "Move two packed single-precision floating-point values from high quadword of xmm to m64."

[VMOVHPS xmm2, xmm1, m64]
opcode       = VEX.NDS.128.0F.WIG 16 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVHPS
description  = "Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."

[VMOVHPS m64, xmm1]
opcode       = VEX.128.0F.WIG 17 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVHPS
description  = "Move two packed single-precision floating-point values from high quadword of xmm1to m64."

[MOVLHPS xmm1, xmm2]
opcode       = 0F 16 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVLHPS
description  = "Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1."

[VMOVLHPS xmm1, xmm2, xmm3]
opcode       = VEX.NDS.128.0F.WIG 16 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVLHPS
description  = "Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2."

[MOVLPD xmm, m64]
opcode       = 66 0F 12 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVLPD
description  = "Move double-precision floating-point value from m64 to low quadword of xmm register."

[MOVLPD m64, xmm]
opcode       = 66 0F 13 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVLPD
description  = "Move double-precision floating-point nvalue from low quadword of xmm register to m64."

[VMOVLPD xmm2, xmm1, m64]
opcode       = VEX.NDS.128.66.0F.WIG 12 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVLPD
description  = "Merge double-precision floating-point value from m64 and the high quadword of xmm1."

[VMOVLPD m64, xmm1]
opcode       = VEX.128.66.0F.WIG 13 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVLPD
description  = "Move double-precision floating-point values from low quadword of xmm1 to m64."

[MOVLPS xmm, m64]
opcode       = 0F 12 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVLPS
description  = "Move two packed single-precision floating-point values from m64 to low quadword of xmm."

[MOVLPS m64, xmm]
opcode       = 0F 13 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVLPS
description  = "Move two packed single-precision floating-point values from low quadword of xmm to m64."

[VMOVLPS xmm2, xmm1, m64]
opcode       = VEX.NDS.128.0F.WIG 12 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVLPS
description  = "Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."

[VMOVLPS m64, xmm1]
opcode       = VEX.128.0F.WIG 13 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVLPS
description  = "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."

[MOVMSKPD reg, xmm]
opcode       = 66 0F 50 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVMSKPD
description  = "Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros."

[VMOVMSKPD reg, xmm2]
opcode       = VEX.128.66.0F.WIG 50 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVMSKPD
description  = "Extract 2-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed."

[VMOVMSKPD reg, ymm2]
opcode       = VEX.256.66.0F.WIG 50 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVMSKPD
description  = "Extract 4-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed."

[MOVMSKPS reg, xmm]
opcode       = 0F 50 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVMSKPS
description  = "Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros."

[VMOVMSKPS reg, xmm2]
opcode       = VEX.128.0F.WIG 50 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVMSKPS
description  = "Extract 4-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed."

[VMOVMSKPS reg, ymm2]
opcode       = VEX.256.0F.WIG 50 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVMSKPS
description  = "Extract 8-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed."

[MOVNTDQA xmm1, m128]
opcode       = 66 0F 38 2A /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = MOVNTDQA
description  = "Move double quadword from m128 to xmm using non-temporal hint if WC memory type."

[VMOVNTDQA xmm1, m128]
opcode       = VEX.128.66.0F38.WIG 2A /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVNTDQA
description  = "Move double quadword from m128 to xmm using non-temporal hint if WC memory type."

[VMOVNTDQA ymm1, m256]
opcode       = VEX.256.66.0F38.WIG 2A /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VMOVNTDQA
description  = "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."

[MOVNTDQ m128, xmm]
opcode       = 66 0F E7 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVNTDQ
description  = "Move double quadword from xmm to m128 using non-temporal hint."

[VMOVNTDQ m128, xmm1]
opcode       = VEX.128.66.0F.WIG E7 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVNTDQ
description  = "Move packed integer values in xmm1 to m128 using non-temporal hint."

[VMOVNTDQ m256, ymm1]
opcode       = VEX.256.66.0F.WIG E7 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVNTDQ
description  = "Move packed integer values in ymm1 to m256 using non-temporal hint."

[MOVNTI m32, r32]
opcode       = 0F C3 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVNTI
description  = "Move doubleword from r32 to m32 using non-temporal hint."

[MOVNTI m64, r64]
opcode       = REX.W+ 0F C3 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVNTI
description  = "Move quadword from r64 to m64 using non-temporal hint."

[MOVNTPD m128, xmm]
opcode       = 66 0F 2B /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVNTPD
description  = "Move packed double-precision floating-point values from xmm to m128 using non-temporal hint."

[VMOVNTPD m128, xmm1]
opcode       = VEX.128.66.0F.WIG 2B /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVNTPD
description  = "Move packed double-precision values in xmm1 to m128 using non-temporal hint."

[VMOVNTPD m256, ymm1]
opcode       = VEX.256.66.0F.WIG 2B /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVNTPD
description  = "Move packed double-precision values in ymm1 to m256 using non-temporal hint."

[MOVNTPS m128, xmm]
opcode       = 0F 2B /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVNTPS
description  = "Move packed single-precision floating-point values from xmm to m128 using non-temporal hint."

[VMOVNTPS m128, xmm1]
opcode       = VEX.128.0F.WIG 2B /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVNTPS
description  = "Move packed single-precision values xmm1 to mem using non-temporal hint."

[VMOVNTPS m256, ymm1]
opcode       = VEX.256.0F.WIG 2B /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVNTPS
description  = "Move packed single-precision values ymm1 to mem using non-temporal hint."

[MOVNTQ m64, mm]
opcode       = 0F E7 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVNTQ
description  = "Move quadword from mm to m64 using non-temporal hint."

[MOVQ mm, mm/m64]
opcode       = 0F 6F /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 1
att_mnemonic = MOVQ
description  = "Move quadword from mm/m64 to mm."

[MOVQ mm/m64, mm]
opcode       = 0F 7F /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = MOVQ
description  = "Move quadword from mm to mm/m64."

[MOVQ xmm1, xmm2/m64]
opcode       = F3 0F 7E
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVQ
description  = "Move quadword from xmm2/mem64 to xmm1."

[VMOVQ xmm1, xmm2]
opcode       = VEX.128.F3.0F.WIG 7E /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVQ
description  = "Move quadword from xmm2 to xmm1."

[VMOVQ xmm1, m64]
opcode       = VEX.128.F3.0F.WIG 7E /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVQ
description  = "Load quadword from m64 to xmm1."

[MOVQ xmm2/m64, xmm1]
opcode       = 66 0F D6
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVQ
description  = "Move quadword from xmm1 to xmm2/mem64."

[VMOVQ xmm1/m64, xmm2]
opcode       = VEX.128.66.0F.WIG D6 /r
operand      = MR
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVQ
description  = "Move quadword from xmm2 register to xmm1/m64."

[MOVQ2DQ xmm, mm]
opcode       = F3 0F D6
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = MOVQ2DQ
description  = "Move quadword from mmx to low quadword of xmm."

[MOVS m8, m8]
opcode       = A4
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVS
description  = "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."

[MOVS m16, m16]
opcode       = A5
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVS
description  = "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."

[MOVS m32, m32]
opcode       = A5
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVS
description  = "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."

[MOVS m64, m64]
opcode       = REX.W+ A5
operand      = NP
props        = I, I
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVS
description  = "Move qword from address (R|E)SI to (R|E)DI."

[MOVSB]
opcode       = A4
operand      = NP
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSB
description  = "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."

[MOVSW]
opcode       = PREF.66+ A5
operand      = NP
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSW
description  = "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."

[MOVSD]
opcode       = A5
operand      = NP
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSL
description  = "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."

[MOVSQ]
opcode       = REX.W+ A5
operand      = NP
iread        = E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVSQ
description  = "Move qword from address (R|E)SI to (R|E)DI."

[MOVSD xmm1, xmm2/m64]
opcode       = F2 0F 10 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVSD
description  = "Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register."

[VMOVSD xmm1, xmm2, xmm3]
opcode       = VEX.NDS.LIG.F2.0F.WIG 10 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSD
description  = "Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register."

[VMOVSD xmm1, m64]
opcode       = VEX.LIG.F2.0F.WIG 10 /r
operand      = XM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSD
description  = "Load scalar double-precision floating-point value from m64 to xmm1 register."

[MOVSD xmm2/m64, xmm1]
opcode       = F2 0F 11 /r
operand      = MR
props        = QW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVSD
description  = "Move scalar double-precision floating-point value from xmm1 register to xmm2/m64."

[VMOVSD xmm1, xmm2, xmm3]
opcode       = VEX.NDS.LIG.F2.0F.WIG 11 /r
operand      = MVR
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVSD
description  = "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1."

[VMOVSD m64, xmm1]
opcode       = VEX.LIG.F2.0F.WIG 11 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSD
description  = "Move scalar double-precision floating-point value from xmm1 register to m64."

[MOVSHDUP xmm1, xmm2/m128]
opcode       = F3 0F 16 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = MOVSHDUP
description  = "Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword."

[VMOVSHDUP xmm1, xmm2/m128]
opcode       = VEX.128.F3.0F.WIG 16 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSHDUP
description  = "Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."

[VMOVSHDUP ymm1, ymm2/m256]
opcode       = VEX.256.F3.0F.WIG 16 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSHDUP
description  = "Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."

[MOVSLDUP xmm1, xmm2/m128]
opcode       = F3 0F 12 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PNI
preferred    = 0
att_mnemonic = MOVSLDUP
description  = "Move two single-precision floating-point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword."

[VMOVSLDUP xmm1, xmm2/m128]
opcode       = VEX.128.F3.0F.WIG 12 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSLDUP
description  = "Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."

[VMOVSLDUP ymm1, ymm2/m256]
opcode       = VEX.256.F3.0F.WIG 12 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSLDUP
description  = "Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."

[MOVSS xmm1, xmm2/m32]
opcode       = F3 0F 10 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 1
att_mnemonic = MOVSS
description  = "Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register."

[VMOVSS xmm1, xmm2, xmm3]
opcode       = VEX.NDS.LIG.F3.0F.WIG 10 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSS
description  = "Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register."

[VMOVSS xmm1, m32]
opcode       = VEX.LIG.F3.0F.WIG 10 /r
operand      = XM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSS
description  = "Load scalar single-precision floating-point value from m32 to xmm1 register."

[MOVSS xmm2/m32, xmm]
opcode       = F3 0F 11 /r
operand      = MR
props        = QW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVSS
description  = "Move scalar single-precision floating-point value from xmm1 register to xmm2/m32."

[VMOVSS xmm1, xmm2, xmm3]
opcode       = VEX.NDS.LIG.F3.0F.WIG 11 /r
operand      = MVR
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVSS
description  = "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register."

[VMOVSS m32, xmm1]
opcode       = VEX.LIG.F3.0F.WIG 11 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVSS
description  = "Move scalar single-precision floating-point value from xmm1 register to m32."

[MOVSX r16, r/m8]
opcode       = 0F BE /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSBW
description  = "Move byte to word with sign-extension."

[MOVSX r16, r/m8]
opcode       = REX+ 0F BE /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSBW
description  = "Move byte to word with sign-extension."

[MOVSX r32, r/m8]
opcode       = 0F BE /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSBL
description  = "Move byte to doubleword with sign-extension."

[MOVSX r32, r/m8]
opcode       = REX+ 0F BE /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSBL
description  = "Move byte to doubleword with sign-extension."

[MOVSX r64, r/m8]
opcode       = REX.W+ 0F BE /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVSBQ
description  = "Move byte to quadword with sign-extension."

[MOVSX r32, r/m16]
opcode       = 0F BF /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVSWL
description  = "Move word to doubleword, with sign-extension."

[MOVSX r64, r/m16]
opcode       = REX.W+ 0F BF /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVSWQ
description  = "Move word to quadword with sign-extension."

[MOVSXD r64, r/m32]
opcode       = REX.W+ 63 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVSLQ
description  = "Move doubleword to quadword with sign-extension."

[MOVUPD xmm1, xmm2/m128]
opcode       = 66 0F 10 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = MOVUPD
description  = "Move packed double-precision floating-point values from xmm2/m128 to xmm1."

[VMOVUPD xmm1, xmm2/m128]
opcode       = VEX.128.66.0F.WIG 10 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVUPD
description  = "Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."

[VMOVUPD ymm1, ymm2/m256]
opcode       = VEX.256.66.0F.WIG 10 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVUPD
description  = "Move unaligned packed double-precision floating-point from ymm2/mem to ymm1."

[MOVUPD xmm2/m128, xmm]
opcode       = 66 0F 11 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MOVUPD
description  = "Move packed double-precision floating-point values from xmm1 to xmm2/m128."

[VMOVUPD xmm2/m128, xmm1]
opcode       = VEX.128.66.0F.WIG 11 /r
operand      = MR
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVUPD
description  = "Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."

[VMOVUPD ymm2/m256, ymm1]
opcode       = VEX.256.66.0F.WIG 11 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVUPD
description  = "Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem."

[MOVUPS xmm1, xmm2/m128]
opcode       = 0F 10 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 1
att_mnemonic = MOVUPS
description  = "Move packed single-precision floating-point values from xmm2/m128 to xmm1."

[VMOVUPS xmm1, xmm2/m128]
opcode       = VEX.128.0F.WIG 10 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVUPS
description  = "Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."

[VMOVUPS ymm1, ymm2/m256]
opcode       = VEX.256.0F.WIG 10 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMOVUPS
description  = "Move unaligned packed single-precision floating-point from ymm2/mem to ymm1."

[MOVUPS xmm2/m128, xmm1]
opcode       = 0F 11 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MOVUPS
description  = "Move packed single-precision floating-point values from xmm1 to xmm2/m128."

[VMOVUPS xmm2/m128, xmm1]
opcode       = VEX.128.0F.WIG 11 /r
operand      = MR
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVUPS
description  = "Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."

[VMOVUPS ymm2/m256, ymm1]
opcode       = VEX.256.0F.WIG 11 /r
operand      = MR
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VMOVUPS
description  = "Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem."

[MOVZX r16, r/m8]
opcode       = 0F B6 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVZBW
description  = "Move byte to word with zero-extension."

[MOVZX r16, r/m8]
opcode       = REX+ 0F B6 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVZBW
description  = "Move byte to word with zero-extension."

[MOVZX r32, r/m8]
opcode       = 0F B6 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVZBL
description  = "Move byte to doubleword, zero-extension."

[MOVZX r32, r/m8]
opcode       = REX+ 0F B6 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVZBL
description  = "Move byte to doubleword, zero-extension."

[MOVZX r64, r/m8]
opcode       = REX.W+ 0F B6 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVZBQ
description  = "Move byte to quadword, zero-extension."

[MOVZX r32, r/m16]
opcode       = 0F B7 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MOVZWL
description  = "Move word to doubleword, zero-extension."

[MOVZX r64, r/m16]
opcode       = REX.W+ 0F B7 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MOVZWQ
description  = "Move word to quadword, zero-extension."

[MPSADBW xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 42 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = MPSADBW
description  = "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8."

[VMPSADBW xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 42 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMPSADBW
description  = "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8."

[VMPSADBW ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.WIG 42 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VMPSADBW
description  = "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by imm8."

[MUL r/m8]
opcode       = F6 /4
operand      = M
props        = R
iread        = AL
iwrite       = AX E.OF E.CF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MULB
description  = "Unsigned multiply (AX = AL * r/m8)."

[MUL r/m8]
opcode       = REX+ F6 /4
operand      = M
props        = R
iread        = AL
iwrite       = AX E.OF E.CF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MULB
description  = "Unsigned multiply (AX = AL * r/m8)."

[MUL r/m16]
opcode       = F7 /4
operand      = M
props        = R
iread        = AX
iwrite       = AX DX E.OF E.CF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MULW
description  = "Unsigned multiply (DX:AX = AX * r/m16)."

[MUL r/m32]
opcode       = F7 /4
operand      = M
props        = R
iread        = EAX
iwrite       = RAX RDX E.OF E.CF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = MULL
description  = "Unsigned multiply (EDX:EAX = EAX * r/m32)."

[MUL r/m64]
opcode       = REX.W+ F7 /4
operand      = M
props        = R
iread        = RAX
iwrite       = RAX RDX E.OF E.CF
iundef       = E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = MULQ
description  = "Unsigned multiply (RDX:RAX = RAX * r/m64."

[MULPD xmm1, xmm2/m128]
opcode       = 66 0F 59 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MULPD
description  = "Multiply packed double-precision floating-point values in xmm2/m128 by xmm1."

[VMULPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 59 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMULPD
description  = "Multiply packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."

[VMULPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 59 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMULPD
description  = "Multiply packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."

[MULPS xmm1, xmm2/m128]
opcode       = 0F 59 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MULPS
description  = "Multiply packed single-precision floating-point values in xmm2/mem by xmm1."

[VMULPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 59 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMULPS
description  = "Multiply packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."

[VMULPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 59 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMULPS
description  = "Multiply packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."

[MULSD xmm1, xmm2/m64]
opcode       = F2 0F 59 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = MULSD
description  = "Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1."

[VMULSD xmm1,xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 59 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMULSD
description  = "Multiply the low double-precision floating-point value in xmm3/mem64 by low double precision floating-point value in xmm2."

[MULSS xmm1, xmm2/m32]
opcode       = F3 0F 59 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = MULSS
description  = "Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1."

[VMULSS xmm1,xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 59 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMULSS
description  = "Multiply the low single-precision floating-point value in xmm3/mem by the low single-precision floating-point value in xmm2."

[MULX r32a, r32b, r/m32]
opcode       = VEX.NDD.LZ.F2.0F38.W0 F6 /r
operand      = RVM
props        = W, W, R
iread        = EDX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = MULXL
description  = "Unsigned multiply of r/m32 with EDX without affecting arithmetic flags"

[MULX r64a, r64b, r/m64]
opcode       = VEX.NDD.LZ.F2.0F38.W1 F6 /r
operand      = RVM
props        = W, W, R
iread        = RDX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = MULXQ
description  = "Unsigned multiply of r/m64 with RDX without affecting arithmetic flags"

[MWAIT]
opcode       = 0F 01 C9
operand      = NP
iread        = EAX ECX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MONITOR
preferred    = 0
att_mnemonic = MWAIT
description  = "A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."

[NEG r/m8]
opcode       = F6 /3
operand      = M
props        = RW
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = NEGB
description  = "Two's complement negate r/m8."

[NEG r/m8]
opcode       = REX+ F6 /3
operand      = M
props        = RW
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = NEGB
description  = "Two's complement negate r/m8."

[NEG r/m16]
opcode       = F7 /3
operand      = M
props        = RW
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = NEGW
description  = "Two's complement negate r/m16."

[NEG r/m32]
opcode       = F7 /3
operand      = M
props        = RW
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = NEGL
description  = "Two's complement negate r/m32."

[NEG r/m64]
opcode       = REX.W+ F7 /3
operand      = M
props        = RW
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = NEGQ
description  = "Two's complement negate r/m64."

[NOP]
opcode       = 90
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = NOP
description  = "One byte no-operation instruction."

[NOP r/m16]
opcode       = 0F 1F /0
operand      = M
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = NOPL
preferred    = 0
att_mnemonic = NOPW
description  = "Multi-byte no-operation instruction."

[NOP r/m32]
opcode       = 0F 1F /0
operand      = M
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = NOPL
preferred    = 0
att_mnemonic = NOPL
description  = "Multi-byte no-operation instruction."

[NOT r/m8]
opcode       = F6 /2
operand      = M
props        = RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = NOTB
description  = "Reverse each bit of r/m8."

[NOT r/m8]
opcode       = REX+ F6 /2
operand      = M
props        = RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = NOTB
description  = "Reverse each bit of r/m8."

[NOT r/m16]
opcode       = F7 /2
operand      = M
props        = RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = NOTW
description  = "Reverse each bit of r/m16."

[NOT r/m32]
opcode       = F7 /2
operand      = M
props        = RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = NOTL
description  = "Reverse each bit of r/m32."

[NOT r/m64]
opcode       = REX.W+ F7 /2
operand      = M
props        = RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = NOTQ
description  = "Reverse each bit of r/m64."

[OR AL, imm8]
opcode       = 0C ib
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORB
description  = "AL OR imm8."

[OR AX, imm16]
opcode       = 0D iw
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORW
description  = "AX OR imm16."

[OR EAX, imm32]
opcode       = 0D id
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORL
description  = "EAX OR imm32."

[OR RAX, imm32]
opcode       = REX.W+ 0D id
operand      = I
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ORQ
description  = "RAX OR imm32 (sign-extended)."

[OR r/m8, imm8]
opcode       = 80 /1 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORB
description  = "r/m8 OR imm8."

[OR r/m8, imm8]
opcode       = REX+ 80 /1 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ORB
description  = "r/m8 OR imm8."

[OR r/m16, imm16]
opcode       = 81 /1 iw
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORW
description  = "r/m16 OR imm16."

[OR r/m32, imm32]
opcode       = 81 /1 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORL
description  = "r/m32 OR imm32."

[OR r/m64, imm32]
opcode       = REX.W+ 81 /1 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ORQ
description  = "r/m64 OR imm32 (sign-extended)."

[OR r/m16, imm8]
opcode       = 83 /1 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ORW
description  = "r/m16 OR imm8 (sign-extended)."

[OR r/m32, imm8]
opcode       = 83 /1 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ORL
description  = "r/m32 OR imm8 (sign-extended)."

[OR r/m64, imm8]
opcode       = REX.W+ 83 /1 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ORQ
description  = "r/m64 OR imm8 (sign-extended)."

[OR r/m8, r8]
opcode       = 08 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ORB
description  = "r/m8 OR r8."

[OR r/m8, r8]
opcode       = REX+ 08 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ORB
description  = "r/m8 OR r8."

[OR r/m16, r16]
opcode       = 09 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ORW
description  = "r/m16 OR r16."

[OR r/m32, r32]
opcode       = 09 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = ORL
description  = "r/m32 OR r32."

[OR r/m64, r64]
opcode       = REX.W+ 09 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = ORQ
description  = "r/m64 OR r64."

[OR r8, r/m8]
opcode       = 0A /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORB
description  = "r8 OR r/m8."

[OR r8, r/m8]
opcode       = REX+ 0A /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ORB
description  = "r8 OR r/m8."

[OR r16, r/m16]
opcode       = 0B /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORW
description  = "r16 OR r/m16."

[OR r32, r/m32]
opcode       = 0B /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ORL
description  = "r32 OR r/m32."

[OR r64, r/m64]
opcode       = REX.W+ 0B /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.CF E.SF E.ZF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ORQ
description  = "r64 OR r/m64."

[ORPD xmm1, xmm2/m128]
opcode       = 66 0F 56 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = ORPD
description  = "Bitwise OR of xmm2/m128 and xmm1."

[VORPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 56 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VORPD
description  = "Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem."

[VORPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 56 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VORPD
description  = "Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem."

[ORPS xmm1, xmm2/m128]
opcode       = 0F 56 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = ORPS
description  = "Bitwise OR of xmm1 and xmm2/m128."

[VORPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 56 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VORPS
description  = "Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem."

[VORPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 56 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VORPS
description  = "Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem."

[OUT imm8, AL]
opcode       = E6 ib
operand      = I
props        = R, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTB
description  = "Output byte in AL to I/O port address imm8."

[OUT imm8, AX]
opcode       = E7 ib
operand      = I
props        = R, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTW
description  = "Output word in AX to I/O port address imm8."

[OUT imm8, EAX]
opcode       = E7 ib
operand      = I
props        = R, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTL
description  = "Output doubleword in EAX to I/O port address imm8."

[OUT DX, AL]
opcode       = EE
operand      = NP
props        = R, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTB
description  = "Output byte in AL to I/O port address in DX."

[OUT DX, AX]
opcode       = EF
operand      = NP
props        = R, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTW
description  = "Output word in AX to I/O port address in DX."

[OUT DX, EAX]
opcode       = EF
operand      = NP
props        = R, R
iread        = E.IOPL E.VM
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTL
description  = "Output doubleword in EAX to I/O port address in DX."

[OUTS DX, m8]
opcode       = 6E
operand      = NP
props        = R, I
iread        = E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTS
description  = "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."

[OUTS DX, m16]
opcode       = 6F
operand      = NP
props        = R, I
iread        = E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTS
description  = "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."

[OUTS DX, m32]
opcode       = 6F
operand      = NP
props        = R, I
iread        = E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTS
description  = "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."

[OUTSB]
opcode       = 6E
operand      = NP
iread        = E.IOPL E.VM E.DF DX RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTSB
description  = "Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."

[OUTSW]
opcode       = PREF.66+ 6F
operand      = NP
iread        = E.IOPL E.VM E.DF DX RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTSW
description  = "Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."

[OUTSD]
opcode       = 6F
operand      = NP
iread        = E.IOPL E.VM E.DF DX RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = OUTSL
description  = "Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."

[PABSB mm1, mm2/m64]
opcode       = 0F 38 1C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PABSB
description  = "Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1."

[PABSB xmm1, xmm2/m128]
opcode       = 66 0F 38 1C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PABSB
description  = "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."

[PABSW mm1, mm2/m64]
opcode       = 0F 38 1D /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PABSW
description  = "Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1."

[PABSW xmm1, xmm2/m128]
opcode       = 66 0F 38 1D /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PABSW
description  = "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."

[PABSD mm1, mm2/m64]
opcode       = 0F 38 1E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PABSD
description  = "Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1."

[PABSD xmm1, xmm2/m128]
opcode       = 66 0F 38 1E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PABSD
description  = "Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."

[VPABSB xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.WIG 1C /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPABSB
description  = "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."

[VPABSW xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.WIG 1D /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPABSW
description  = "Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."

[VPABSD xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.WIG 1E /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPABSD
description  = "Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."

[VPABSB ymm1, ymm2/m256]
opcode       = VEX.256.66.0F38.WIG 1C /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPABSB
description  = "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1."

[VPABSW ymm1, ymm2/m256]
opcode       = VEX.256.66.0F38.WIG 1D /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPABSW
description  = "Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1"

[VPABSD ymm1, ymm2/m256]
opcode       = VEX.256.66.0F38.WIG 1E /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPABSD
description  = "Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."

[PACKSSWB mm1, mm2/m64]
opcode       = 0F 63 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PACKSSWB
description  = "Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation."

[PACKSSWB xmm1, xmm2/m128]
opcode       = 66 0F 63 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PACKSSWB
description  = "Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation."

[PACKSSDW mm1, mm2/m64]
opcode       = 0F 6B /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PACKSSDW
description  = "Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation."

[PACKSSDW xmm1, xmm2/m128]
opcode       = 66 0F 6B /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PACKSSDW
description  = "Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation."

[VPACKSSWB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 63 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPACKSSWB
description  = "Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation."

[VPACKSSDW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 6B /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPACKSSDW
description  = "Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation."

[VPACKSSWB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 63 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPACKSSWB
description  = "Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation."

[VPACKSSDW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 6B /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPACKSSDW
description  = "Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation."

[PACKUSDW xmm1, xmm2/m128]
opcode       = 66 0F 38 2B /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PACKUSDW
description  = "Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."

[VPACKUSDW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 2B /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPACKUSDW
description  = "Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."

[VPACKUSDW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 2B /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPACKUSDW
description  = "Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m128 into 16 packed unsigned word integers in ymm1 using unsigned saturation."

[PACKUSWB mm, mm/m64]
opcode       = 0F 67 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PACKUSWB
description  = "Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation."

[PACKUSWB xmm1, xmm2/m128]
opcode       = 66 0F 67 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PACKUSWB
description  = "Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."

[VPACKUSWB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 67 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPACKUSWB
description  = "Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."

[VPACKUSWB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 67 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPACKUSWB
description  = "Converts 16 signed word integers from ymm2 And 16 signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation."

[PADDB mm, mm/m64]
opcode       = 0F FC /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PADDB
description  = "Add packed byte integers from mm/m64 and mm."

[PADDB xmm1, xmm2/m128]
opcode       = 66 0F FC /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDB
description  = "Add packed byte integers from xmm2/m128 and xmm1."

[PADDW mm, mm/m64]
opcode       = 0F FD /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PADDW
description  = "Add packed word integers from mm/m64 and mm."

[PADDW xmm1, xmm2/m128]
opcode       = 66 0F FD /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDW
description  = "Add packed word integers from xmm2/m128 and xmm1."

[PADDD mm, mm/m64]
opcode       = 0F FE /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PADDD
description  = "Add packed doubleword integers from mm/m64 and mm."

[PADDD xmm1, xmm2/m128]
opcode       = 66 0F FE /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDD
description  = "Add packed doubleword integers from xmm2/m128 and xmm1."

[VPADDB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG FC /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDB
description  = "Add packed byte integers from xmm3/m128 and xmm2."

[VPADDW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG FD /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDW
description  = "Add packed word integers from xmm3/m128 and xmm2."

[VPADDD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG FE /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDD
description  = "Add packed doubleword integers from xmm3/m128 and xmm2."

[VPADDB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG FC /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDB
description  = "Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1."

[VPADDW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG FD /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDW
description  = "Add packed word integers from ymm2, ymm3/m256 and store in ymm1."

[VPADDD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG FE /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDD
description  = "Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1."

[PADDQ mm1, mm2/m64]
opcode       = 0F D4 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDQ
description  = "Add quadword integer mm2/m64 to mm1."

[PADDQ xmm1, xmm2/m128]
opcode       = 66 0F D4 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDQ
description  = "Add packed quadword integers xmm2/m128 to xmm1."

[VPADDQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D4 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDQ
description  = "Add packed quadword integers xmm3/m128 and xmm2."

[VPADDQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG D4 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDQ
description  = "Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1."

[PADDSB mm, mm/m64]
opcode       = 0F EC /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PADDSB
description  = "Add packed signed byte integers from mm/m64 and mm and saturate the results."

[PADDSB xmm1, xmm2/m128]
opcode       = 66 0F EC /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDSB
description  = "Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results."

[PADDSW mm, mm/m64]
opcode       = 0F ED /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PADDSW
description  = "Add packed signed word integers from mm/m64 and mm and saturate the results."

[PADDSW xmm1, xmm2/m128]
opcode       = 66 0F ED /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDSW
description  = "Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results."

[VPADDSB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG EC /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDSB
description  = "Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results."

[VPADDSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG ED /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDSW
description  = "Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results."

[VPADDSB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG EC /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDSB
description  = "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."

[VPADDSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG ED /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDSW
description  = "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."

[PADDUSB mm, mm/m64]
opcode       = 0F DC /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PADDUSB
description  = "Add packed unsigned byte integers from mm/m64 and mm and saturate the results."

[PADDUSB xmm1, xmm2/m128]
opcode       = 66 0F DC /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDUSB
description  = "Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results."

[PADDUSW mm, mm/m64]
opcode       = 0F DD /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PADDUSW
description  = "Add packed unsigned word integers from mm/m64 and mm and saturate the results."

[PADDUSW xmm1, xmm2/m128]
opcode       = 66 0F DD /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PADDUSW
description  = "Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results."

[VPADDUSB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG DC /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDUSB
description  = "Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results."

[VPADDUSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG DD /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPADDUSW
description  = "Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results."

[VPADDUSB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG DC /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDUSB
description  = "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."

[VPADDUSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG DD /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPADDUSW
description  = "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."

[PALIGNR mm1, mm2/m64, imm8]
opcode       = 0F 3A 0F
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PALIGNR
description  = "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1."

[PALIGNR xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 0F
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PALIGNR
description  = "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1"

[VPALIGNR xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 0F /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPALIGNR
description  = "Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1."

[VPALIGNR ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.WIG 0F /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPALIGNR
description  = "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1."

[PAND mm, mm/m64]
opcode       = 0F DB /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PAND
description  = "Bitwise AND mm/m64 and mm."

[PAND xmm1, xmm2/m128]
opcode       = 66 0F DB /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PAND
description  = "Bitwise AND of xmm2/m128 and xmm1."

[VPAND xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG DB /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPAND
description  = "Bitwise AND of xmm3/m128 and xmm."

[VPAND ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG DB /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPAND
description  = "Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1."

[PANDN mm, mm/m64]
opcode       = 0F DF /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PANDN
description  = "Bitwise AND NOT of mm/m64 and mm."

[PANDN xmm1, xmm2/m128]
opcode       = 66 0F DF /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PANDN
description  = "Bitwise AND NOT of xmm2/m128 and xmm1."

[VPANDN xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG DF /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPANDN
description  = "Bitwise AND NOT of xmm3/m128 and xmm2."

[VPANDN ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG DF /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPANDN
description  = "Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1."

[PAUSE]
opcode       = F3 90
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PAUSE
description  = "Gives hint to processor that improves performance of spin-wait loops."

[PAVGB mm1, mm2/m64]
opcode       = 0F E0 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PAVGB
description  = "Average packed unsigned byte integers from mm2/m64 and mm1 with rounding."

[PAVGB xmm1, xmm2/m128]
opcode       = 66 0F E0 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PAVGB
description  = "Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding."

[PAVGW mm1, mm2/m64]
opcode       = 0F E3 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PAVGW
description  = "Average packed unsigned word integers from mm2/m64 and mm1 with rounding."

[PAVGW xmm1, xmm2/m128]
opcode       = 66 0F E3 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PAVGW
description  = "Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding."

[VPAVGB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E0 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPAVGB
description  = "Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding."

[VPAVGW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E3 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPAVGW
description  = "Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding."

[VPAVGB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG E0 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPAVGB
description  = "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1."

[VPAVGW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG E3 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPAVGW
description  = "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1."

[PBLENDVB xmm1, xmm2/m128, <XMM0>]
opcode       = 66 0F 38 10 /r
operand      = RM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PBLENDVB
description  = "Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1."

[VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4]
opcode       = VEX.NDS.128.66.0F3A.W0 4C /r /is4
operand      = RVMR
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPBLENDVB
description  = "Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1."

[VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4]
opcode       = VEX.NDS.256.66.0F3A.W0 4C /r /is4
operand      = RVMR
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBLENDVB
description  = "Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1."

[PBLENDW xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 0E /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PBLENDW
description  = "Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."

[VPBLENDW xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 0E /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPBLENDW
description  = "Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."

[VPBLENDW ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.WIG 0E /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBLENDW
description  = "Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."

[PCLMULQDQ xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 44 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PCLMULQDQ
preferred    = 0
att_mnemonic = PCLMULQDQ
description  = "Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used."

[VPCLMULQDQ xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.WIG 44 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = PCLMULQDQ AVX
preferred    = 0
att_mnemonic = VPCLMULQDQ
description  = "Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used."

[PCMPEQB mm, mm/m64]
opcode       = 0F 74 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PCMPEQB
description  = "Compare packed bytes in mm/m64 and mm for equality."

[PCMPEQB xmm1, xmm2/m128]
opcode       = 66 0F 74 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PCMPEQB
description  = "Compare packed bytes in xmm2/m128 and xmm1 for equality."

[PCMPEQW mm, mm/m64]
opcode       = 0F 75 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PCMPEQW
description  = "Compare packed words in mm/m64 and mm for equality."

[PCMPEQW xmm1, xmm2/m128]
opcode       = 66 0F 75 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PCMPEQW
description  = "Compare packed words in xmm2/m128 and xmm1 for equality."

[PCMPEQD mm, mm/m64]
opcode       = 0F 76 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PCMPEQD
description  = "Compare packed doublewords in mm/m64 and mm for equality."

[PCMPEQD xmm1, xmm2/m128]
opcode       = 66 0F 76 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PCMPEQD
description  = "Compare packed doublewords in xmm2/m128 and xmm1 for equality."

[VPCMPEQB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 74 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPEQB
description  = "Compare packed bytes in xmm3/m128 and xmm2 for equality."

[VPCMPEQW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 75 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPEQW
description  = "Compare packed words in xmm3/m128 and xmm2 for equality."

[VPCMPEQD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 76 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPEQD
description  = "Compare packed doublewords in xmm3/m128 and xmm2 for equality."

[VPCMPEQB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 74 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPEQB
description  = "Compare packed bytes in ymm3/m256 and ymm2 for equality."

[VPCMPEQW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 75 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPEQW
description  = "Compare packed words in ymm3/m256 and ymm2 for equality."

[VPCMPEQD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 76 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPEQD
description  = "Compare packed doublewords in ymm3/m256 and ymm2 for equality."

[PCMPEQQ xmm1, xmm2/m128]
opcode       = 66 0F 38 29 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PCMPEQQ
description  = "Compare packed qwords in xmm2/m128 and xmm1 for equality."

[VPCMPEQQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 29 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPEQQ
description  = "Compare packed quadwords in xmm3/m128 and xmm2 for equality."

[VPCMPEQQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 29 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPEQQ
description  = "Compare packed quadwords in ymm3/m256 and ymm2 for equality."

[PCMPESTRI xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 61 /r
operand      = RMI
props        = R, R, R
iread        = EAX EDX
iwrite       = RCX E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_2
preferred    = 0
att_mnemonic = PCMPESTRI
description  = "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."

[VPCMPESTRI xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.WIG 61 /r ib
operand      = RMI
props        = R, R, R
iread        = EAX EDX
iwrite       = RCX E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPESTRI
description  = "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."

[PCMPESTRM xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 60 /r
operand      = RMI
props        = R, R, R
iread        = EAX EDX
iwrite       = XMM0 E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_2
preferred    = 0
att_mnemonic = PCMPESTRM
description  = "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0"

[VPCMPESTRM xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.WIG 60 /r ib
operand      = RMI
props        = R, R, R
iread        = EAX EDX
iwrite       = YMM0 E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPESTRM
description  = "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."

[PCMPGTB mm, mm/m64]
opcode       = 0F 64 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PCMPGTB
description  = "Compare packed signed byte integers in mm and mm/m64 for greater than."

[PCMPGTB xmm1, xmm2/m128]
opcode       = 66 0F 64 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PCMPGTB
description  = "Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than."

[PCMPGTW mm, mm/m64]
opcode       = 0F 65 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PCMPGTW
description  = "Compare packed signed word integers in mm and mm/m64 for greater than."

[PCMPGTW xmm1, xmm2/m128]
opcode       = 66 0F 65 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PCMPGTW
description  = "Compare packed signed word integers in xmm1 and xmm2/m128 for greater than."

[PCMPGTD mm, mm/m64]
opcode       = 0F 66 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PCMPGTD
description  = "Compare packed signed doubleword integers in mm and mm/m64 for greater than."

[PCMPGTD xmm1, xmm2/m128]
opcode       = 66 0F 66 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PCMPGTD
description  = "Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than."

[VPCMPGTB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 64 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPGTB
description  = "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than."

[VPCMPGTW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 65 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPGTW
description  = "Compare packed signed word integers in xmm2 and xmm3/m128 for greater than."

[VPCMPGTD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 66 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPGTD
description  = "Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than."

[VPCMPGTB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 64 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPGTB
description  = "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than."

[VPCMPGTW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 65 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPGTW
description  = "Compare packed signed word integers in ymm2 and ymm3/m256 for greater than."

[VPCMPGTD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 66 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPGTD
description  = "Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than."

[PCMPGTQ xmm1, xmm2/m128]
opcode       = 66 0F 38 37 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_2
preferred    = 0
att_mnemonic = PCMPGTQ
description  = "Compare packed signed qwords in xmm2/m128 and xmm1 for greater than."

[VPCMPGTQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 37 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPGTQ
description  = "Compare packed signed qwords in xmm2 and xmm3/m128 for greater than."

[VPCMPGTQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 37 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPCMPGTQ
description  = "Compare packed signed qwords in ymm2 and ymm3/m256 for greater than."

[PCMPISTRI xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 63 /r
operand      = RM
props        = R, R, R
iwrite       = RCX E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_2
preferred    = 0
att_mnemonic = PCMPISTRI
description  = "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."

[VPCMPISTRI xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.WIG 63 /r ib
operand      = RM
props        = R, R, R
iwrite       = RCX E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPISTRI
description  = "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."

[PCMPISTRM xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 62 /r
operand      = RM
props        = R, R, R
iwrite       = XMM0 E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_2
preferred    = 0
att_mnemonic = PCMPISTRM
description  = "Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0."

[VPCMPISTRM xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.WIG 62 /r ib
operand      = RM
props        = R, R, R
iwrite       = YMM0 E.CF E.ZF E.SF E.OF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPCMPISTRM
description  = "Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0."

[PDEP r32a, r32b, r/m32]
opcode       = VEX.NDS.LZ.F2.0F38.W0 F5 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = PDEPL
description  = "Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a."

[PDEP r64a, r64b, r/m64]
opcode       = VEX.NDS.LZ.F2.0F38.W1 F5 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = PDEPQ
description  = "Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a."

[PEXT r32a, r32b, r/m32]
opcode       = VEX.NDS.LZ.F3.0F38.W0 F5 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = PEXTL
description  = "Parallel extract of bits from r32b using mask in r/m32, result is written to r32a."

[PEXT r64a, r64b, r/m64]
opcode       = VEX.NDS.LZ.F3.0F38.W1 F5 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = PEXTQ
description  = "Parallel extract of bits from r64b using mask in r/m64, result is written to r64a."

[PEXTRB reg/m8, xmm2, imm8]
opcode       = 66 0F 3A 14 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PEXTRB
description  = "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed."

[PEXTRD r/m32, xmm2, imm8]
opcode       = 66 0F 3A 16 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PEXTRD
description  = "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32."

[PEXTRQ r/m64, xmm2, imm8]
opcode       = 66 REX.W+ 0F 3A 16 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PEXTRQ
description  = "Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64."

[VPEXTRB reg/m8, xmm2, imm8]
opcode       = VEX.128.66.0F3A.W0 14 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPEXTRB
description  = "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with"

[VPEXTRD r32/m32, xmm2, imm8]
opcode       = VEX.128.66.0F3A.W0 16 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPEXTRD
description  = "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32."

[VPEXTRQ r64/m64, xmm2, imm8]
opcode       = VEX.128.66.0F3A.W1 16 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPEXTRQ
description  = "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64."

[PEXTRW reg, mm, imm8]
opcode       = 0F C5 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PEXTRW
description  = "Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."

[PEXTRW reg, xmm, imm8]
opcode       = 66 0F C5 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = PEXTRW
description  = "Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."

[PEXTRW reg/m16, xmm, imm8]
opcode       = 66 0F 3A 15 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PEXTRW
description  = "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64."

[VPEXTRW reg, xmm1, imm8]
opcode       = VEX.128.66.0F.W0 C5 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 1
att_mnemonic = VPEXTRW
description  = "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros."

[VPEXTRW reg/m16, xmm2, imm8]
opcode       = VEX.128.66.0F3A.W0 15 /r ib
operand      = MRI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPEXTRW
description  = "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros."

[PHADDW mm1, mm2/m64]
opcode       = 0F 38 01 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHADDW
description  = "Add 16-bit integers horizontally, pack to MM1."

[PHADDW xmm1, xmm2/m128]
opcode       = 66 0F 38 01 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHADDW
description  = "Add 16-bit integers horizontally, pack to XMM1."

[PHADDD mm1, mm2/m64]
opcode       = 0F 38 02 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHADDD
description  = "Add 32-bit integers horizontally, pack to MM1."

[PHADDD xmm1, xmm2/m128]
opcode       = 66 0F 38 02 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHADDD
description  = "Add 32-bit integers horizontally, pack to XMM1."

[VPHADDW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 01 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPHADDW
description  = "Add 16-bit integers horizontally, pack to xmm1."

[VPHADDD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 02 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPHADDD
description  = "Add 32-bit integers horizontally, pack to xmm1."

[VPHADDW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 01 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPHADDW
description  = "Add 16-bit signed integers horizontally, pack to ymm1."

[VPHADDD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 02 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPHADDD
description  = "Add 32-bit signed integers horizontally, pack to ymm1."

[PHADDSW mm1, mm2/m64]
opcode       = 0F 38 03 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHADDSW
description  = "Add 16-bit signed integers horizontally, pack saturated integers to MM1."

[PHADDSW xmm1, xmm2/m128]
opcode       = 66 0F 38 03 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHADDSW
description  = "Add 16-bit signed integers horizontally, pack saturated integers to XMM1."

[VPHADDSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 03 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPHADDSW
description  = "Add 16-bit signed integers horizontally, pack saturated integers to xmm1."

[VPHADDSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 03 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPHADDSW
description  = "Add 16-bit signed integers horizontally, pack saturated integers to ymm1."

[PHMINPOSUW xmm1, xmm2/m128]
opcode       = 66 0F 38 41 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PHMINPOSUW
description  = "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."

[VPHMINPOSUW xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.WIG 41 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPHMINPOSUW
description  = "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."

[PHSUBW mm1, mm2/m64]
opcode       = 0F 38 05 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHSUBW
description  = "Subtract 16-bit signed integers horizontally, pack to MM1."

[PHSUBW xmm1, xmm2/m128]
opcode       = 66 0F 38 05 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHSUBW
description  = "Subtract 16-bit signed integers horizontally, pack to XMM1."

[PHSUBD mm1, mm2/m64]
opcode       = 0F 38 06 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHSUBD
description  = "Subtract 32-bit signed integers horizontally, pack to MM1."

[PHSUBD xmm1, xmm2/m128]
opcode       = 66 0F 38 06 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHSUBD
description  = "Subtract 32-bit signed integers horizontally, pack to XMM1"

[VPHSUBW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 05 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPHSUBW
description  = "Subtract 16-bit signed integers horizontally, pack to xmm1."

[VPHSUBD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 06 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPHSUBD
description  = "Subtract 32-bit signed integers horizontally, pack to xmm1."

[VPHSUBW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 05 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPHSUBW
description  = "Subtract 16-bit signed integers horizontally, pack to ymm1."

[VPHSUBD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 06 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPHSUBD
description  = "Subtract 32-bit signed integers horizontally, pack to ymm1."

[PHSUBSW mm1, mm2/m64]
opcode       = 0F 38 07 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHSUBSW
description  = "Subtract 16-bit signed integer horizontally, pack saturated integers to MM1."

[PHSUBSW xmm1, xmm2/m128]
opcode       = 66 0F 38 07 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PHSUBSW
description  = "Subtract 16-bit signed integer horizontally, pack saturated integers to XMM1"

[VPHSUBSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 07 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPHSUBSW
description  = "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."

[VPHSUBSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 07 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPHSUBSW
description  = "Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1."

[PINSRB xmm1, r32/m8, imm8]
opcode       = 66 0F 3A 20 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PINSRB
description  = "Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8."

[PINSRD xmm1, r/m32, imm8]
opcode       = 66 0F 3A 22 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PINSRD
description  = "Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8."

[PINSRQ xmm1, r/m64, imm8]
opcode       = 66 REX.W+ 0F 3A 22 /r ib
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PINSRQ
description  = "Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8."

[VPINSRB xmm1, xmm2, r32/m8, imm8]
opcode       = VEX.NDS.128.66.0F3A.W0 20 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPINSRB
description  = "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8."

[VPINSRD xmm1, xmm2, r32/m32, imm8]
opcode       = VEX.NDS.128.66.0F3A.W0 22 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPINSRD
description  = "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8."

[VPINSRQ xmm1, xmm2, r64/m64, imm8]
opcode       = VEX.NDS.128.66.0F3A.W1 22 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPINSRQ
description  = "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8."

[PINSRW mm, r32/m16, imm8]
opcode       = 0F C4 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PINSRW
description  = "Insert the low word from r32 or from m16 into mm at the word position specified by imm8"

[PINSRW xmm, r32/m16, imm8]
opcode       = 66 0F C4 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PINSRW
description  = "Move the low word of r32 or from m16 into xmm at the word position specified by imm8."

[VPINSRW xmm1, xmm2, r32/m16, imm8]
opcode       = VEX.NDS.128.66.0F.W0 C4 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPINSRW
description  = "Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8."

[PMADDUBSW mm1, mm2/m64]
opcode       = 0F 38 04 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX SSSE3
preferred    = 0
att_mnemonic = PMADDUBSW
description  = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to MM1."

[PMADDUBSW xmm1, xmm2/m128]
opcode       = 66 0F 38 04 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PMADDUBSW
description  = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to XMM1."

[VPMADDUBSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 04 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMADDUBSW
description  = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."

[VPMADDUBSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 04 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMADDUBSW
description  = "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1."

[PMADDWD mm, mm/m64]
opcode       = 0F F5 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PMADDWD
description  = "Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm."

[PMADDWD xmm1, xmm2/m128]
opcode       = 66 0F F5 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMADDWD
description  = "Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1."

[VPMADDWD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F5 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMADDWD
description  = "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1."

[VPMADDWD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG F5 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMADDWD
description  = "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1."

[PMAXSB xmm1, xmm2/m128]
opcode       = 66 0F 38 3C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMAXSB
description  = "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."

[VPMAXSB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 3C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMAXSB
description  = "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."

[VPMAXSB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 3C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMAXSB
description  = "Compare packed signed byte integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1."

[PMAXSD xmm1, xmm2/m128]
opcode       = 66 0F 38 3D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMAXSD
description  = "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."

[VPMAXSD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 3D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMAXSD
description  = "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."

[VPMAXSD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 3D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMAXSD
description  = "Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed maximum values in ymm1."

[PMAXSW mm1, mm2/m64]
opcode       = 0F EE /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PMAXSW
description  = "Compare signed word integers in mm2/m64 and mm1 and return maximum values."

[PMAXSW xmm1, xmm2/m128]
opcode       = 66 0F EE /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMAXSW
description  = "Compare signed word integers in xmm2/m128 and xmm1 and return maximum values."

[VPMAXSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG EE /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMAXSW
description  = "Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1."

[VPMAXSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG EE /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMAXSW
description  = "Compare packed signed word integers in ymm3/m128 and ymm2 and store packed maximum values in ymm1."

[PMAXUB mm1, mm2/m64]
opcode       = 0F DE /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PMAXUB
description  = "Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values."

[PMAXUB xmm1, xmm2/m128]
opcode       = 66 0F DE /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMAXUB
description  = "Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values."

[VPMAXUB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG DE /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMAXUB
description  = "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."

[VPMAXUB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG DE /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMAXUB
description  = "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."

[PMAXUD xmm1, xmm2/m128]
opcode       = 66 0F 38 3F /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMAXUD
description  = "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."

[VPMAXUD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 3F /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMAXUD
description  = "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."

[VPMAXUD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 3F /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMAXUD
description  = "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."

[PMAXUW xmm1, xmm2/m128]
opcode       = 66 0F 38 3E /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMAXUW
description  = "Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."

[VPMAXUW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 3E /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMAXUW
description  = "Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1."

[VPMAXUW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 3E /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMAXUW
description  = "Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1."

[PMINSB xmm1, xmm2/m128]
opcode       = 66 0F 38 38 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMINSB
description  = "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."

[VPMINSB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 38 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMINSB
description  = "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."

[VPMINSB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 38 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMINSB
description  = "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."

[PMINSD xmm1, xmm2/m128]
opcode       = 66 0F 38 39 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMINSD
description  = "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."

[VPMINSD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 39 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMINSD
description  = "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."

[VPMINSD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 39 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMINSD
description  = "Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1."

[PMINSW mm1, mm2/m64]
opcode       = 0F EA /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PMINSW
description  = "Compare signed word integers in mm2/m64 and mm1 and return minimum values."

[PMINSW xmm1, xmm2/m128]
opcode       = 66 0F EA /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMINSW
description  = "Compare signed word integers in xmm2/m128 and xmm1 and return minimum values."

[VPMINSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG EA /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMINSW
description  = "Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."

[PMINUB mm1, mm2/m64]
opcode       = 0F DA /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PMINUB
description  = "Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values."

[PMINUB xmm1, xmm2/m128]
opcode       = 66 0F DA /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMINUB
description  = "Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values."

[VPMINUB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG DA /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMINUB
description  = "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."

[VPMINUB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG DA /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMINUB
description  = "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."

[PMINUD xmm1, xmm2/m128]
opcode       = 66 0F 38 3B /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMINUD
description  = "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."

[VPMINUD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 3B /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMINUD
description  = "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."

[VPMINUD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 3B /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMINUD
description  = "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."

[PMINUW xmm1, xmm2/m128]
opcode       = 66 0F 38 3A /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMINUW
description  = "Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."

[VPMINUW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 3A /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMINUW
description  = "Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."

[VPMINUW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 3A /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMINUW
description  = "Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1."

[PMOVMSKB reg, mm]
opcode       = 0F D7 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PMOVMSKB
description  = "Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed"

[PMOVMSKB reg, xmm]
opcode       = 66 0F D7 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMOVMSKB
description  = "Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed"

[VPMOVMSKB reg, xmm1]
opcode       = VEX.128.66.0F.WIG D7 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVMSKB
description  = "Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros."

[VPMOVMSKB reg, ymm1]
opcode       = VEX.256.66.0F.WIG D7 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVMSKB
description  = "Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros."

[PMOVSXBW xmm1, xmm2/m64]
opcode       = 66 0f 38 20 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVSXBW
description  = "Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1."

[PMOVSXBD xmm1, xmm2/m32]
opcode       = 66 0f 38 21 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVSXBD
description  = "Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1."

[PMOVSXBQ xmm1, xmm2/m16]
opcode       = 66 0f 38 22 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVSXBQ
description  = "Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1."

[PMOVSXWD xmm1, xmm2/m64]
opcode       = 66 0f 38 23 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVSXWD
description  = "Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1."

[PMOVSXWQ xmm1, xmm2/m32]
opcode       = 66 0f 38 24 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVSXWQ
description  = "Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1."

[PMOVSXDQ xmm1, xmm2/m64]
opcode       = 66 0f 38 25 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVSXDQ
description  = "Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1."

[VPMOVSXBW xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.WIG 20 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVSXBW
description  = "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."

[VPMOVSXBD xmm1, xmm2/m32]
opcode       = VEX.128.66.0F38.WIG 21 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVSXBD
description  = "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."

[VPMOVSXBQ xmm1, xmm2/m16]
opcode       = VEX.128.66.0F38.WIG 22 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVSXBQ
description  = "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."

[VPMOVSXWD xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.WIG 23 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVSXWD
description  = "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."

[VPMOVSXWQ xmm1, xmm2/m32]
opcode       = VEX.128.66.0F38.WIG 24 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVSXWQ
description  = "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."

[VPMOVSXDQ xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.WIG 25 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVSXDQ
description  = "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1"

[VPMOVSXBW ymm1, xmm2/m128]
opcode       = VEX.256.66.0F38.WIG 20 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVSXBW
description  = "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."

[VPMOVSXBD ymm1, xmm2/m64]
opcode       = VEX.256.66.0F38.WIG 21 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVSXBD
description  = "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."

[VPMOVSXBQ ymm1, xmm2/m32]
opcode       = VEX.256.66.0F38.WIG 22 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVSXBQ
description  = "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."

[VPMOVSXWD ymm1, xmm2/m128]
opcode       = VEX.256.66.0F38.WIG 23 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVSXWD
description  = "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1."

[VPMOVSXWQ ymm1, xmm2/m64]
opcode       = VEX.256.66.0F38.WIG 24 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVSXWQ
description  = "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1."

[VPMOVSXDQ ymm1, xmm2/m128]
opcode       = VEX.256.66.0F38.WIG 25 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVSXDQ
description  = "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1."

[PMOVZXBW xmm1, xmm2/m64]
opcode       = 66 0f 38 30 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVZXBW
description  = "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."

[PMOVZXBD xmm1, xmm2/m32]
opcode       = 66 0f 38 31 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVZXBD
description  = "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."

[PMOVZXBQ xmm1, xmm2/m16]
opcode       = 66 0f 38 32 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVZXBQ
description  = "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."

[PMOVZXWD xmm1, xmm2/m64]
opcode       = 66 0f 38 33 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVZXWD
description  = "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."

[PMOVZXWQ xmm1, xmm2/m32]
opcode       = 66 0f 38 34 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVZXWQ
description  = "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."

[PMOVZXDQ xmm1, xmm2/m64]
opcode       = 66 0f 38 35 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMOVZXDQ
description  = "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."

[VPMOVZXBW xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.WIG 30 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVZXBW
description  = "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."

[VPMOVZXBD xmm1, xmm2/m32]
opcode       = VEX.128.66.0F38.WIG 31 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVZXBD
description  = "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."

[VPMOVZXBQ xmm1, xmm2/m16]
opcode       = VEX.128.66.0F38.WIG 32 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVZXBQ
description  = "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."

[VPMOVZXWD xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.WIG 33 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVZXWD
description  = "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."

[VPMOVZXWQ xmm1, xmm2/m32]
opcode       = VEX.128.66.0F38.WIG 34 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVZXWQ
description  = "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."

[VPMOVZXDQ xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.WIG 35 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMOVZXDQ
description  = "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."

[VPMOVZXBW ymm1, xmm2/m128]
opcode       = VEX.256.66.0F38.WIG 30 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVZXBW
description  = "Zero extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 16-bit integers in ymm1."

[VPMOVZXBD ymm1, xmm2/m64]
opcode       = VEX.256.66.0F38.WIG 31 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVZXBD
description  = "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."

[VPMOVZXBQ ymm1, xmm2/m32]
opcode       = VEX.256.66.0F38.WIG 32 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVZXBQ
description  = "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."

[VPMOVZXWD ymm1, xmm2/m128]
opcode       = VEX.256.66.0F38.WIG 33 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVZXWD
description  = "Zero extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1"

[VPMOVZXWQ ymm1, xmm2/m64]
opcode       = VEX.256.66.0F38.WIG 34 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVZXWQ
description  = "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1."

[VPMOVZXDQ ymm1, xmm2/m128]
opcode       = VEX.256.66.0F38.WIG 35 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMOVZXDQ
description  = "Zero extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1."

[PMULDQ xmm1, xmm2/m128]
opcode       = 66 0F 38 28 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMULDQ
description  = "Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1."

[VPMULDQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 28 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMULDQ
description  = "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1."

[VPMULDQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 28 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMULDQ
description  = "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1."

[PMULHRSW mm1, mm2/m64]
opcode       = 0F 38 0B /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PMULHRSW
description  = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to MM1."

[PMULHRSW xmm1, xmm2/m128]
opcode       = 66 0F 38 0B /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PMULHRSW
description  = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to XMM1."

[VPMULHRSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 0B /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMULHRSW
description  = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."

[VPMULHRSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 0B /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMULHRSW
description  = "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1."

[PMULHUW mm1, mm2/m64]
opcode       = 0F E4 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PMULHUW
description  = "Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."

[PMULHUW xmm1, xmm2/m128]
opcode       = 66 0F E4 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMULHUW
description  = "Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."

[VPMULHUW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E4 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMULHUW
description  = "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."

[VPMULHUW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG E4 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMULHUW
description  = "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."

[PMULHW mm, mm/m64]
opcode       = 0F E5 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PMULHW
description  = "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."

[PMULHW xmm1, xmm2/m128]
opcode       = 66 0F E5 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMULHW
description  = "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."

[VPMULHW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E5 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMULHW
description  = "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."

[VPMULHW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG E5 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMULHW
description  = "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."

[PMULLD xmm1, xmm2/m128]
opcode       = 66 0F 38 40 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PMULLD
description  = "Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1."

[VPMULLD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 40 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMULLD
description  = "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."

[VPMULLD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 40 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMULLD
description  = "Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1."

[PMULLW mm, mm/m64]
opcode       = 0F D5 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PMULLW
description  = "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1."

[PMULLW xmm1, xmm2/m128]
opcode       = 66 0F D5 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMULLW
description  = "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1."

[VPMULLW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D5 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMULLW
description  = "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."

[VPMULLW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG D5 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMULLW
description  = "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1."

[PMULUDQ mm1, mm2/m64]
opcode       = 0F F4 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMULUDQ
description  = "Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1."

[PMULUDQ xmm1, xmm2/m128]
opcode       = 66 0F F4 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PMULUDQ
description  = "Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1."

[VPMULUDQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F4 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPMULUDQ
description  = "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1."

[VPMULUDQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG F4 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMULUDQ
description  = "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1."

[POP r/m16]
opcode       = 8F /0
operand      = M
props        = W
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = POPW
description  = "Pop top of stack into m16; increment stack pointer."

[POP r/m32]
opcode       = 8F /0
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into m32; increment stack pointer."

[POP r/m64]
opcode       = 8F /0
operand      = M
props        = W
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = POPQ
description  = "Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size."

[POP r16]
opcode       = 58 +rw
operand      = O
props        = W
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = POPW
description  = "Pop top of stack into r16; increment stack pointer."

[POP r32]
opcode       = 58 +rd
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into r32; increment stack pointer."

[POP r64]
opcode       = 58 +rd
operand      = O
props        = W
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = POPQ
description  = "Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size."

[POP DS]
opcode       = 1F
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into DS; increment stack pointer."

[POP ES]
opcode       = 07
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into ES; increment stack pointer."

[POP SS]
opcode       = 17
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into SS; increment stack pointer."

[POP FS, p66]
opcode       = PREF.66+ 0F A1
operand      = NP
props        = W, I
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = POPQ
description  = "Pop top of stack into FS; increment stack pointer by 16 bits."

[POP FS]
opcode       = 0F A1
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into FS; increment stack pointer by 32 bits."

[POP FS]
opcode       = 0F A1
operand      = NP
props        = W
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = POPQ
description  = "Pop top of stack into FS; increment stack pointer by 64 bits."

[POP GS, p66]
opcode       = PREF.66+ 0F A9
operand      = NP
props        = W, I
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = POPQ
description  = "Pop top of stack into GS; increment stack pointer by 16 bits."

[POP GS]
opcode       = 0F A9
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into GS; increment stack pointer by 32 bits."

[POP GS]
opcode       = 0F A9
operand      = NP
props        = W
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = POPQ
description  = "Pop top of stack into GS; increment stack pointer by 64 bits."

[POPA]
opcode       = 61
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Pop DI, SI, BP, BX, DX, CX, and AX."

[POPAD]
opcode       = 61
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."

[POPCNT r16, r/m16]
opcode       = F3 0F B8 /r
operand      = RM
props        = W, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = POPCNT
preferred    = 0
att_mnemonic = POPCNTW
description  = "POPCNT on r/m16"

[POPCNT r32, r/m32]
opcode       = F3 0F B8 /r
operand      = RM
props        = W, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = POPCNT
preferred    = 0
att_mnemonic = POPCNTL
description  = "POPCNT on r/m32"

[POPCNT r64, r/m64]
opcode       = F3 REX.W+ 0F B8 /r
operand      = RM
props        = W, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = POPCNT
preferred    = 0
att_mnemonic = POPCNTQ
description  = "POPCNT on r/m64"

[POPF]
opcode       = 66 9D
operand      = NP
iread        = RSP
iwrite       = E.* RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = POPFW
description  = "Pop top of stack into lower 16 bits of EFLAGS."

[POPFD]
opcode       = 9D
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Pop top of stack into EFLAGS."

[POPFQ]
opcode       = 9D
operand      = NP
iread        = RSP
iwrite       = E.* RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = POPFQ
description  = "Pop top of stack and zero-extend into RFLAGS."

[POR mm, mm/m64]
opcode       = 0F EB /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = POR
description  = "Bitwise OR of mm/m64 and mm."

[POR xmm1, xmm2/m128]
opcode       = 66 0F EB /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = POR
description  = "Bitwise OR of xmm2/m128 and xmm1."

[VPOR xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG EB /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPOR
description  = "Bitwise OR of xmm2/m128 and xmm3."

[VPOR ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG EB /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPOR
description  = "Bitwise OR of ymm2/m256 and ymm3"

[PREFETCHT0 m8]
opcode       = 0F 18 /1
operand      = M
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PREFETCHT0
description  = "Move data from m8 closer to the processor using T0 hint."

[PREFETCHT1 m8]
opcode       = 0F 18 /2
operand      = M
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PREFETCHT1
description  = "Move data from m8 closer to the processor using T1 hint."

[PREFETCHT2 m8]
opcode       = 0F 18 /3
operand      = M
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PREFETCHT2
description  = "Move data from m8 closer to the processor using T2 hint."

[PREFETCHNTA m8]
opcode       = 0F 18 /0
operand      = M
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PREFETCHNTA
description  = "Move data from m8 closer to the processor using NTA hint."

[PSADBW mm1, mm2/m64]
opcode       = 0F F6 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = PSADBW
description  = "Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result."

[PSADBW xmm1, xmm2/m128]
opcode       = 66 0F F6 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSADBW
description  = "Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."

[VPSADBW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F6 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSADBW
description  = "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."

[VPSADBW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG F6 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSADBW
description  = "Computes the absolute differences of the packed unsigned byte integers from ymm3/m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."

[PSHUFB mm1, mm2/m64]
opcode       = 0F 38 00 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSHUFB
description  = "Shuffle bytes in mm1 according to contents of mm2/m64."

[PSHUFB xmm1, xmm2/m128]
opcode       = 66 0F 38 00 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSHUFB
description  = "Shuffle bytes in xmm1 according to contents of xmm2/m128."

[VPSHUFB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 00 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSHUFB
description  = "Shuffle bytes in xmm2 according to contents of xmm3/m128."

[VPSHUFB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.WIG 00 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSHUFB
description  = "Shuffle bytes in ymm2 according to contents of ymm3/m256."

[PSHUFD xmm1, xmm2/m128, imm8]
opcode       = 66 0F 70 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSHUFD
description  = "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."

[VPSHUFD xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F.WIG 70 /r ib
operand      = RMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSHUFD
description  = "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."

[VPSHUFD ymm1, ymm2/m256, imm8]
opcode       = VEX.256.66.0F.WIG 70 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSHUFD
description  = "Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."

[PSHUFHW xmm1, xmm2/m128, imm8]
opcode       = F3 0F 70 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSHUFHW
description  = "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."

[VPSHUFHW xmm1, xmm2/m128, imm8]
opcode       = VEX.128.F3.0F.WIG 70 /r ib
operand      = RMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSHUFHW
description  = "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."

[VPSHUFHW ymm1, ymm2/m256, imm8]
opcode       = VEX.256.F3.0F.WIG 70 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSHUFHW
description  = "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."

[PSHUFLW xmm1, xmm2/m128, imm8]
opcode       = F2 0F 70 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSHUFLW
description  = "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."

[VPSHUFLW xmm1, xmm2/m128, imm8]
opcode       = VEX.128.F2.0F.WIG 70 /r ib
operand      = RMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSHUFLW
description  = "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."

[VPSHUFLW ymm1, ymm2/m256, imm8]
opcode       = VEX.256.F2.0F.WIG 70 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSHUFLW
description  = "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."

[PSHUFW mm1, mm2/m64, imm8]
opcode       = 0F 70 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PSHUFW
description  = "Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1."

[PSIGNB mm1, mm2/m64]
opcode       = 0F 38 08 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSIGNB
description  = "Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64"

[PSIGNB xmm1, xmm2/m128]
opcode       = 66 0F 38 08 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSIGNB
description  = "Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128."

[PSIGNW mm1, mm2/m64]
opcode       = 0F 38 09 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSIGNW
description  = "Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128."

[PSIGNW xmm1, xmm2/m128]
opcode       = 66 0F 38 09 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSIGNW
description  = "Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128."

[PSIGND mm1, mm2/m64]
opcode       = 0F 38 0A /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSIGND
description  = "Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128."

[PSIGND xmm1, xmm2/m128]
opcode       = 66 0F 38 0A /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSSE3
preferred    = 0
att_mnemonic = PSIGND
description  = "Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128."

[VPSIGNB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 08 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSIGNB
description  = "Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128."

[VPSIGNW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 09 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSIGNW
description  = "Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128."

[VPSIGND xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.WIG 0A /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSIGND
description  = "Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128."

[PSLLDQ xmm1, imm8]
opcode       = 66 0F 73 /7 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSLLDQ
description  = "Shift xmm1 left by imm8 bytes while shifting in 0s."

[VPSLLDQ xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 73 /7 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSLLDQ
description  = "Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1."

[VPSLLDQ ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 73 /7 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLDQ
description  = "Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1."

[PSLLW mm, mm/m64]
opcode       = 0F F1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSLLW
description  = "Shift words in mm left mm/m64 while shifting in 0s."

[PSLLW xmm1, xmm2/m128]
opcode       = 66 0F F1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSLLW
description  = "Shift words in xmm1 left by xmm2/m128 while shifting in 0s."

[PSLLW mm1, imm8]
opcode       = 0F 71 /6 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSLLW
description  = "Shift words in mm left by imm8 while shifting in 0s."

[PSLLW xmm1, imm8]
opcode       = 66 0F 71 /6 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 1
att_mnemonic = PSLLW
description  = "Shift words in xmm1 left by imm8 while shifting in 0s."

[PSLLD mm, mm/m64]
opcode       = 0F F2 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSLLD
description  = "Shift doublewords in mm left by mm/m64 while shifting in 0s."

[PSLLD xmm1, xmm2/m128]
opcode       = 66 0F F2 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSLLD
description  = "Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s."

[PSLLD mm, imm8]
opcode       = 0F 72 /6 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSLLD
description  = "Shift doublewords in mm left by imm8 while shifting in 0s."

[PSLLD xmm1, imm8]
opcode       = 66 0F 72 /6 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSLLD
description  = "Shift doublewords in xmm1 left by imm8 while shifting in 0s."

[PSLLQ mm, mm/m64]
opcode       = 0F F3 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSLLQ
description  = "Shift quadword in mm left by mm/m64 while shifting in 0s."

[PSLLQ xmm1, xmm2/m128]
opcode       = 66 0F F3 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSLLQ
description  = "Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s."

[PSLLQ mm, imm8]
opcode       = 0F 73 /6 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSLLQ
description  = "Shift quadword in mm left by imm8 while shifting in 0s."

[PSLLQ xmm1, imm8]
opcode       = 66 0F 73 /6 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSLLQ
description  = "Shift quadwords in xmm1 left by imm8 while shifting in 0s."

[VPSLLW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F1 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSLLW
description  = "Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."

[VPSLLW xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 71 /6 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSLLW
description  = "Shift words in xmm2 left by imm8 while shifting in 0s."

[VPSLLD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F2 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSLLD
description  = "Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."

[VPSLLD xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 72 /6 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSLLD
description  = "Shift doublewords in xmm2 left by imm8 while shifting in 0s."

[VPSLLQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F3 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSLLQ
description  = "Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."

[VPSLLQ xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 73 /6 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSLLQ
description  = "Shift quadwords in xmm2 left by imm8 while shifting in 0s."

[VPSLLW ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG F1 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLW
description  = "Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."

[VPSLLW ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 71 /6 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLW
description  = "Shift words in ymm2 left by imm8 while shifting in 0s."

[VPSLLD ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG F2 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLD
description  = "Shift doublewords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s"

[VPSLLD ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 72 /6 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLD
description  = "Shift doublewords in ymm2 left by imm8 while shifting in 0s."

[VPSLLQ ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG F3 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLQ
description  = "Shift quadwords in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."

[VPSLLQ ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 73 /6 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLQ
description  = "Shift quadwords in ymm2 left by imm8 while shifting in 0s."

[PSRAW mm, mm/m64]
opcode       = 0F E1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRAW
description  = "Shift words in mm right by mm/m64 while shifting in sign bits."

[PSRAW xmm1, xmm2/m128]
opcode       = 66 0F E1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRAW
description  = "Shift words in xmm1 right by xmm2/m128 while shifting in sign bits."

[PSRAW mm, imm8]
opcode       = 0F 71 /4 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRAW
description  = "Shift words in mm right by imm8 while shifting in sign bits"

[PSRAW xmm1, imm8]
opcode       = 66 0F 71 /4 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRAW
description  = "Shift words in xmm1 right by imm8 while shifting in sign bits"

[PSRAD mm, mm/m64]
opcode       = 0F E2 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRAD
description  = "Shift doublewords in mm right by mm/m64 while shifting in sign bits."

[PSRAD xmm1, xmm2/m128]
opcode       = 66 0F E2 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRAD
description  = "Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits."

[PSRAD mm, imm8]
opcode       = 0F 72 /4 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRAD
description  = "Shift doublewords in mm right by imm8 while shifting in sign bits."

[PSRAD xmm1, imm8]
opcode       = 66 0F 72 /4 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRAD
description  = "Shift doublewords in xmm1 right by imm8 while shifting in sign bits."

[VPSRAW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E1 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRAW
description  = "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."

[VPSRAW xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 71 /4 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRAW
description  = "Shift words in xmm2 right by imm8 while shifting in sign bits."

[VPSRAD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E2 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRAD
description  = "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."

[VPSRAD xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 72 /4 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRAD
description  = "Shift doublewords in xmm2 right by imm8 while shifting in sign bits."

[VPSRAW ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG E1 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRAW
description  = "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."

[VPSRAW ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 71 /4 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRAW
description  = "Shift words in ymm2 right by imm8 while shifting in sign bits."

[VPSRAD ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG E2 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRAD
description  = "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."

[VPSRAD ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 72 /4 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRAD
description  = "Shift doublewords in ymm2 right by imm8 while shifting in sign bits."

[PSRLDQ xmm1, imm8]
opcode       = 66 0F 73 /3 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRLDQ
description  = "Shift xmm1 right by imm8 while shifting in 0s."

[VPSRLDQ xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 73 /3 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRLDQ
description  = "Shift xmm2 right by imm8 bytes while shifting in 0s."

[VPSRLDQ ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 73 /3 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLDQ
description  = "Shift ymm1 right by imm8 bytes while shifting in 0s."

[PSRLW mm, mm/m64]
opcode       = 0F D1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRLW
description  = "Shift words in mm right by amount specified in mm/m64 while shifting in 0s."

[PSRLW xmm1, xmm2/m128]
opcode       = 66 0F D1 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRLW
description  = "Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."

[PSRLW mm, imm8]
opcode       = 0F 71 /2 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRLW
description  = "Shift words in mm right by imm8 while shifting in 0s."

[PSRLW xmm1, imm8]
opcode       = 66 0F 71 /2 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRLW
description  = "Shift words in xmm1 right by imm8 while shifting in 0s."

[PSRLD mm, mm/m64]
opcode       = 0F D2 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRLD
description  = "Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s."

[PSRLD xmm1, xmm2/m128]
opcode       = 66 0F D2 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRLD
description  = "Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s."

[PSRLD mm, imm8]
opcode       = 0F 72 /2 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRLD
description  = "Shift doublewords in mm right by imm8 while shifting in 0s."

[PSRLD xmm1, imm8]
opcode       = 66 0F 72 /2 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRLD
description  = "Shift doublewords in xmm1 right by imm8 while shifting in 0s."

[PSRLQ mm, mm/m64]
opcode       = 0F D3 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRLQ
description  = "Shift mm right by amount specified in mm/m64 while shifting in 0s."

[PSRLQ xmm1, xmm2/m128]
opcode       = 66 0F D3 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRLQ
description  = "Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."

[PSRLQ mm, imm8]
opcode       = 0F 73 /2 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSRLQ
description  = "Shift mm right by imm8 while shifting in 0s."

[PSRLQ xmm1, imm8]
opcode       = 66 0F 73 /2 ib
operand      = MI
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSRLQ
description  = "Shift quadwords in xmm1 right by imm8 while shifting in 0s."

[VPSRLW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D1 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRLW
description  = "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."

[VPSRLW xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 71 /2 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRLW
description  = "Shift words in xmm2 right by imm8 while shifting in 0s."

[VPSRLD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D2 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRLD
description  = "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."

[VPSRLD xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 72 /2 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRLD
description  = "Shift doublewords in xmm2 right by imm8 while shifting in 0s."

[VPSRLQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D3 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRLQ
description  = "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."

[VPSRLQ xmm1, xmm2, imm8]
opcode       = VEX.NDD.128.66.0F.WIG 73 /2 ib
operand      = VMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSRLQ
description  = "Shift quadwords in xmm2 right by imm8 while shifting in 0s."

[VPSRLW ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG D1 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLW
description  = "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."

[VPSRLW ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 71 /2 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLW
description  = "Shift words in ymm2 right by imm8 while shifting in 0s."

[VPSRLD ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG D2 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLD
description  = "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."

[VPSRLD ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 72 /2 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLD
description  = "Shift doublewords in ymm2 right by imm8 while shifting in 0s."

[VPSRLQ ymm1, ymm2, xmm3/m128]
opcode       = VEX.NDS.256.66.0F.WIG D3 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLQ
description  = "Shift quadwords in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."

[VPSRLQ ymm1, ymm2, imm8]
opcode       = VEX.NDD.256.66.0F.WIG 73 /2 ib
operand      = VMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLQ
description  = "Shift quadwords in ymm2 right by imm8 while shifting in 0s."

[PSUBB mm, mm/m64]
opcode       = 0F F8 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSUBB
description  = "Subtract packed byte integers in mm/m64 from packed byte integers in mm."

[PSUBB xmm1, xmm2/m128]
opcode       = 66 0F F8 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBB
description  = "Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1."

[PSUBW mm, mm/m64]
opcode       = 0F F9 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSUBW
description  = "Subtract packed word integers in mm/m64 from packed word integers in mm."

[PSUBW xmm1, xmm2/m128]
opcode       = 66 0F F9 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBW
description  = "Subtract packed word integers in xmm2/m128 from packed word integers in xmm1."

[PSUBD mm, mm/m64]
opcode       = 0F FA /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSUBD
description  = "Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm."

[PSUBD xmm1, xmm2/m128]
opcode       = 66 0F FA /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBD
description  = "Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1."

[VPSUBB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F8 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBB
description  = "Subtract packed byte integers in xmm3/m128 from xmm2."

[VPSUBW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG F9 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBW
description  = "Subtract packed word integers in xmm3/m128 from xmm2."

[VPSUBD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG FA /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBD
description  = "Subtract packed doubleword integers in xmm3/m128 from xmm2."

[VPSUBB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG F8 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBB
description  = "Subtract packed byte integers in ymm3/m256 from ymm2."

[VPSUBW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG F9 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBW
description  = "Subtract packed word integers in ymm3/m256 from ymm2."

[VPSUBD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG FA /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBD
description  = "Subtract packed doubleword integers in ymm3/m256 from ymm2."

[PSUBQ mm1, mm2/m64]
opcode       = 0F FB /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBQ
description  = "Subtract quadword integer in mm1 from mm2 /m64."

[PSUBQ xmm1, xmm2/m128]
opcode       = 66 0F FB /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBQ
description  = "Subtract packed quadword integers in xmm1 from xmm2 /m128."

[VPSUBQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG FB /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBQ
description  = "Subtract packed quadword integers in xmm3/m128 from xmm2."

[VPSUBQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG FB /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBQ
description  = "Subtract packed quadword integers in ymm3/m256 from ymm2."

[PSUBSB mm, mm/m64]
opcode       = 0F E8 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSUBSB
description  = "Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results."

[PSUBSB xmm1, xmm2/m128]
opcode       = 66 0F E8 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBSB
description  = "Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results."

[PSUBSW mm, mm/m64]
opcode       = 0F E9 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSUBSW
description  = "Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results."

[PSUBSW xmm1, xmm2/m128]
opcode       = 66 0F E9 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBSW
description  = "Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results."

[VPSUBSB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E8 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBSB
description  = "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results."

[VPSUBSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG E9 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBSW
description  = "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results."

[VPSUBSB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG E8 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBSB
description  = "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results."

[VPSUBSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG E9 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBSW
description  = "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results."

[PSUBUSB mm, mm/m64]
opcode       = 0F D8 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSUBUSB
description  = "Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result."

[PSUBUSB xmm1, xmm2/m128]
opcode       = 66 0F D8 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBUSB
description  = "Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result."

[PSUBUSW mm, mm/m64]
opcode       = 0F D9 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PSUBUSW
description  = "Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result."

[PSUBUSW xmm1, xmm2/m128]
opcode       = 66 0F D9 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PSUBUSW
description  = "Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result."

[VPSUBUSB xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D8 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBUSB
description  = "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result."

[VPSUBUSW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG D9 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPSUBUSW
description  = "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result."

[VPSUBUSB ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG D8 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBUSB
description  = "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result."

[VPSUBUSW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG D9 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSUBUSW
description  = "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result."

[PTEST xmm1, xmm2/m128]
opcode       = 66 0F 38 17 /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = PTEST
description  = "Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s."

[VPTEST xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.WIG 17 /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPTEST
description  = "Set ZF and CF depending on bitwise AND and ANDN of sources."

[VPTEST ymm1, ymm2/m256]
opcode       = VEX.256.66.0F38.WIG 17 /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPTEST
description  = "Set ZF and CF depending on bitwise AND and ANDN of sources."

[PUNPCKHBW mm, mm/m64]
opcode       = 0F 68 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PUNPCKHBW
description  = "Unpack and interleave high-order bytes from mm and mm/m64 into mm."

[PUNPCKHBW xmm1, xmm2/m128]
opcode       = 66 0F 68 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKHBW
description  = "Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1."

[PUNPCKHWD mm, mm/m64]
opcode       = 0F 69 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PUNPCKHWD
description  = "Unpack and interleave high-order words from mm and mm/m64 into mm."

[PUNPCKHWD xmm1, xmm2/m128]
opcode       = 66 0F 69 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKHWD
description  = "Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1."

[PUNPCKHDQ mm, mm/m64]
opcode       = 0F 6A /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PUNPCKHDQ
description  = "Unpack and interleave high-order doublewords from mm and mm/m64 into mm."

[PUNPCKHDQ xmm1, xmm2/m128]
opcode       = 66 0F 6A /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKHDQ
description  = "Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1."

[PUNPCKHQDQ xmm1, xmm2/m128]
opcode       = 66 0F 6D /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKHQDQ
description  = "Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1."

[VPUNPCKHBW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 68 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKHBW
description  = "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1."

[VPUNPCKHWD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 69 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKHWD
description  = "Interleave high-order words from xmm2 and xmm3/m128 into xmm1."

[VPUNPCKHDQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 6A /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKHDQ
description  = "Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1."

[VPUNPCKHQDQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 6D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKHQDQ
description  = "Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register."

[VPUNPCKHBW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 68 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKHBW
description  = "Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register."

[VPUNPCKHWD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 69 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKHWD
description  = "Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register."

[VPUNPCKHDQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 6A /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKHDQ
description  = "Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register."

[VPUNPCKHQDQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 6D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKHQDQ
description  = "Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register."

[PUNPCKLBW mm, mm/m32]
opcode       = 0F 60 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PUNPCKLBW
description  = "Interleave low-order bytes from mm and mm/m32 into mm."

[PUNPCKLBW xmm1, xmm2/m128]
opcode       = 66 0F 60 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKLBW
description  = "Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1."

[PUNPCKLWD mm, mm/m32]
opcode       = 0F 61 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PUNPCKLWD
description  = "Interleave low-order words from mm and mm/m32 into mm."

[PUNPCKLWD xmm1, xmm2/m128]
opcode       = 66 0F 61 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKLWD
description  = "Interleave low-order words from xmm1 and xmm2/m128 into xmm1."

[PUNPCKLDQ mm, mm/m32]
opcode       = 0F 62 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PUNPCKLDQ
description  = "Interleave low-order doublewords from mm and mm/m32 into mm."

[PUNPCKLDQ xmm1, xmm2/m128]
opcode       = 66 0F 62 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKLDQ
description  = "Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1."

[PUNPCKLQDQ xmm1, xmm2/m128]
opcode       = 66 0F 6C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PUNPCKLQDQ
description  = "Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register."

[VPUNPCKLBW xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 60 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKLBW
description  = "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1."

[VPUNPCKLWD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 61 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKLWD
description  = "Interleave low-order words from xmm2 and xmm3/m128 into xmm1."

[VPUNPCKLDQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 62 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKLDQ
description  = "Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1."

[VPUNPCKLQDQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 6C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPUNPCKLQDQ
description  = "Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register."

[VPUNPCKLBW ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 60 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKLBW
description  = "Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register."

[VPUNPCKLWD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 61 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKLWD
description  = "Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register."

[VPUNPCKLDQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 62 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKLDQ
description  = "Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register."

[VPUNPCKLQDQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 6C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPUNPCKLQDQ
description  = "Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register."

[PUSH r/m16]
opcode       = FF /6
operand      = M
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHW
description  = "Push r/m16."

[PUSH r/m32]
opcode       = FF /6
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Push r/m32."

[PUSH r/m64]
opcode       = FF /6
operand      = M
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = PUSHQ
description  = "Push r/m64."

[PUSH r16]
opcode       = 50 +rw
operand      = O
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = PUSHW
description  = "Push r16."

[PUSH r32]
opcode       = 50 +rd
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Push r32."

[PUSH r64]
opcode       = 50 +rd
operand      = O
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = PUSHQ
description  = "Push r64."

[PUSHQ imm8]
opcode       = 6A
operand      = I
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHQ
description  = "Push imm8 (sign-extended to 64-bits)."

[PUSHW imm8]
opcode       = 66 6A
operand      = I
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHW
description  = "Push imm8 (sign-extended to 16-bits)."

[PUSHQ imm16]
opcode       = 68
operand      = I
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHQ
description  = "Push imm16 (sign-extended to 64-bits)."

[PUSHW imm16]
opcode       = 66 68
operand      = I
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHW
description  = "Push imm16 (sign-extended to 16-bits)."

[PUSHQ imm32]
opcode       = 68
operand      = I
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHQ
description  = "Push imm32 (sign-extended to 64-bits)."

[PUSH CS]
opcode       = 0E
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Push CS."

[PUSH SS]
opcode       = 16
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Push SS."

[PUSH DS]
opcode       = 1E
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Push DS."

[PUSH ES]
opcode       = 06
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Push ES."

[PUSH FS]
opcode       = 0F A0
operand      = NP
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHQ
description  = "Push FS."

[PUSH GS]
opcode       = 0F A8
operand      = NP
props        = R
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHQ
description  = "Push GS."

[PUSHA]
opcode       = 60
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Push AX, CX, DX, BX, original SP, BP, SI, and DI."

[PUSHAD]
opcode       = 60
iread        = RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI."

[PUSHF]
opcode       = 66 9C
operand      = NP
iread        = E.* RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = PUSHFW
description  = "Push lower 16 bits of EFLAGS."

[PUSHFD]
opcode       = 9C
useful       = 0
protected    = 0
x64_mode     = NE
x32_compat   = V
preferred    = 0
description  = "Push EFLAGS."

[PUSHFQ]
opcode       = 9C
operand      = NP
iread        = E.* RSP
iwrite       = RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = PUSHFQ
description  = "Push RFLAGS."

[PXOR mm, mm/m64]
opcode       = 0F EF /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MMX
preferred    = 0
att_mnemonic = PXOR
description  = "Bitwise XOR of mm/m64 and mm."

[PXOR xmm1, xmm2/m128]
opcode       = 66 0F EF /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = PXOR
description  = "Bitwise XOR of xmm2/m128 and xmm1."

[VPXOR xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG EF /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPXOR
description  = "Bitwise XOR of xmm3/m128 and xmm2."

[VPXOR ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG EF /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPXOR
description  = "Bitwise XOR of ymm3/m256 and ymm2."

[RCL r/m8, 1]
opcode       = D0 /2
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLB
description  = "Rotate 9 bits (CF, r/m8) left once."

[RCL r/m8, 1]
opcode       = REX+ D0 /2
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCLB
description  = "Rotate 9 bits (CF, r/m8) left once."

[RCL r/m8, CL]
opcode       = D2 /2
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLB
description  = "Rotate 9 bits (CF, r/m8) left CL times."

[RCL r/m8, CL]
opcode       = REX+ D2 /2
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCLB
description  = "Rotate 9 bits (CF, r/m8) left CL times."

[RCL r/m8, imm8]
opcode       = C0 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLB
description  = "Rotate 9 bits (CF, r/m8) left imm8 times."

[RCL r/m8, imm8]
opcode       = REX+ C0 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCLB
description  = "Rotate 9 bits (CF, r/m8) left imm8 times."

[RCL r/m16, 1]
opcode       = D1 /2
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLW
description  = "Rotate 17 bits (CF, r/m16) left once."

[RCL r/m16, CL]
opcode       = D3 /2
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLW
description  = "Rotate 17 bits (CF, r/m16) left CL times."

[RCL r/m16, imm8]
opcode       = C1 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLW
description  = "Rotate 17 bits (CF, r/m16) left imm8 times."

[RCL r/m32, 1]
opcode       = D1 /2
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLL
description  = "Rotate 33 bits (CF, r/m32) left once."

[RCL r/m64, 1]
opcode       = REX.W+ D1 /2
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCLQ
description  = "Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count."

[RCL r/m32, CL]
opcode       = D3 /2
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLL
description  = "Rotate 33 bits (CF, r/m32) left CL times."

[RCL r/m64, CL]
opcode       = REX.W+ D3 /2
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCLQ
description  = "Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count."

[RCL r/m32, imm8]
opcode       = C1 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCLL
description  = "Rotate 33 bits (CF, r/m32) left imm8 times."

[RCL r/m64, imm8]
opcode       = REX.W+ C1 /2 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCLQ
description  = "Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count."

[RCR r/m8, 1]
opcode       = D0 /3
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRB
description  = "Rotate 9 bits (CF, r/m8) right once."

[RCR r/m8, 1]
opcode       = REX+ D0 /3
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCRB
description  = "Rotate 9 bits (CF, r/m8) right once."

[RCR r/m8, CL]
opcode       = D2 /3
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRB
description  = "Rotate 9 bits (CF, r/m8) right CL times."

[RCR r/m8, CL]
opcode       = REX+ D2 /3
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCRB
description  = "Rotate 9 bits (CF, r/m8) right CL times."

[RCR r/m8, imm8]
opcode       = C0 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRB
description  = "Rotate 9 bits (CF, r/m8) right imm8 times."

[RCR r/m8, imm8]
opcode       = REX+ C0 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCRB
description  = "Rotate 9 bits (CF, r/m8) right imm8 times."

[RCR r/m16, 1]
opcode       = D1 /3
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRW
description  = "Rotate 17 bits (CF, r/m16) right once."

[RCR r/m16, CL]
opcode       = D3 /3
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRW
description  = "Rotate 17 bits (CF, r/m16) right CL times."

[RCR r/m16, imm8]
opcode       = C1 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRW
description  = "Rotate 17 bits (CF, r/m16) right imm8 times."

[RCR r/m32, 1]
opcode       = D1 /3
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRL
description  = "Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count."

[RCR r/m64, 1]
opcode       = REX.W+ D1 /3
operand      = M1
props        = RW, R
iread        = E.CF
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCRQ
description  = "Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count."

[RCR r/m32, CL]
opcode       = D3 /3
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRL
description  = "Rotate 33 bits (CF, r/m32) right CL times."

[RCR r/m64, CL]
opcode       = REX.W+ D3 /3
operand      = MC
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCRQ
description  = "Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count."

[RCR r/m32, imm8]
opcode       = C1 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RCRL
description  = "Rotate 33 bits (CF, r/m32) right imm8 times."

[RCR r/m64, imm8]
opcode       = REX.W+ C1 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RCRQ
description  = "Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count."

[ROL r/m8, 1]
opcode       = D0 /0
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLB
description  = "Rotate 8 bits r/m8 left once."

[ROL r/m8, 1]
opcode       = REX+ D0 /0
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ROLB
description  = "Rotate 8 bits r/m8 left once."

[ROL r/m8, CL]
opcode       = D2 /0
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLB
description  = "Rotate 8 bits r/m8 left CL times."

[ROL r/m8, CL]
opcode       = REX+ D2 /0
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ROLB
description  = "Rotate 8 bits r/m8 left CL times."

[ROL r/m8, imm8]
opcode       = C0 /0 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLB
description  = "Rotate 8 bits r/m8 left imm8 times."

[ROL r/m8, imm8]
opcode       = REX+ C0 /0 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ROLB
description  = "Rotate 8 bits r/m8 left imm8 times."

[ROL r/m16, 1]
opcode       = D1 /0
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLW
description  = "Rotate 16 bits r/m16 left once."

[ROL r/m16, CL]
opcode       = D3 /0
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLW
description  = "Rotate 16 bits r/m16 left CL times."

[ROL r/m16, imm8]
opcode       = C1 /0 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLW
description  = "Rotate 16 bits r/m16 left imm8 times."

[ROL r/m32, 1]
opcode       = D1 /0
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLL
description  = "Rotate 32 bits r/m32 left once."

[ROL r/m64, 1]
opcode       = REX.W+ D1 /0
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ROLQ
description  = "Rotate 64 bits r/m64 left once. Uses a 6 bit count."

[ROL r/m32, CL]
opcode       = D3 /0
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLL
description  = "Rotate 32 bits r/m32 left CL times."

[ROL r/m64, CL]
opcode       = REX.W+ D3 /0
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ROLQ
description  = "Rotate 64 bits r/m64 left CL times. Uses a 6 bit count."

[ROL r/m32, imm8]
opcode       = C1 /0 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = ROLL
description  = "Rotate 32 bits r/m32 left imm8 times."

[ROL r/m64, imm8]
opcode       = REX.W+ C1 /0 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = ROLQ
description  = "Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count."

[ROR r/m8, 1]
opcode       = D0 /1
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORB
description  = "Rotate 8 bits r/m8 right once."

[ROR r/m8, 1]
opcode       = REX+ D0 /1
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RORB
description  = "Rotate 8 bits r/m8 right once."

[ROR r/m8, CL]
opcode       = D2 /1
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORB
description  = "Rotate 8 bits r/m8 right CL times."

[ROR r/m8, CL]
opcode       = REX+ D2 /1
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RORB
description  = "Rotate 8 bits r/m8 right CL times."

[ROR r/m8, imm8]
opcode       = C0 /1 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORB
description  = "Rotate 8 bits r/m16 right imm8 times."

[ROR r/m8, imm8]
opcode       = REX+ C0 /1 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RORB
description  = "Rotate 8 bits r/m16 right imm8 times."

[ROR r/m16, 1]
opcode       = D1 /1
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORW
description  = "Rotate 16 bits r/m16 right once."

[ROR r/m16, CL]
opcode       = D3 /1
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORW
description  = "Rotate 16 bits r/m16 right CL times."

[ROR r/m16, imm8]
opcode       = C1 /1 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORW
description  = "Rotate 16 bits r/m16 right imm8 times."

[ROR r/m32, 1]
opcode       = D1 /1
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORL
description  = "Rotate 32 bits r/m32 right once."

[ROR r/m64, 1]
opcode       = REX.W+ D1 /1
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RORQ
description  = "Rotate 64 bits r/m64 right once. Uses a 6 bit count."

[ROR r/m32, CL]
opcode       = D3 /1
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORL
description  = "Rotate 32 bits r/m32 right CL times."

[ROR r/m64, CL]
opcode       = REX.W+ D3 /1
operand      = MC
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RORQ
description  = "Rotate 64 bits r/m64 right CL times. Uses a 6 bit count."

[ROR r/m32, imm8]
opcode       = C1 /1 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RORL
description  = "Rotate 32 bits r/m32 right imm8 times."

[ROR r/m64, imm8]
opcode       = REX.W+ C1 /1 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of
iundef       = e.of
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = RORQ
description  = "Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count."

[RCPPS xmm1, xmm2/m128]
opcode       = 0F 53 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = RCPPS
description  = "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."

[VRCPPS xmm1, xmm2/m128]
opcode       = VEX.128.0F.WIG 53 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VRCPPS
description  = "Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1."

[VRCPPS ymm1, ymm2/m256]
opcode       = VEX.256.0F.WIG 53 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VRCPPS
description  = "Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1."

[RCPSS xmm1, xmm2/m32]
opcode       = F3 0F 53 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = RCPSS
description  = "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1."

[VRCPSS xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 53 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VRCPSS
description  = "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the result in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."

[RDFSBASE r32]
opcode       = F3 0F AE /0
operand      = M
props        = W
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = RDFSBASE
description  = "Load the 32-bit destination register with the FS base address."

[RDFSBASE r64]
opcode       = REX.W+ F3 0F AE /0
operand      = M
props        = W
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = RDFSBASE
description  = "Load the 64-bit destination register with the FS base address."

[RDGSBASE r32]
opcode       = F3 0F AE /1
operand      = M
props        = W
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = RDGSBASE
description  = "Load the 32-bit destination register with the GS base address."

[RDGSBASE r64]
opcode       = REX.W+ F3 0F AE /1
operand      = M
props        = W
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = RDGSBASE
description  = "Load the 64-bit destination register with the GS base address."

[RDMSR]
opcode       = 0F 32
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
cpuid_flags  = MSR
preferred    = 0
description  = "Read MSR specified by ECX into EDX:EAX."

[RDPMC]
opcode       = 0F 33
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = MSR
preferred    = 0
description  = "Read performance-monitoring counter specified by ECX into EDX:EAX."

[RDRAND r16]
opcode       = 0F C7 /6
operand      = M
props        = W
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = RDRAND
preferred    = 0
att_mnemonic = RDRAND
description  = "Read a 16-bit random number and store in the destination register."

[RDRAND r32]
opcode       = 0F C7 /6
operand      = M
props        = W
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = RDRAND
preferred    = 0
att_mnemonic = RDRAND
description  = "Read a 32-bit random number and store in the destination register."

[RDRAND r64]
opcode       = REX.W+ 0F C7 /6
operand      = M
props        = W
iwrite       = E.CF E.OF E.SF E.ZF E.AF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = RDRAND
preferred    = 0
att_mnemonic = RDRAND
description  = "Read a 64-bit random number and store in the destination register."

[RDTSC]
opcode       = 0F 31
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = TSC
preferred    = 0
description  = "Read time-stamp counter into EDX:EAX."

[RDTSCP]
opcode       = 0F 01 F9
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = RDTSCP
preferred    = 0
description  = "Read 64-bit time-stamp counter and 32-bit IA32_TSC_AUX value into EDX:EAX and ECX."

[REP_INS m8, DX]
opcode       = F3 6C
operand      = NP
props        = I, R
iread        = ECX E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP INSB
description  = "Input (E)CX bytes from port DX into ES:[(E)DI]."

[REP_INS m8, DX]
opcode       = F3 REX.W+ 6C
operand      = NP
props        = I, R
iread        = RCX E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP INSB
description  = "Input RCX bytes from port DX into [RDI]."

[REP_INS m16, DX]
opcode       = F3 6D
operand      = NP
props        = I, R
iread        = ECX E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP INSW
description  = "Input (E)CX words from port DX into ES:[(E)DI.]"

[REP_INS m32, DX]
opcode       = F3 6D
operand      = NP
props        = I, R
iread        = ECX E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP INSL
description  = "Input (E)CX doublewords from port DX into ES:[(E)DI]."

[REP_INS m64, DX]
opcode       = F3 REX.W+ 6D
operand      = NP
props        = I, R
iread        = RCX E.IOPL E.VM E.DF RDI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP INSQ
description  = "Input RCX default size from port DX into [RDI]."

[REP_MOVS m8, m8]
opcode       = F3 A4
operand      = NP
props        = I, I
iread        = ECX E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP MOVSB
description  = "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."

[REP_MOVS m8, m8]
opcode       = F3 REX.W+ A4
operand      = NP
props        = I, I
iread        = RCX E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP MOVSB
description  = "Move RCX bytes from [RSI] to [RDI]."

[REP_MOVS m16, m16]
opcode       = F3 A5
operand      = NP
props        = I, I
iread        = ECX E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP MOVSW
description  = "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."

[REP_MOVS m32, m32]
opcode       = F3 A5
operand      = NP
props        = I, I
iread        = ECX E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP MOVSL
description  = "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."

[REP_MOVS m64, m64]
opcode       = F3 REX.W+ A5
operand      = NP
props        = I, I
iread        = RCX E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP MOVSQ
description  = "Move RCX quadwords from [RSI] to [RDI]."

[REP_OUTS DX, m8]
opcode       = F3 6E
operand      = NP
props        = R, I
iread        = ECX E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP OUTSB
description  = "Output (E)CX bytes from DS:[(E)SI] to port DX."

[REP_OUTS DX, m8]
opcode       = F3 REX.W+ 6E
operand      = NP
props        = R, I
iread        = RCX E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP OUTSB
description  = "Output RCX bytes from [RSI] to port DX."

[REP_OUTS DX, m16]
opcode       = F3 6F
operand      = NP
props        = R, I
iread        = ECX E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP OUTSW
description  = "Output (E)CX words from DS:[(E)SI] to port DX."

[REP_OUTS DX, m32]
opcode       = F3 6F
operand      = NP
props        = R, I
iread        = ECX E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP OUTSL
description  = "Output (E)CX doublewords from DS:[(E)SI] to port DX."

[REP_OUTS DX, m64]
opcode       = F3 REX.W+ 6F
operand      = NP
props        = R, I
iread        = RCX E.IOPL E.VM E.DF RSI
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP OUTSQ
description  = "Output RCX default size from [RSI] to port DX."

[REP_LODS AL]
opcode       = F3 AC
operand      = NP
props        = W
iread        = ECX E.DF SI rsi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP LODSB
description  = "Load (E)CX bytes from DS:[(E)SI] to AL."

[REP_LODS AL]
opcode       = F3 REX.W+ AC
operand      = NP
props        = W
iread        = RCX E.DF SI rsi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP LODSB
description  = "Load RCX bytes from [RSI] to AL."

[REP_LODS AX]
opcode       = F3 AD
operand      = NP
props        = W
iread        = ECX E.DF SI rsi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP LODSW
description  = "Load (E)CX words from DS:[(E)SI] to AX."

[REP_LODS EAX]
opcode       = F3 AD
operand      = NP
props        = W
iread        = ECX E.DF SI rsi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP LODSL
description  = "Load (E)CX doublewords from DS:[(E)SI] to EAX."

[REP_LODS RAX]
opcode       = F3 REX.W+ AD
operand      = NP
props        = W
iread        = RCX E.DF SI rsi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP LODSQ
description  = "Load RCX quadwords from [RSI] to RAX."

[REP_STOS m8]
opcode       = F3 AA
operand      = NP
props        = I
iread        = ECX E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP STOSB
description  = "Fill (E)CX bytes at ES:[(E)DI] with AL."

[REP_STOS m8]
opcode       = F3 REX.W+ AA
operand      = NP
props        = I
iread        = RCX E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP STOSB
description  = "Fill RCX bytes at [RDI] with AL."

[REP_STOS m16]
opcode       = F3 AB
operand      = NP
props        = I
iread        = ECX E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP STOSW
description  = "Fill (E)CX words at ES:[(E)DI] with AX."

[REP_STOS m32]
opcode       = F3 AB
operand      = NP
props        = I
iread        = ECX E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REP STOSL
description  = "Fill (E)CX doublewords at ES:[(E)DI] with EAX."

[REP_STOS m64]
opcode       = F3 REX.W+ AB
operand      = NP
props        = I
iread        = RCX E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REP STOSQ
description  = "Fill RCX quadwords at [RDI] with RAX."

[REPE_CMPS m8, m8]
opcode       = F3 A6
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPZ CMPSB
description  = "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."

[REPE_CMPS m8, m8]
opcode       = F3 REX.W+ A6
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPZ CMPSB
description  = "Find non-matching bytes in [RDI] and [RSI]."

[REPE_CMPS m16, m16]
opcode       = F3 A7
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPZ CMPSW
description  = "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."

[REPE_CMPS m32, m32]
opcode       = F3 A7
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPZ CMPSL
description  = "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."

[REPE_CMPS m64, m64]
opcode       = F3 REX.W+ A7
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPZ CMPSQ
description  = "Find non-matching quadwords in [RDI] and [RSI]."

[REPE_SCAS m8]
opcode       = F3 AE
operand      = NP
props        = I
iread        = E.ZF E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPZ SCASB
description  = "Find non-AL byte starting at ES:[(E)DI]."

[REPE_SCAS m8]
opcode       = F3 REX.W+ AE
operand      = NP
props        = I
iread        = E.ZF E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPZ SCASB
description  = "Find non-AL byte starting at [RDI]."

[REPE_SCAS m16]
opcode       = F3 AF
operand      = NP
props        = I
iread        = E.ZF E.DF RDI AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPZ SCASW
description  = "Find non-AX word starting at ES:[(E)DI]."

[REPE_SCAS m32]
opcode       = F3 AF
operand      = NP
props        = I
iread        = E.ZF E.DF RDI EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPZ SCASL
description  = "Find non-EAX doubleword starting at ES:[(E)DI]."

[REPE_SCAS m64]
opcode       = F3 REX.W+ AF
operand      = NP
props        = I
iread        = E.ZF E.DF RDI RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPZ SCASQ
description  = "Find non-RAX quadword starting at [RDI]."

[REPNE_CMPS m8, m8]
opcode       = F2 A6
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPNZ CMPSB
description  = "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."

[REPNE_CMPS m8, m8]
opcode       = F2 REX.W+ A6
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPNZ CMPSB
description  = "Find matching bytes in [RDI] and [RSI]."

[REPNE_CMPS m16, m16]
opcode       = F2 A7
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPNZ CMPSW
description  = "Find matching words in ES:[(E)DI] and DS:[(E)SI]."

[REPNE_CMPS m32, m32]
opcode       = F2 A7
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPNZ CMPSL
description  = "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."

[REPNE_CMPS m64, m64]
opcode       = F2 REX.W+ A7
operand      = NP
props        = I, I
iread        = E.ZF E.DF ESI rsi EDI rdi
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPNZ CMPSQ
description  = "Find matching doublewords in [RDI] and [RSI]."

[REPNE_SCAS m8]
opcode       = F2 AE
operand      = NP
props        = I
iread        = E.ZF E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPNZ SCASB
description  = "Find AL, starting at ES:[(E)DI]."

[REPNE_SCAS m8]
opcode       = F2 REX.W+ AE
operand      = NP
props        = I
iread        = E.ZF E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPNZ SCASB
description  = "Find AL, starting at [RDI]."

[REPNE_SCAS m16]
opcode       = F2 AF
operand      = NP
props        = I
iread        = E.ZF E.DF RDI AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPNZ SCASW
description  = "Find AX, starting at ES:[(E)DI]."

[REPNE_SCAS m32]
opcode       = F2 AF
operand      = NP
props        = I
iread        = E.ZF E.DF RDI EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = REP_GOOD
preferred    = 1
att_mnemonic = REPNZ SCASL
description  = "Find EAX, starting at ES:[(E)DI]."

[REPNE_SCAS m64]
opcode       = F2 REX.W+ AF
operand      = NP
props        = I
iread        = E.ZF E.DF RDI RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = REP_GOOD
preferred    = 0
att_mnemonic = REPNZ SCASQ
description  = "Find RAX, starting at [RDI]."

[RET]
opcode       = C3
operand      = NP
iwrite       = RIP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RETQ
description  = "Near return to calling procedure."

[RET far]
opcode       = CB
operand      = NP
props        = I
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = LRETL
description  = "Far return to calling procedure."

[RET imm16]
opcode       = C2 iw
operand      = I
props        = R
iwrite       = RIP RSP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RETQ
description  = "Near return to calling procedure and pop imm16 bytes from stack."

[RET imm16, far]
opcode       = CA iw
operand      = I
props        = R, I
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = RETQ
description  = "Far return to calling procedure and pop imm16 bytes from stack."

[RORX r32, r/m32, imm8]
opcode       = VEX.LZ.F2.0F3A.W0 F0 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = RORXL
description  = "Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags."

[RORX r64, r/m64, imm8]
opcode       = VEX.LZ.F2.0F3A.W1 F0 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = RORXQ
description  = "Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags."

[ROUNDPD xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 09 /r ib
operand      = RMI
props        = W, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = ROUNDPD
description  = "Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."

[VROUNDPD xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.WIG 09 /r ib
operand      = RMI
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VROUNDPD
description  = "Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."

[VROUNDPD ymm1, ymm2/m256, imm8]
opcode       = VEX.256.66.0F3A.WIG 09 /r ib
operand      = RMI
props        = W, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VROUNDPD
description  = "Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8."

[ROUNDPS xmm1, xmm2/m128, imm8]
opcode       = 66 0F 3A 08 /r ib
operand      = RMI
props        = W, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = ROUNDPS
description  = "Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."

[VROUNDPS xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.WIG 08 /r ib
operand      = RMI
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VROUNDPS
description  = "Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8."

[VROUNDPS ymm1, ymm2/m256, imm8]
opcode       = VEX.256.66.0F3A.WIG 08 /r ib
operand      = RMI
props        = W, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VROUNDPS
description  = "Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8."

[ROUNDSD xmm1, xmm2/m64, imm8]
opcode       = 66 0F 3A 0B /r ib
operand      = RMI
props        = RW, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = ROUNDSD
description  = "Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8."

[VROUNDSD xmm1, xmm2, xmm3/m64, imm8]
opcode       = VEX.NDS.LIG.66.0F3A.WIG 0B /r ib
operand      = RVMI
props        = Z, R, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VROUNDSD
description  = "Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by imm8. Upper packed double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."

[ROUNDSS xmm1, xmm2/m32, imm8]
opcode       = 66 0F 3A 0A /r ib
operand      = RMI
props        = RW, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE4_1
preferred    = 0
att_mnemonic = ROUNDSS
description  = "Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8."

[VROUNDSS xmm1, xmm2, xmm3/m32, imm8]
opcode       = VEX.NDS.LIG.66.0F3A.WIG 0A ib
operand      = RVMI
props        = Z, R, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VROUNDSS
description  = "Round the low packed single precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by imm8. Also, upper packed single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."

[RSM]
opcode       = 0F AA
useful       = 0
protected    = 1
x64_mode     = I
x32_compat   = V
preferred    = 0
description  = "Resume operation of interrupted program."

[RSQRTPS xmm1, xmm2/m128]
opcode       = 0F 52 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = RSQRTPS
description  = "Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."

[VRSQRTPS xmm1, xmm2/m128]
opcode       = VEX.128.0F.WIG 52 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VRSQRTPS
description  = "Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1."

[VRSQRTPS ymm1, ymm2/m256]
opcode       = VEX.256.0F.WIG 52 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VRSQRTPS
description  = "Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1."

[RSQRTSS xmm1, xmm2/m32]
opcode       = F3 0F 52 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = RSQRTSS
description  = "Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."

[VRSQRTSS xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 52 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VRSQRTSS
description  = "Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."

[SAHF]
opcode       = 9E
operand      = NP
iread        = AH
iwrite       = E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = LAHF_LM
preferred    = 0
att_mnemonic = SAHF
description  = "Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register."

[SAL r/m8, 1]
opcode       = D0 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALB
description  = "Multiply r/m8 by 2, once."

[SAL r/m8, 1]
opcode       = REX+ D0 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SALB
description  = "Multiply r/m8 by 2, once."

[SAL r/m8, CL]
opcode       = D2 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALB
description  = "Multiply r/m8 by 2, CL times."

[SAL r/m8, CL]
opcode       = REX+ D2 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SALB
description  = "Multiply r/m8 by 2, CL times."

[SAL r/m8, imm8]
opcode       = C0 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALB
description  = "Multiply r/m8 by 2, imm8 times."

[SAL r/m8, imm8]
opcode       = REX+ C0 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SALB
description  = "Multiply r/m8 by 2, imm8 times."

[SAL r/m16, 1]
opcode       = D1 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALW
description  = "Multiply r/m16 by 2, once."

[SAL r/m16, CL]
opcode       = D3 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALW
description  = "Multiply r/m16 by 2, CL times."

[SAL r/m16, imm8]
opcode       = C1 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALW
description  = "Multiply r/m16 by 2, imm8 times."

[SAL r/m32, 1]
opcode       = D1 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALL
description  = "Multiply r/m32 by 2, once."

[SAL r/m64, 1]
opcode       = REX.W+ D1 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SALQ
description  = "Multiply r/m64 by 2, once."

[SAL r/m32, CL]
opcode       = D3 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALL
description  = "Multiply r/m32 by 2, CL times."

[SAL r/m64, CL]
opcode       = REX.W+ D3 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SALQ
description  = "Multiply r/m64 by 2, CL times."

[SAL r/m32, imm8]
opcode       = C1 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SALL
description  = "Multiply r/m32 by 2, imm8 times."

[SAL r/m64, imm8]
opcode       = REX.W+ C1 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af e.cf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SALQ
description  = "Multiply r/m64 by 2, imm8 times."

[SAR r/m8, 1]
opcode       = D0 /7
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARB
description  = "Signed divide r/m8 by 2, once."

[SAR r/m8, 1]
opcode       = REX+ D0 /7
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SARB
description  = "Signed divide r/m8 by 2, once."

[SAR r/m8, CL]
opcode       = D2 /7
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARB
description  = "Signed divide r/m8 by 2, CL times."

[SAR r/m8, CL]
opcode       = REX+ D2 /7
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SARB
description  = "Signed divide r/m8 by 2, CL times."

[SAR r/m8, imm8]
opcode       = C0 /7 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARB
description  = "Signed divide r/m8 by 2, imm8 time."

[SAR r/m8, imm8]
opcode       = REX+ C0 /7 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SARB
description  = "Signed divide r/m8 by 2, imm8 time."

[SAR r/m16,1]
opcode       = D1 /7
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARW
description  = "Signed divide r/m16 by 2, once."

[SAR r/m16, CL]
opcode       = D3 /7
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARW
description  = "Signed divide r/m16 by 2, CL times."

[SAR r/m16, imm8]
opcode       = C1 /7 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARW
description  = "Signed divide r/m16 by 2, imm8 times."

[SAR r/m32, 1]
opcode       = D1 /7
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARL
description  = "Signed divide r/m32 by 2, once."

[SAR r/m64, 1]
opcode       = REX.W+ D1 /7
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SARQ
description  = "Signed divide r/m32 by 2, once."

[SAR r/m32, CL]
opcode       = D3 /7
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARL
description  = "Signed divide r/m32 by 2, CL times."

[SAR r/m64, CL]
opcode       = REX.W+ D3 /7
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SARQ
description  = "Signed divide r/m32 by 2, CL times."

[SAR r/m32, imm8]
opcode       = C1 /7 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SARL
description  = "Signed divide r/m32 by 2, imm8 times."

[SAR r/m64, imm8]
opcode       = REX.W+ C1 /7 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SARQ
description  = "Signed divide r/m32 by 2, imm8 times."

[SHL r/m8, 1]
opcode       = D0 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLB
description  = "Multiply r/m8 by 2, once."

[SHL r/m8, 1]
opcode       = REX+ D0 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLB
description  = "Multiply r/m8 by 2, once."

[SHL r/m8, CL]
opcode       = D2 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLB
description  = "Multiply r/m8 by 2, CL times."

[SHL r/m8, CL]
opcode       = REX+ D2 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLB
description  = "Multiply r/m8 by 2, CL times."

[SHL r/m8, imm8]
opcode       = C0 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLB
description  = "Multiply r/m8 by 2, imm8 times."

[SHL r/m8, imm8]
opcode       = REX+ C0 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLB
description  = "Multiply r/m8 by 2, imm8 times."

[SHL r/m16,1]
opcode       = D1 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLW
description  = "Multiply r/m16 by 2, once."

[SHL r/m16, CL]
opcode       = D3 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLW
description  = "Multiply r/m16 by 2, CL times."

[SHL r/m16, imm8]
opcode       = C1 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLW
description  = "Multiply r/m16 by 2, imm8 times."

[SHL r/m32,1]
opcode       = D1 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLL
description  = "Multiply r/m32 by 2, once."

[SHL r/m64,1]
opcode       = REX.W+ D1 /4
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLQ
description  = "Multiply r/m64 by 2, once."

[SHL r/m32, CL]
opcode       = D3 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLL
description  = "Multiply r/m32 by 2, CL times."

[SHL r/m64, CL]
opcode       = REX.W+ D3 /4
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLQ
description  = "Multiply r/m32 by 2, CL times."

[SHL r/m32, imm8]
opcode       = C1 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLL
description  = "Multiply r/m32 by 2, imm8 times."

[SHL r/m64, imm8]
opcode       = REX.W+ C1 /4 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLQ
description  = "Multiply r/m32 by 2, imm8 times."

[SHR r/m8,1]
opcode       = D0 /5
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRB
description  = "Unsigned divide r/m8 by 2, once."

[SHR r/m8, 1]
opcode       = REX+ D0 /5
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRB
description  = "Unsigned divide r/m8 by 2, once."

[SHR r/m8, CL]
opcode       = D2 /5
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRB
description  = "Unsigned divide r/m8 by 2, CL times."

[SHR r/m8, CL]
opcode       = REX+ D2 /5
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRB
description  = "Unsigned divide r/m8 by 2, CL times."

[SHR r/m8, imm8]
opcode       = C0 /5 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRB
description  = "Unsigned divide r/m8 by 2, imm8 times."

[SHR r/m8, imm8]
opcode       = REX+ C0 /5 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRB
description  = "Unsigned divide r/m8 by 2, imm8 times."

[SHR r/m16, 1]
opcode       = D1 /5
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRW
description  = "Unsigned divide r/m16 by 2, once."

[SHR r/m16, CL]
opcode       = D3 /5
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRW
description  = "Unsigned divide r/m16 by 2, CL times"

[SHR r/m16, imm8]
opcode       = C1 /5 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRW
description  = "Unsigned divide r/m16 by 2, imm8 times."

[SHR r/m32, 1]
opcode       = D1 /5
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRL
description  = "Unsigned divide r/m32 by 2, once."

[SHR r/m64, 1]
opcode       = REX.W+ D1 /5
operand      = M1
props        = RW, R
iwrite       = E.CF E.OF E.PF E.SF E.ZF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRQ
description  = "Unsigned divide r/m32 by 2, once."

[SHR r/m32, CL]
opcode       = D3 /5
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRL
description  = "Unsigned divide r/m32 by 2, CL times."

[SHR r/m64, CL]
opcode       = REX.W+ D3 /5
operand      = MC
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRQ
description  = "Unsigned divide r/m32 by 2, CL times."

[SHR r/m32, imm8]
opcode       = C1 /5 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRL
description  = "Unsigned divide r/m32 by 2, imm8 times."

[SHR r/m64, imm8]
opcode       = REX.W+ C1 /5 ib
operand      = MI
props        = RW, R
iwrite       = e.cf e.of e.pf e.sf e.zf
iundef       = e.cf e.of e.af
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRQ
description  = "Unsigned divide r/m32 by 2, imm8 times."

[SARX r32a, r/m32, r32b]
opcode       = VEX.NDS.LZ.F3.0F38.W0 F7 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = SARXL
description  = "Shift r/m32 arithmetically right with count specified in r32b"

[SHLX r32a, r/m32, r32b]
opcode       = VEX.NDS.LZ.66.0F38.W0 F7 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = SHLXL
description  = "Shift r/m32 logically left with count specified in r32b"

[SHRX r32a, r/m32, r32b]
opcode       = VEX.NDS.LZ.F2.0F38.W0 F7 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = SHRXL
description  = "Shift r/m32 logically right with count specified in r32b"

[SARX r64a, r/m64, r64b]
opcode       = VEX.NDS.LZ.F3.0F38.W1 F7 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = SARXQ
description  = "Shift r/m64 arithmetically right with count specified in r64b"

[SHLX r64a, r/m64, r64b]
opcode       = VEX.NDS.LZ.66.0F38.W1 F7 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = SHLXQ
description  = "Shift r/m64 logically left with count specified in r64b."

[SHRX r64a, r/m64, r64b]
opcode       = VEX.NDS.LZ.F2.0F38.W1 F7 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI2
preferred    = 0
att_mnemonic = SHRXQ
description  = "Shift r/m64 logically right with count specified in r64b"

[SBB AL, imm8]
opcode       = 1C ib
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBB
description  = "Subtract with borrow imm8 from AL."

[SBB AX, imm16]
opcode       = 1D iw
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBW
description  = "Subtract with borrow imm16 from AX."

[SBB EAX, imm32]
opcode       = 1D id
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBL
description  = "Subtract with borrow imm32 from EAX."

[SBB RAX, imm32]
opcode       = REX.W+ 1D id
operand      = I
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SBBQ
description  = "Subtract with borrow sign-extended imm.32 to 64-bits from RAX."

[SBB r/m8, imm8]
opcode       = 80 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBB
description  = "Subtract with borrow imm8 from r/m8."

[SBB r/m8, imm8]
opcode       = REX+ 80 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SBBB
description  = "Subtract with borrow imm8 from r/m8."

[SBB r/m16, imm16]
opcode       = 81 /3 iw
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBW
description  = "Subtract with borrow imm16 from r/m16."

[SBB r/m32, imm32]
opcode       = 81 /3 id
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBL
description  = "Subtract with borrow imm32 from r/m32."

[SBB r/m64, imm32]
opcode       = REX.W+ 81 /3 id
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SBBQ
description  = "Subtract with borrow sign-extended imm32 to 64-bits from r/m64."

[SBB r/m16, imm8]
opcode       = 83 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SBBW
description  = "Subtract with borrow sign-extended imm8 from r/m16."

[SBB r/m32, imm8]
opcode       = 83 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SBBL
description  = "Subtract with borrow sign-extended imm8 from r/m32."

[SBB r/m64, imm8]
opcode       = REX.W+ 83 /3 ib
operand      = MI
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = SBBQ
description  = "Subtract with borrow sign-extended imm8 from r/m64."

[SBB r/m8, r8]
opcode       = 18 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SBBB
description  = "Subtract with borrow r8 from r/m8."

[SBB r/m8, r8]
opcode       = REX+ 18 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = SBBB
description  = "Subtract with borrow r8 from r/m8."

[SBB r/m16, r16]
opcode       = 19 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SBBW
description  = "Subtract with borrow r16 from r/m16."

[SBB r/m32, r32]
opcode       = 19 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SBBL
description  = "Subtract with borrow r32 from r/m32."

[SBB r/m64, r64]
opcode       = REX.W+ 19 /r
operand      = MR
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = SBBQ
description  = "Subtract with borrow r64 from r/m64."

[SBB r8, r/m8]
opcode       = 1A /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBB
description  = "Subtract with borrow r/m8 from r8."

[SBB r8, r/m8]
opcode       = REX+ 1A /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SBBB
description  = "Subtract with borrow r/m8 from r8."

[SBB r16, r/m16]
opcode       = 1B /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBW
description  = "Subtract with borrow r/m16 from r16."

[SBB r32, r/m32]
opcode       = 1B /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SBBL
description  = "Subtract with borrow r/m32 from r32."

[SBB r64, r/m64]
opcode       = REX.W+ 1B /r
operand      = RM
props        = RW, R
iread        = E.CF
iwrite       = E.OF E.SF E.ZF E.AF E.PF E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SBBQ
description  = "Subtract with borrow r/m64 from r64."

[SCAS m8]
opcode       = AE
operand      = NP
props        = I
iread        = E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SCAS
description  = "Compare AL with byte at ES:(E)DI or RDI, then set status flags."

[SCAS m16]
opcode       = AF
operand      = NP
props        = I
iread        = E.DF RDI AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SCAS
description  = "Compare AX with word at ES:(E)DI or RDI, then set status flags."

[SCAS m32]
opcode       = AF
operand      = NP
props        = I
iread        = E.DF RDI EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SCAS
description  = "Compare EAX with doubleword at ES(E)DI or RDI then set status flags."

[SCAS m64]
opcode       = REX.W+ AF
operand      = NP
props        = I
iread        = E.DF RDI RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SCAS
description  = "Compare RAX with quadword at RDI or EDI then set status flags."

[SCASB]
opcode       = AE
operand      = NP
iread        = E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SCASB
description  = "Compare AL with byte at ES:(E)DI or RDI then set status flags."

[SCASW]
opcode       = PREF.66+ AF
operand      = NP
iread        = E.DF RDI AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SCASW
description  = "Compare AX with word at ES:(E)DI or RDI then set status flags."

[SCASD]
opcode       = AF
operand      = NP
iread        = E.DF RDI EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SCASL
description  = "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags."

[SCASQ]
opcode       = REX.W+ AF
operand      = NP
iread        = E.DF RDI RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SCASQ
description  = "Compare RAX with quadword at RDI or EDI then set status flags."

[SETA r/m8]
opcode       = 0F 97 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETA
description  = "Set byte if above (CF=0 and ZF=0)."

[SETA r/m8]
opcode       = REX+ 0F 97 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETA
description  = "Set byte if above (CF=0 and ZF=0)."

[SETAE r/m8]
opcode       = 0F 93 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETAE
description  = "Set byte if above or equal (CF=0)."

[SETAE r/m8]
opcode       = REX+ 0F 93 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETAE
description  = "Set byte if above or equal (CF=0)."

[SETB r/m8]
opcode       = 0F 92 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETB
description  = "Set byte if below (CF=1)."

[SETB r/m8]
opcode       = REX+ 0F 92 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETB
description  = "Set byte if below (CF=1)."

[SETBE r/m8]
opcode       = 0F 96 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETBE
description  = "Set byte if below or equal (CF=1 or ZF=1)."

[SETBE r/m8]
opcode       = REX+ 0F 96 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETBE
description  = "Set byte if below or equal (CF=1 or ZF=1)."

[SETC r/m8]
opcode       = 0F 92 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETC
description  = "Set byte if carry (CF=1)."

[SETC r/m8]
opcode       = REX+ 0F 92 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETC
description  = "Set byte if carry (CF=1)."

[SETE r/m8]
opcode       = 0F 94 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETE
description  = "Set byte if equal (ZF=1)."

[SETE r/m8]
opcode       = REX+ 0F 94 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETE
description  = "Set byte if equal (ZF=1)."

[SETG r/m8]
opcode       = 0F 9F /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETG
description  = "Set byte if greater (ZF=0 and SF=OF)."

[SETG r/m8]
opcode       = REX+ 0F 9F /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETG
description  = "Set byte if greater (ZF=0 and SF=OF)."

[SETGE r/m8]
opcode       = 0F 9D /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETGE
description  = "Set byte if greater or equal (SF=OF)."

[SETGE r/m8]
opcode       = REX+ 0F 9D /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETGE
description  = "Set byte if greater or equal (SF=OF)."

[SETL r/m8]
opcode       = 0F 9C /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETL
description  = "Set byte if less (SF!= OF)."

[SETL r/m8]
opcode       = REX+ 0F 9C /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETL
description  = "Set byte if less (SF!= OF)."

[SETLE r/m8]
opcode       = 0F 9E /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETLE
description  = "Set byte if less or equal (ZF=1 or SF!= OF)."

[SETLE r/m8]
opcode       = REX+ 0F 9E /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETLE
description  = "Set byte if less or equal (ZF=1 or SF!= OF)."

[SETNA r/m8]
opcode       = 0F 96 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNA
description  = "Set byte if not above (CF=1 or ZF=1)."

[SETNA r/m8]
opcode       = REX+ 0F 96 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNA
description  = "Set byte if not above (CF=1 or ZF=1)."

[SETNAE r/m8]
opcode       = 0F 92 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNAE
description  = "Set byte if not above or equal (CF=1)."

[SETNAE r/m8]
opcode       = REX+ 0F 92 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNAE
description  = "Set byte if not above or equal (CF=1)."

[SETNB r/m8]
opcode       = 0F 93 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNB
description  = "Set byte if not below (CF=0)."

[SETNB r/m8]
opcode       = REX+ 0F 93 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNB
description  = "Set byte if not below (CF=0)."

[SETNBE r/m8]
opcode       = 0F 97 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNBE
description  = "Set byte if not below or equal (CF=0 and ZF=0)."

[SETNBE r/m8]
opcode       = REX+ 0F 97 /0
operand      = M
props        = W
iread        = E.CF E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNBE
description  = "Set byte if not below or equal (CF=0 and ZF=0)."

[SETNC r/m8]
opcode       = 0F 93 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNC
description  = "Set byte if not carry (CF=0)."

[SETNC r/m8]
opcode       = REX+ 0F 93 /0
operand      = M
props        = W
iread        = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNC
description  = "Set byte if not carry (CF=0)."

[SETNE r/m8]
opcode       = 0F 95 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNE
description  = "Set byte if not equal (ZF=0)."

[SETNE r/m8]
opcode       = REX+ 0F 95 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNE
description  = "Set byte if not equal (ZF=0)."

[SETNG r/m8]
opcode       = 0F 9E /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNG
description  = "Set byte if not greater (ZF=1 or SF!= OF)"

[SETNG r/m8]
opcode       = REX+ 0F 9E /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNG
description  = "Set byte if not greater (ZF=1 or SF!= OF)"

[SETNGE r/m8]
opcode       = 0F 9C /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNGE
description  = "Set byte if not greater or equal (SF!= OF)."

[SETNGE r/m8]
opcode       = REX+ 0F 9C /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNGE
description  = "Set byte if not greater or equal (SF!= OF)."

[SETNL r/m8]
opcode       = 0F 9D /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNL
description  = "Set byte if not less (SF=OF)."

[SETNL r/m8]
opcode       = REX+ 0F 9D /0
operand      = M
props        = W
iread        = E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNL
description  = "Set byte if not less (SF=OF)."

[SETNLE r/m8]
opcode       = 0F 9F /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNLE
description  = "Set byte if not less or equal (ZF=0 and SF=OF)."

[SETNLE r/m8]
opcode       = REX+ 0F 9F /0
operand      = M
props        = W
iread        = E.ZF E.SF E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNLE
description  = "Set byte if not less or equal (ZF=0 and SF=OF)."

[SETNO r/m8]
opcode       = 0F 91 /0
operand      = M
props        = W
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNO
description  = "Set byte if not overflow (OF=0)."

[SETNO r/m8]
opcode       = REX+ 0F 91 /0
operand      = M
props        = W
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNO
description  = "Set byte if not overflow (OF=0)."

[SETNP r/m8]
opcode       = 0F 9B /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNP
description  = "Set byte if not parity (PF=0)."

[SETNP r/m8]
opcode       = REX+ 0F 9B /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNP
description  = "Set byte if not parity (PF=0)."

[SETNS r/m8]
opcode       = 0F 99 /0
operand      = M
props        = W
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNS
description  = "Set byte if not sign (SF=0)."

[SETNS r/m8]
opcode       = REX+ 0F 99 /0
operand      = M
props        = W
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNS
description  = "Set byte if not sign (SF=0)."

[SETNZ r/m8]
opcode       = 0F 95 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETNZ
description  = "Set byte if not zero (ZF=0)."

[SETNZ r/m8]
opcode       = REX+ 0F 95 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETNZ
description  = "Set byte if not zero (ZF=0)."

[SETO r/m8]
opcode       = 0F 90 /0
operand      = M
props        = W
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETO
description  = "Set byte if overflow (OF=1)"

[SETO r/m8]
opcode       = REX+ 0F 90 /0
operand      = M
props        = W
iread        = E.OF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETO
description  = "Set byte if overflow (OF=1)"

[SETP r/m8]
opcode       = 0F 9A /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETP
description  = "Set byte if parity (PF=1)."

[SETP r/m8]
opcode       = REX+ 0F 9A /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETP
description  = "Set byte if parity (PF=1)."

[SETPE r/m8]
opcode       = 0F 9A /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETPE
description  = "Set byte if parity even (PF=1)."

[SETPE r/m8]
opcode       = REX+ 0F 9A /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETPE
description  = "Set byte if parity even (PF=1)."

[SETPO r/m8]
opcode       = 0F 9B /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETPO
description  = "Set byte if parity odd (PF=0)."

[SETPO r/m8]
opcode       = REX+ 0F 9B /0
operand      = M
props        = W
iread        = E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETPO
description  = "Set byte if parity odd (PF=0)."

[SETS r/m8]
opcode       = 0F 98 /0
operand      = M
props        = W
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETS
description  = "Set byte if sign (SF=1)."

[SETS r/m8]
opcode       = REX+ 0F 98 /0
operand      = M
props        = W
iread        = E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETS
description  = "Set byte if sign (SF=1)."

[SETZ r/m8]
opcode       = 0F 94 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SETZ
description  = "Set byte if zero (ZF=1)."

[SETZ r/m8]
opcode       = REX+ 0F 94 /0
operand      = M
props        = W
iread        = E.ZF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SETZ
description  = "Set byte if zero (ZF=1)."

[SFENCE]
opcode       = 0F AE F8
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SFENCE
description  = "Serializes store operations."

[SGDT m]
opcode       = 0F 01 /0
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Store GDTR to m."

[SHLD r/m16, r16, imm8]
opcode       = 0F A4
operand      = MRI
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLDW
description  = "Shift r/m16 to left imm8 places while shifting bits from r16 in from the right."

[SHLD r/m16, r16, CL]
opcode       = 0F A5
operand      = MRC
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLDW
description  = "Shift r/m16 to left CL places while shifting bits from r16 in from the right."

[SHLD r/m32, r32, imm8]
opcode       = 0F A4
operand      = MRI
props        = Rzu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLDL
description  = "Shift r/m32 to left imm8 places while shifting bits from r32 in from the right."

[SHLD r/m64, r64, imm8]
opcode       = REX.W+ 0F A4
operand      = MRI
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLDQ
description  = "Shift r/m64 to left imm8 places while shifting bits from r64 in from the right."

[SHLD r/m32, r32, CL]
opcode       = 0F A5
operand      = MRC
props        = Rzu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHLDL
description  = "Shift r/m32 to left CL places while shifting bits from r32 in from the right."

[SHLD r/m64, r64, CL]
opcode       = REX.W+ 0F A5
operand      = MRC
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHLDQ
description  = "Shift r/m64 to left CL places while shifting bits from r64 in from the right."

[SHRD r/m16, r16, imm8]
opcode       = 0F AC
operand      = MRI
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRDW
description  = "Shift r/m16 to right imm8 places while shifting bits from r16 in from the left."

[SHRD r/m16, r16, CL]
opcode       = 0F AD
operand      = MRC
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRDW
description  = "Shift r/m16 to right CL places while shifting bits from r16 in from the left."

[SHRD r/m32, r32, imm8]
opcode       = 0F AC
operand      = MRI
props        = Rzu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRDL
description  = "Shift r/m32 to right imm8 places while shifting bits from r32 in from the left."

[SHRD r/m64, r64, imm8]
opcode       = REX.W+ 0F AC
operand      = MRI
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRDQ
description  = "Shift r/m64 to right imm8 places while shifting bits from r64 in from the left."

[SHRD r/m32, r32, CL]
opcode       = 0F AD
operand      = MRC
props        = Rzu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SHRDL
description  = "Shift r/m32 to right CL places while shifting bits from r32 in from the left."

[SHRD r/m64, r64, CL]
opcode       = REX.W+ 0F AD
operand      = MRC
props        = Rwu, R, R
iwrite       = e.cf e.sf e.zf e.pf
iundef       = e.of e.sf e.zf e.af e.cf e.pf
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SHRDQ
description  = "Shift r/m64 to right CL places while shifting bits from r64 in from the left."

[SHUFPD xmm1, xmm2/m128, imm8]
opcode       = 66 0F C6 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = SHUFPD
description  = "Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1."

[VSHUFPD xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F.WIG C6 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSHUFPD
description  = "Shuffle Packed double-precision floating- point values selected by imm8 from xmm2 and xmm3/mem."

[VSHUFPD ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F.WIG C6 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSHUFPD
description  = "Shuffle Packed double-precision floating- point values selected by imm8 from ymm2 and ymm3/mem."

[SHUFPS xmm1, xmm2/m128, imm8]
opcode       = 0F C6 /r ib
operand      = RMI
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = SHUFPS
description  = "Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1."

[VSHUFPS xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.0F.WIG C6 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSHUFPS
description  = "Shuffle Packed single-precision floating-point values selected by imm8 from xmm2 and xmm3/mem."

[VSHUFPS ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.0F.WIG C6 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSHUFPS
description  = "Shuffle Packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/mem."

[SIDT m]
opcode       = 0F 01 /1
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Store IDTR to m."

[SLDT r/m16]
opcode       = 0F 00 /0
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Stores segment selector from LDTR in r/m16."

[SLDT r64/m16]
opcode       = REX.W+ 0F 00 /0
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Stores segment selector from LDTR in r64/m16."

[SMSW r/m16]
opcode       = 0F 01 /4
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Store machine status word to r/m16."

[SMSW r32/m16]
opcode       = 0F 01 /4
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Store machine status word in low-order 16 bits of r32/m16; high-order 16 bits of r32 are undefined."

[SMSW r64/m16]
opcode       = REX.W+ 0F 01 /4
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Store machine status word in low-order 16 bits of r64/m16; high-order 16 bits of r32 are undefined."

[SQRTPD xmm1, xmm2/m128]
opcode       = 66 0F 51 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = SQRTPD
description  = "Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1."

[VSQRTPD xmm1, xmm2/m128]
opcode       = VEX.128.66.0F.WIG 51 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSQRTPD
description  = "Computes Square Roots of the packed double- precision floating-point values in xmm2/m128 and stores the result in xmm1."

[VSQRTPD ymm1, ymm2/m256]
opcode       = VEX.256.66.0F.WIG 51 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSQRTPD
description  = "Computes Square Roots of the packed double- precision floating-point values in ymm2/m256 and stores the result in ymm1"

[SQRTPS xmm1, xmm2/m128]
opcode       = 0F 51 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = SQRTPS
description  = "Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1."

[VSQRTPS xmm1, xmm2/m128]
opcode       = VEX.128.0F.WIG 51 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSQRTPS
description  = "Computes Square Roots of the packed single- precision floating-point values in xmm2/m128 and stores the result in xmm1."

[VSQRTPS ymm1, ymm2/m256]
opcode       = VEX.256.0F.WIG 51 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSQRTPS
description  = "Computes Square Roots of the packed single- precision floating-point values in ymm2/m256 and stores the result in ymm1."

[SQRTSD xmm1, xmm2/m64]
opcode       = F2 0F 51 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = SQRTSD
description  = "Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1."

[VSQRTSD xmm1,xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 51 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSQRTSD
description  = "Computes square root of the low double- precision floating point value in xmm3/m64 and stores the results in xmm2. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."

[SQRTSS xmm1, xmm2/m32]
opcode       = F3 0F 51 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = SQRTSS
description  = "Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1."

[VSQRTSS xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 51
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSQRTSS
description  = "Computes square root of the low single- precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."

[STC]
opcode       = F9
operand      = NP
iwrite       = E.CF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STC
description  = "Set CF flag."

[STD]
opcode       = FD
operand      = NP
iwrite       = E.DF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STD
description  = "Set DF flag."

[STI]
opcode       = FB
operand      = NP
iread        = E.VM E.IOPL E.VIP
iwrite       = e.if e.vif
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STI
description  = "Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction."

[STMXCSR m32]
opcode       = 0F AE /3
operand      = M
props        = W
iread        = M.*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = STMXCSR
description  = "Store contents of MXCSR register to m32."

[VSTMXCSR m32]
opcode       = VEX.LZ.0F.WIG AE /3
operand      = M
props        = W
iread        = M.*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSTMXCSR
description  = "Store contents of MXCSR register to m32."

[STOS m8]
opcode       = AA
operand      = NP
props        = I
iread        = E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STOSB
description  = "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."

[STOS m16]
opcode       = AB
operand      = NP
props        = I
iread        = E.DF RDI AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STOSW
description  = "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."

[STOS m32]
opcode       = AB
operand      = NP
props        = I
iread        = E.DF RDI EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STOSL
description  = "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."

[STOS m64]
opcode       = REX.W+ AB
operand      = NP
props        = I
iread        = E.DF RDI RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = STOSQ
description  = "Store RAX at address RDI or EDI."

[STOSB]
opcode       = AA
operand      = NP
iread        = E.DF RDI AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STOSB
description  = "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."

[STOSW]
opcode       = PREF.66+ AB
operand      = NP
iread        = E.DF RDI AX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STOSW
description  = "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."

[STOSD]
opcode       = AB
operand      = NP
iread        = E.DF RDI EAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = STOSL
description  = "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."

[STOSQ]
opcode       = REX.W+ AB
operand      = NP
iread        = E.DF RDI RAX
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = STOSQ
description  = "Store RAX at address RDI or EDI."

[STR r/m16]
opcode       = 0F 00 /1
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Stores segment selector from TR in r/m16."

[SUB AL, imm8]
opcode       = 2C ib
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBB
description  = "Subtract imm8 from AL."

[SUB AX, imm16]
opcode       = 2D iw
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBW
description  = "Subtract imm16 from AX."

[SUB EAX, imm32]
opcode       = 2D id
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBL
description  = "Subtract imm32 from EAX."

[SUB RAX, imm32]
opcode       = REX.W+ 2D id
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SUBQ
description  = "Subtract imm32 sign-extended to 64-bits from RAX."

[SUB r/m8, imm8]
opcode       = 80 /5 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBB
description  = "Subtract imm8 from r/m8."

[SUB r/m8, imm8]
opcode       = REX+ 80 /5 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SUBB
description  = "Subtract imm8 from r/m8."

[SUB r/m16, imm16]
opcode       = 81 /5 iw
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBW
description  = "Subtract imm16 from r/m16."

[SUB r/m32, imm32]
opcode       = 81 /5 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBL
description  = "Subtract imm32 from r/m32."

[SUB r/m64, imm32]
opcode       = REX.W+ 81 /5 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SUBQ
description  = "Subtract imm32 sign-extended to 64-bits from r/m64."

[SUB r/m16, imm8]
opcode       = 83 /5 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SUBW
description  = "Subtract sign-extended imm8 from r/m16."

[SUB r/m32, imm8]
opcode       = 83 /5 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SUBL
description  = "Subtract sign-extended imm8 from r/m32."

[SUB r/m64, imm8]
opcode       = REX.W+ 83 /5 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = SUBQ
description  = "Subtract sign-extended imm8 from r/m64."

[SUB r/m8, r8]
opcode       = 28 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SUBB
description  = "Subtract r8 from r/m8."

[SUB r/m8, r8]
opcode       = REX+ 28 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = SUBB
description  = "Subtract r8 from r/m8."

[SUB r/m16, r16]
opcode       = 29 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SUBW
description  = "Subtract r16 from r/m16."

[SUB r/m32, r32]
opcode       = 29 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = SUBL
description  = "Subtract r32 from r/m32."

[SUB r/m64, r64]
opcode       = REX.W+ 29 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = SUBQ
description  = "Subtract r64 from r/m64."

[SUB r8, r/m8]
opcode       = 2A /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBB
description  = "Subtract r/m8 from r8."

[SUB r8, r/m8]
opcode       = REX+ 2A /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SUBB
description  = "Subtract r/m8 from r8."

[SUB r16, r/m16]
opcode       = 2B /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBW
description  = "Subtract r/m16 from r16."

[SUB r32, r/m32]
opcode       = 2B /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = SUBL
description  = "Subtract r/m32 from r32."

[SUB r64, r/m64]
opcode       = REX.W+ 2B /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = SUBQ
description  = "Subtract r/m64 from r64."

[SUBPD xmm1, xmm2/m128]
opcode       = 66 0F 5C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = SUBPD
description  = "Subtract packed double-precision floating- point values in xmm2/m128 from xmm1."

[VSUBPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 5C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSUBPD
description  = "Subtract packed double-precision floating- point values in xmm3/mem from xmm2 and stores result in xmm1."

[VSUBPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 5C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSUBPD
description  = "Subtract packed double-precision floating- point values in ymm3/mem from ymm2 and stores result in ymm1."

[SUBPS xmm1, xmm2/m128]
opcode       = 0F 5C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = SUBPS
description  = "Subtract packed single-precision floating-point values in xmm2/mem from xmm1."

[VSUBPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 5C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSUBPS
description  = "Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1."

[VSUBPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 5C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSUBPS
description  = "Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1."

[SUBSD xmm1, xmm2/m64]
opcode       = F2 0F 5C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = SUBSD
description  = "Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1."

[VSUBSD xmm1, xmm2, xmm3/m64]
opcode       = VEX.NDS.LIG.F2.0F.WIG 5C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSUBSD
description  = "Subtract the low double-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1."

[SUBSS xmm1, xmm2/m32]
opcode       = F3 0F 5C /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = SUBSS
description  = "Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1."

[VSUBSS xmm1, xmm2, xmm3/m32]
opcode       = VEX.NDS.LIG.F3.0F.WIG 5C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VSUBSS
description  = "Subtract the low single-precision floating- point value in xmm3/mem from xmm2 and store the result in xmm1."

[SWAPGS]
opcode       = 0F 01 F8
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
preferred    = 0
att_mnemonic = SWAPGS
description  = "Exchanges the current GS base register value with the value contained in MSR address C0000102H."

[SYSCALL]
opcode       = 0F 05
operand      = NP
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = SYSCALL
preferred    = 0
att_mnemonic = SYSCALL
description  = "Fast call to privilege level 0 system procedures."

[SYSENTER]
opcode       = 0F 34
operand      = NP
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SEP
preferred    = 0
att_mnemonic = SYSENTER
description  = "Fast call to privilege level 0 system procedures."

[SYSEXIT]
opcode       = 0F 35
operand      = NP
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SEP
preferred    = 0
att_mnemonic = SYSEXIT
description  = "Fast return to privilege level 3 user code."

[SYSEXIT pw]
opcode       = REX.W+ 0F 35
operand      = NP
props        = I
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SEP
preferred    = 0
att_mnemonic = SYSEXIT
description  = "Fast return to 64-bit mode privilege level 3 user code."

[SYSRET]
opcode       = 0F 07
operand      = NP
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = SYSCALL
preferred    = 0
att_mnemonic = SYSRET
description  = "Return to compatibility mode from fast system call"

[SYSRET pw]
opcode       = REX.W+ 0F 07
operand      = NP
props        = I
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = SYSCALL
preferred    = 0
att_mnemonic = SYSRET
description  = "Return to 64-bit mode from fast system call"

[TEST AL, imm8]
opcode       = A8 ib
operand      = I
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTB
description  = "AND imm8 with AL; set SF, ZF, PF according to result."

[TEST AX, imm16]
opcode       = A9 iw
operand      = I
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTW
description  = "AND imm16 with AX; set SF, ZF, PF according to result."

[TEST EAX, imm32]
opcode       = A9 id
operand      = I
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTL
description  = "AND imm32 with EAX; set SF, ZF, PF according to result."

[TEST RAX, imm32]
opcode       = REX.W+ A9 id
operand      = I
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = TESTQ
description  = "AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result."

[TEST r/m8, imm8]
opcode       = F6 /0 ib
operand      = MI
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTB
description  = "AND imm8 with r/m8; set SF, ZF, PF according to result."

[TEST r/m8, imm8]
opcode       = REX+ F6 /0 ib
operand      = MI
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = TESTB
description  = "AND imm8 with r/m8; set SF, ZF, PF according to result."

[TEST r/m16, imm16]
opcode       = F7 /0 iw
operand      = MI
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTW
description  = "AND imm16 with r/m16; set SF, ZF, PF according to result."

[TEST r/m32, imm32]
opcode       = F7 /0 id
operand      = MI
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTL
description  = "AND imm32 with r/m32; set SF, ZF, PF according to result."

[TEST r/m64, imm32]
opcode       = REX.W+ F7 /0 id
operand      = MI
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = TESTQ
description  = "AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result."

[TEST r/m8, r8]
opcode       = 84 /r
operand      = MR
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTB
description  = "AND r8 with r/m8; set SF, ZF, PF according to result."

[TEST r/m8, r8]
opcode       = REX+ 84 /r
operand      = MR
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = TESTB
description  = "AND r8 with r/m8; set SF, ZF, PF according to result."

[TEST r/m16, r16]
opcode       = 85 /r
operand      = MR
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTW
description  = "AND r16 with r/m16; set SF, ZF, PF according to result."

[TEST r/m32, r32]
opcode       = 85 /r
operand      = MR
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = TESTL
description  = "AND r32 with r/m32; set SF, ZF, PF according to result."

[TEST r/m64, r64]
opcode       = REX.W+ 85 /r
operand      = MR
props        = R, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = TESTQ
description  = "AND r64 with r/m64; set SF, ZF, PF according to result."

[TZCNT r16, r/m16]
opcode       = F3 0F BC /r
operand      = RM
props        = W, R
iwrite       = E.ZF E.CF
iundef       = E.AF E.PF E.OF E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = TZCNTW
description  = "Count the number of trailing zero bits in r/m16, return result in r16."

[TZCNT r32, r/m32]
opcode       = F3 0F BC /r
operand      = RM
props        = W, R
iwrite       = E.ZF E.CF
iundef       = E.AF E.PF E.OF E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = TZCNTL
description  = "Count the number of trailing zero bits in r/m32, return result in r32."

[TZCNT r64, r/m64]
opcode       = REX.W+ F3 0F BC /r
operand      = RM
props        = W, R
iwrite       = E.ZF E.CF
iundef       = E.AF E.PF E.OF E.SF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = BMI1
preferred    = 0
att_mnemonic = TZCNTQ
description  = "Count the number of trailing zero bits in r/m64, return result in r64."

[UCOMISD xmm1, xmm2/m64]
opcode       = 66 0F 2E /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = UCOMISD
description  = "Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly."

[VUCOMISD xmm1, xmm2/m64]
opcode       = VEX.LIG.66.0F.WIG 2E /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUCOMISD
description  = "Compare low double precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."

[UCOMISS xmm1, xmm2/m32]
opcode       = 0F 2E /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = UCOMISS
description  = "Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly."

[VUCOMISS xmm1, xmm2/m32]
opcode       = VEX.LIG.0F.WIG 2E /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUCOMISS
description  = "Compare low single precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."

[UD2]
opcode       = 0F 0B
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = UD2
description  = "Raise invalid opcode exception."

[UNPCKHPD xmm1, xmm2/m128]
opcode       = 66 0F 15 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = UNPCKHPD
description  = "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128."

[VUNPCKHPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 15 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKHPD
description  = "Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128."

[VUNPCKHPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 15 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKHPD
description  = "Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256."

[UNPCKHPS xmm1, xmm2/m128]
opcode       = 0F 15 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = UNPCKHPS
description  = "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1."

[VUNPCKHPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 15 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKHPS
description  = "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128."

[VUNPCKHPS ymm1, ymm2,ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 15 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKHPS
description  = "Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256."

[UNPCKLPD xmm1, xmm2/m128]
opcode       = 66 0F 14 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = UNPCKLPD
description  = "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128."

[VUNPCKLPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 14 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKLPD
description  = "Unpacks and Interleaves double precision floating-point values low high quadwords of xmm2 and xmm3/m128."

[VUNPCKLPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 14 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKLPD
description  = "Unpacks and Interleaves double precision floating-point values low high quadwords of ymm2 and ymm3/m256."

[UNPCKLPS xmm1, xmm2/m128]
opcode       = 0F 14 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = UNPCKLPS
description  = "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1."

[VUNPCKLPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 14 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKLPS
description  = "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128."

[VUNPCKLPS ymm1, ymm2,ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 14 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VUNPCKLPS
description  = "Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256."

[VBROADCASTSS xmm1, m32]
opcode       = VEX.128.66.0F38.W0 18 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBROADCASTSS
description  = "Broadcast single-precision floating-point element in mem to four locations in xmm1."

[VBROADCASTSS ymm1, m32]
opcode       = VEX.256.66.0F38.W0 18 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBROADCASTSS
description  = "Broadcast single-precision floating-point element in mem to eight locations in ymm1."

[VBROADCASTSD ymm1, m64]
opcode       = VEX.256.66.0F38.W0 19 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBROADCASTSD
description  = "Broadcast double-precision floating-point element in mem to four locations in ymm1."

[VBROADCASTF128 ymm1, m128]
opcode       = VEX.256.66.0F38.W0 1A /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VBROADCASTF128
description  = "Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1."

[VBROADCASTSS xmm1, xmm2]
opcode       = VEX.128.66.0F38.W0 18 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VBROADCASTSS
description  = "Broadcast the low single-precision floating- point element in the source operand to four locations in xmm1."

[VBROADCASTSS ymm1, xmm2]
opcode       = VEX.256.66.0F38.W0 18 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VBROADCASTSS
description  = "Broadcast low single-precision floating-point element in the source operand to eight locations in ymm1."

[VBROADCASTSD ymm1, xmm2]
opcode       = VEX.256.66.0F38.W0 19 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VBROADCASTSD
description  = "Broadcast low double-precision floating-point element in the source operand to four locations in ymm1."

[VCVTPH2PS ymm1, xmm2/m128]
opcode       = VEX.256.66.0F38.W0 13 /r
operand      = RM
props        = W, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = F16C
preferred    = 0
att_mnemonic = VCVTPH2PS
description  = "Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1."

[VCVTPH2PS xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.W0 13 /r
operand      = RM
props        = Z, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = F16C
preferred    = 0
att_mnemonic = VCVTPH2PS
description  = "Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1."

[VCVTPS2PH xmm1/m128, ymm2, imm8]
opcode       = VEX.256.66.0F3A.W0 1D /r ib
operand      = MR
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = F16C
preferred    = 0
att_mnemonic = VCVTPS2PH
description  = "Convert eight packed single-precision floating-point value in ymm2 to packed half-precision (16-bit) floating-point value in xmm1/mem. Imm8 provides rounding controls."

[VCVTPS2PH xmm1/m64, xmm2, imm8]
opcode       = VEX.128.66.0F3A.W0 1D /r ib
operand      = MR
props        = Z, R, R
iread        = M.RC
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = F16C
preferred    = 0
att_mnemonic = VCVTPS2PH
description  = "Convert four packed single-precision float- ing-point value in xmm2 to packed half- precision (16-bit) floating-point value in xmm1/mem. Imm8 provides rounding con- trols."

[VERR r/m16]
opcode       = 0F 00 /4
operand      = M
props        = R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = VERR
description  = "Set ZF=1 if segment specified with r/m16 can be read."

[VERW r/m16]
opcode       = 0F 00 /5
operand      = M
props        = R
iwrite       = E.ZF
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = VERW
description  = "Set ZF=1 if segment specified with r/m16 can be written."

[VEXTRACTF128 xmm1/m128, ymm2, imm8]
opcode       = VEX.256.66.0F3A.W0 19 /r ib
operand      = MR
props        = QZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VEXTRACTF128
description  = "Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/mem."

[VEXTRACTI128 xmm1/m128, ymm2, imm8]
opcode       = VEX.256.66.0F3A.W0 39 /r ib
operand      = MRI
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VEXTRACTI128
description  = "Extract 128 bits of integer data from ymm2 and store results in xmm1/mem."

[VFMADD132PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 98 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD132PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0."

[VFMADD213PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 A8 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD213PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0."

[VFMADD231PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 B8 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD231PD
description  = "Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0."

[VFMADD132PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 98 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD132PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0."

[VFMADD213PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 A8 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD213PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0."

[VFMADD231PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 B8 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD231PD
description  = "Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0."

[VFMADD132PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 98 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD132PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0"

[VFMADD213PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 A8 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD213PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm1, add to xmm2/mem and put result in xmm0."

[VFMADD231PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 B8 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD231PS
description  = "Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0."

[VFMADD132PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 98 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD132PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add to ymm1 and put result in ymm0."

[VFMADD213PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 A8 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD213PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm1, add to ymm2/mem and put result in ymm0."

[VFMADD231PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 B8 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD231PS
description  = "Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add to ymm0 and put result in ymm0."

[VFMADD132SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 99 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD132SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0"

[VFMADD213SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 A9 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD213SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0."

[VFMADD231SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 B9 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD231SD
description  = "Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0."

[VFMADD132SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 99 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD132SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, add to xmm1 and put result in xmm0"

[VFMADD213SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 A9 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD213SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm1, add to xmm2/mem and put result in xmm0."

[VFMADD231SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 B9 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADD231SS
description  = "Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, add to xmm0 and put result in xmm0."

[VFMADDSUB132PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 96 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB132PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0."

[VFMADDSUB213PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 A6 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB213PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0."

[VFMADDSUB231PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 B6 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB231PD
description  = "Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0."

[VFMADDSUB132PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 96 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB132PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0."

[VFMADDSUB213PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 A6 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB213PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0."

[VFMADDSUB231PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 B6 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB231PD
description  = "Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0."

[VFMADDSUB132PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 96 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB132PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, add/subtract elements in xmm1 and put result in xmm0."

[VFMADDSUB213PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 A6 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB213PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm1, add/subtract elements in xmm2/mem and put result in xmm0."

[VFMADDSUB231PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 B6 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB231PS
description  = "Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, add/subtract elements in xmm0 and put result in xmm0."

[VFMADDSUB132PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 96 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB132PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, add/subtract elements in ymm1 and put result in ymm0."

[VFMADDSUB213PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 A6 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB213PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm1, add/subtract elements in ymm2/mem and put result in ymm0."

[VFMADDSUB231PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 B6 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMADDSUB231PS
description  = "Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, add/subtract elements in ymm0 and put result in ymm0."

[VFMSUBADD132PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 97 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD132PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0."

[VFMSUBADD213PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 A7 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD213PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0."

[VFMSUBADD231PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 B7 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD231PD
description  = "Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0."

[VFMSUBADD132PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 97 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD132PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0."

[VFMSUBADD213PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 A7 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD213PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0."

[VFMSUBADD231PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 B7 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD231PD
description  = "Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0."

[VFMSUBADD132PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 97 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD132PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract/add elements in xmm1 and put result in xmm0."

[VFMSUBADD213PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 A7 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD213PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract/add elements in xmm2/mem and put result in xmm0."

[VFMSUBADD231PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 B7 /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD231PS
description  = "Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract/add elements in xmm0 and put result in xmm0."

[VFMSUBADD132PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 97 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD132PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract/add elements in ymm1 and put result in ymm0."

[VFMSUBADD213PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 A7 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD213PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract/add elements in ymm2/mem and put result in ymm0."

[VFMSUBADD231PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 B7 /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUBADD231PS
description  = "Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract/add elements in ymm0 and put result in ymm0."

[VFMSUB132PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 9A /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB132PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0."

[VFMSUB213PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 AA /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB213PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0."

[VFMSUB231PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 BA /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB231PD
description  = "Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0."

[VFMSUB132PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 9A /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB132PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0."

[VFMSUB213PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 AA /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB213PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0"

[VFMSUB231PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 BA /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB231PD
description  = "Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0."

[VFMSUB132PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 9A /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB132PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0."

[VFMSUB213PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 AA /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB213PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0."

[VFMSUB231PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 BA /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB231PS
description  = "Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0."

[VFMSUB132PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 9A /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB132PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, subtract ymm1 and put result in ymm0."

[VFMSUB213PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 AA /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB213PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm1, subtract ymm2/mem and put result in ymm0"

[VFMSUB231PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 BA /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB231PS
description  = "Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, subtract ymm0 and put result in ymm0."

[VFMSUB132SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 9B /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB132SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0."

[VFMSUB213SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 AB /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB213SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0."

[VFMSUB231SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 BB /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB231SD
description  = "Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0."

[VFMSUB132SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 9B /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB132SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, subtract xmm1 and put result in xmm0."

[VFMSUB213SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 AB /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB213SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm1, subtract xmm2/mem and put result in xmm0."

[VFMSUB231SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 BB /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFMSUB231SS
description  = "Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, subtract xmm0 and put result in xmm0."

[VFNMADD132PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 9C /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD132PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0."

[VFNMADD213PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 AC /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD213PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0."

[VFNMADD231PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 BC /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD231PD
description  = "Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0"

[VFNMADD132PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 9C /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD132PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0."

[VFNMADD213PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 AC /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD213PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0"

[VFNMADD231PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 BC /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD231PD
description  = "Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0."

[VFNMADD132PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 9C /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD132PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0."

[VFNMADD213PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 AC /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD213PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0."

[VFNMADD231PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 BC /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD231PS
description  = "Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0."

[VFNMADD132PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 9C /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD132PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and add to ymm1 and put result in ymm0."

[VFNMADD213PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 AC /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD213PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and add to ymm2/mem and put result in ymm0."

[VFNMADD231PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.0 BC /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD231PS
description  = "Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and add to ymm0 and put result in ymm0."

[VFNMADD132SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 9D /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD132SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0"

[VFNMADD213SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 AD /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD213SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0."

[VFNMADD231SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 BD /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD231SD
description  = "Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0."

[VFNMADD132SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 9D /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD132SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and add to xmm1 and put result in xmm0"

[VFNMADD213SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 AD /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD213SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and add to xmm2/mem and put result in xmm0."

[VFNMADD231SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 BD /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMADD231SS
description  = "Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and add to xmm0 and put result in xmm0."

[VFNMSUB132PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 9E /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB132PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0."

[VFNMSUB213PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 AE /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB213PD
description  = "Multiply packed double-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0"

[VFNMSUB231PD xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W1 BE /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB231PD
description  = "Multiply packed double-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0."

[VFNMSUB132PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 9E /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB132PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0."

[VFNMSUB213PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 AE /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB213PD
description  = "Multiply packed double-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0."

[VFNMSUB231PD ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W1 BE /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB231PD
description  = "Multiply packed double-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0."

[VFNMSUB132PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 9E /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB132PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0."

[VFNMSUB213PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 AE /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB213PS
description  = "Multiply packed single-precision floating-point values from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0."

[VFNMSUB231PS xmm0, xmm1, xmm2/m128]
opcode       = VEX.DDS.128.66.0F38.W0 BE /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB231PS
description  = "Multiply packed single-precision floating-point values from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0."

[VFNMSUB132PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 9E /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB132PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm2/mem, negate the multiplication result and subtract ymm1 and put result in ymm0."

[VFNMSUB213PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.W0 AE /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB213PS
description  = "Multiply packed single-precision floating-point values from ymm0 and ymm1, negate the multiplication result and subtract ymm2/mem and put result in ymm0."

[VFNMSUB231PS ymm0, ymm1, ymm2/m256]
opcode       = VEX.DDS.256.66.0F38.0 BE /r
operand      = RVM
props        = RW, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB231PS
description  = "Multiply packed single-precision floating-point values from ymm1 and ymm2/mem, negate the multiplication result and subtract ymm0 and put result in ymm0."

[VFNMSUB132SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 9F /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB132SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0."

[VFNMSUB213SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 AF /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB213SD
description  = "Multiply scalar double-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0."

[VFNMSUB231SD xmm0, xmm1, xmm2/m64]
opcode       = VEX.DDS.LIG.128.66.0F38.W1 BF /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB231SD
description  = "Multiply scalar double-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0."

[VFNMSUB132SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 9F /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB132SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm2/mem, negate the multiplication result and subtract xmm1 and put result in xmm0."

[VFNMSUB213SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 AF /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB213SS
description  = "Multiply scalar single-precision floating-point value from xmm0 and xmm1, negate the multiplication result and subtract xmm2/mem and put result in xmm0."

[VFNMSUB231SS xmm0, xmm1, xmm2/m32]
opcode       = VEX.DDS.LIG.128.66.0F38.W0 BF /r
operand      = RVM
props        = RZ, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FMA
preferred    = 0
att_mnemonic = VFNMSUB231SS
description  = "Multiply scalar single-precision floating-point value from xmm1 and xmm2/mem, negate the multiplication result and subtract xmm0 and put result in xmm0."

[VGATHERDPD xmm1, vm32x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W1 92 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERDPD
description  = "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VGATHERQPD xmm1, vm64x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W1 93 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERQPD
description  = "Using qword indices specified in vm64x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VGATHERDPD ymm1, vm32x, ymm2]
opcode       = VEX.DDS.256.66.0F38.W1 92 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERDPD
description  = "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."

[VGATHERQPD ymm1, vm64y, ymm2]
opcode       = VEX.DDS.256.66.0F38.W1 93 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERQPD
description  = "Using qword indices specified in vm64y, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."

[VGATHERDPS xmm1, vm32x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W0 92 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERDPS
description  = "Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VGATHERQPS xmm1, vm64x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W0 93 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERQPS
description  = "Using qword indices specified in vm64x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VGATHERDPS ymm1, vm32y, ymm2]
opcode       = VEX.DDS.256.66.0F38.W0 92 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERDPS
description  = "Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."

[VGATHERQPS xmm1, vm64y, xmm2]
opcode       = VEX.DDS.256.66.0F38.W0 93 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VGATHERQPS
description  = "Using qword indices specified in vm64y, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."

[VPGATHERDD xmm1, vm32x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W0 90 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERDD
description  = "Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VPGATHERQD xmm1, vm64x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W0 91 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERQD
description  = "Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VPGATHERDD ymm1, vm32y, ymm2]
opcode       = VEX.DDS.256.66.0F38.W0 90 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERDD
description  = "Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."

[VPGATHERQD xmm1, vm64y, xmm2]
opcode       = VEX.DDS.256.66.0F38.W0 91 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERQD
description  = "Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VPGATHERDQ xmm1, vm32x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W1 90 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERDQ
description  = "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VPGATHERQQ xmm1, vm64x, xmm2]
opcode       = VEX.DDS.128.66.0F38.W1 91 /r
operand      = RMV
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERQQ
description  = "Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."

[VPGATHERDQ ymm1, vm32x, ymm2]
opcode       = VEX.DDS.256.66.0F38.W1 90 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERDQ
description  = "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."

[VPGATHERQQ ymm1, vm64y, ymm2]
opcode       = VEX.DDS.256.66.0F38.W1 91 /r
operand      = RMV
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPGATHERQQ
description  = "Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."

[VINSERTF128 ymm1, ymm2, xmm3/m128, imm8]
opcode       = VEX.NDS.256.66.0F3A.W0 18 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VINSERTF128
description  = "Insert a single precision floating-point value selected by imm8 from xmm3/m128 into ymm2 at the specified destination element specified by imm8 and zero out destination elements in ymm1 as indicated in imm8."

[VINSERTI128 ymm1, ymm2, xmm3/m128, imm8]
opcode       = VEX.NDS.256.66.0F3A.W0 38 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VINSERTI128
description  = "Insert 128-bits of integer data from xmm3/mem and the remaining values from ymm2 into ymm1."

[VMASKMOVPS xmm1, xmm2, m128]
opcode       = VEX.NDS.128.66.0F38.W0 2C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPS
description  = "Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1."

[VMASKMOVPS ymm1, ymm2, m256]
opcode       = VEX.NDS.256.66.0F38.W0 2C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPS
description  = "Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1."

[VMASKMOVPD xmm1, xmm2, m128]
opcode       = VEX.NDS.128.66.0F38.W0 2D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPD
description  = "Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1."

[VMASKMOVPD ymm1, ymm2, m256]
opcode       = VEX.NDS.256.66.0F38.W0 2D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPD
description  = "Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1."

[VMASKMOVPS m128, xmm1, xmm2]
opcode       = VEX.NDS.128.66.0F38.W0 2E /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPS
description  = "Conditionally store packed single-precision values from xmm2 using mask in xmm1."

[VMASKMOVPS m256, ymm1, ymm2]
opcode       = VEX.NDS.256.66.0F38.W0 2E /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPS
description  = "Conditionally store packed single-precision values from ymm2 using mask in ymm1."

[VMASKMOVPD m128, xmm1, xmm2]
opcode       = VEX.NDS.128.66.0F38.W0 2F /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPD
description  = "Conditionally store packed double-precision values from xmm2 using mask in xmm1."

[VMASKMOVPD m256, ymm1, ymm2]
opcode       = VEX.NDS.256.66.0F38.W0 2F /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VMASKMOVPD
description  = "Conditionally store packed double-precision values from ymm2 using mask in ymm1."

[VPBLENDD xmm1, xmm2, xmm3/m128, imm8]
opcode       = VEX.NDS.128.66.0F3A.W0 02 /r ib
operand      = RVMI
props        = Z, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBLENDD
description  = "Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."

[VPBLENDD ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.W0 02 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBLENDD
description  = "Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."

[VPBROADCASTB xmm1, xmm2/m8]
opcode       = VEX.128.66.0F38.W0 78 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTB
description  = "Broadcast a byte integer in the source operand to sixteen locations in xmm1."

[VPBROADCASTB ymm1, xmm2/m8]
opcode       = VEX.256.66.0F38.W0 78 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTB
description  = "Broadcast a byte integer in the source operand to thirty two locations in ymm1."

[VPBROADCASTW xmm1, xmm2/m16]
opcode       = VEX.128.66.0F38.W0 79 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTW
description  = "Broadcast a word integer in the source operand to eight locations in xmm1."

[VPBROADCASTW ymm1, xmm2/m16]
opcode       = VEX.256.66.0F38.W0 79 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTW
description  = "Broadcast a word integer in the source operand to sixteen locations in ymm1."

[VPBROADCASTD xmm1, xmm2/m32]
opcode       = VEX.128.66.0F38.W0 58 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTD
description  = "Broadcast a dword integer in the source operand to four locations in xmm1."

[VPBROADCASTD ymm1, xmm2/m32]
opcode       = VEX.256.66.0F38.W0 58 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTD
description  = "Broadcast a dword integer in the source operand to eight locations in ymm1."

[VPBROADCASTQ xmm1, xmm2/m64]
opcode       = VEX.128.66.0F38.W0 59 /r
operand      = RM
props        = Z, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTQ
description  = "Broadcast a qword element in mem to two locations in xmm1"

[VPBROADCASTQ ymm1, xmm2/m64]
opcode       = VEX.256.66.0F38.W0 59 /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPBROADCASTQ
description  = "Broadcast a qword element in mem to four locations in ymm1"

[VBROADCASTI128 ymm1, m128]
opcode       = VEX.256.66.0F38.W0 5A /r
operand      = RM
props        = W, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VBROADCASTI128
description  = "Broadcast 128 bits of integer data in mem to low and high 128-bits in ymm1."

[VPERMD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W0 36 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPERMD
description  = "Permute doublewords in ymm3/m256 using indexes in ymm2 and store the result in ymm1."

[VPERMPD ymm1, ymm2/m256, imm8]
opcode       = VEX.256.66.0F3A.W1 01 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPERMPD
description  = "Permute double-precision floating-point elements in ymm2/m256 using indexes in imm8 and store the result in ymm1."

[VPERMPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W0 16 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPERMPS
description  = "Permute single-precision floating-point elements in ymm3/m256 using indexes in ymm2 and store the result in ymm1."

[VPERMQ ymm1, ymm2/m256, imm8]
opcode       = VEX.256.66.0F3A.W1 00 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPERMQ
description  = "Permute qwords in ymm2/m256 using indexes in imm8 and store the result in ymm1."

[VPERM2I128 ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.W0 46 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPERM2I128
description  = "Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."

[VPERMILPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.W0 0D /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPD
description  = "Permute double-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1."

[VPERMILPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W0 0D /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPD
description  = "Permute double-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1."

[VPERMILPD xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.W0 05 /r ib
operand      = RMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPD
description  = "Permute double-precision floating-point values in xmm2/mem using controls from imm8."

[VPERMILPD ymm1, ymm2/m256, imm8]
opcode       = VEX.256.66.0F3A.W0 05 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPD
description  = "Permute double-precision floating-point values in ymm2/mem using controls from imm8."

[VPERMILPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.W0 0C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPS
description  = "Permute single-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1."

[VPERMILPS xmm1, xmm2/m128, imm8]
opcode       = VEX.128.66.0F3A.W0 04 /r ib
operand      = RMI
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPS
description  = "Permute single-precision floating-point values in xmm2/mem using controls from imm8 and store result in xmm1."

[VPERMILPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W0 0C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPS
description  = "Permute single-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1."

[VPERMILPS ymm1, ymm2/m256, imm8]
opcode       = VEX.256.66.0F3A.W0 04 /r ib
operand      = RMI
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERMILPS
description  = "Permute single-precision floating-point values in ymm2/mem using controls from imm8 and store result in ymm1."

[VPERM2F128 ymm1, ymm2, ymm3/m256, imm8]
opcode       = VEX.NDS.256.66.0F3A.W0 06 /r ib
operand      = RVMI
props        = W, R, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VPERM2F128
description  = "Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."

[VPMASKMOVD xmm1, xmm2, m128]
opcode       = VEX.NDS.128.66.0F38.W0 8C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVD
description  = "Conditionally load dword values from m128 using mask in xmm2 and store in xmm1."

[VPMASKMOVD ymm1, ymm2, m256]
opcode       = VEX.NDS.256.66.0F38.W0 8C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVD
description  = "Conditionally load dword values from m256 using mask in ymm2 and store in ymm1."

[VPMASKMOVQ xmm1, xmm2, m128]
opcode       = VEX.NDS.128.66.0F38.W1 8C /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVQ
description  = "Conditionally load qword values from m128 using mask in xmm2 and store in xmm1."

[VPMASKMOVQ ymm1, ymm2, m256]
opcode       = VEX.NDS.256.66.0F38.W1 8C /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVQ
description  = "Conditionally load qword values from m256 using mask in ymm2 and store in ymm1."

[VPMASKMOVD m128, xmm1, xmm2]
opcode       = VEX.NDS.128.66.0F38.W0 8E /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVD
description  = "Conditionally store dword values from xmm2 using mask in xmm1."

[VPMASKMOVD m256, ymm1, ymm2]
opcode       = VEX.NDS.256.66.0F38.W0 8E /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVD
description  = "Conditionally store dword values from ymm2 using mask in ymm1."

[VPMASKMOVQ m128, xmm1, xmm2]
opcode       = VEX.NDS.128.66.0F38.W1 8E /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVQ
description  = "Conditionally store qword values from xmm2 using mask in xmm1."

[VPMASKMOVQ m256, ymm1, ymm2]
opcode       = VEX.NDS.256.66.0F38.W1 8E /r
operand      = MVR
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPMASKMOVQ
description  = "Conditionally store qword values from ymm2 using mask in ymm1."

[VPSLLVD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.W0 47 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLVD
description  = "Shift bits in doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."

[VPSLLVQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.W1 47 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLVQ
description  = "Shift bits in quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."

[VPSLLVD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W0 47 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLVD
description  = "Shift bits in doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."

[VPSLLVQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W1 47 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSLLVQ
description  = "Shift bits in quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."

[VPSRAVD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.W0 46 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRAVD
description  = "Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in the sign bits."

[VPSRAVD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W0 46 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRAVD
description  = "Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in the sign bits."

[VPSRLVD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.W0 45 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLVD
description  = "Shift bits in doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."

[VPSRLVQ xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F38.W1 45 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLVQ
description  = "Shift bits in quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."

[VPSRLVD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W0 45 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLVD
description  = "Shift bits in doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."

[VPSRLVQ ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F38.W1 45 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX2
preferred    = 0
att_mnemonic = VPSRLVQ
description  = "Shift bits in quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."

[VTESTPS xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.W0 0E /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VTESTPS
description  = "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources."

[VTESTPS ymm1, ymm2/m256]
opcode       = VEX.256.66.0F38.W0 0E /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VTESTPS
description  = "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating- point sources."

[VTESTPD xmm1, xmm2/m128]
opcode       = VEX.128.66.0F38.W0 0F /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VTESTPD
description  = "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources."

[VTESTPD ymm1, ymm2/m256]
opcode       = VEX.256.66.0F38.W0 0F /r
operand      = RM
props        = R, R
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VTESTPD
description  = "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating- point sources."

[VZEROALL]
opcode       = VEX.256.0F.WIG 77
operand      = NP
iwrite       = YMM*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VZEROALL
description  = "Zero all YMM registers."

[VZEROUPPER]
opcode       = VEX.128.0F.WIG 77
operand      = NP
iread        = XMM*
iwrite       = YMM*
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VZEROUPPER
description  = "Zero upper 128 bits of all YMM registers."

[WAIT]
opcode       = 9B
operand      = NP
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = WAIT
description  = "Check pending unmasked floating-point exceptions."

[FWAIT]
opcode       = 9B
operand      = NP
iundef       = S.C0 S.C1 S.C2 S.C3
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = FPU
preferred    = 0
att_mnemonic = FWAIT
description  = "Check pending unmasked floating-point exceptions."

[WBINVD]
opcode       = 0F 09
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Write back and flush Internal caches; initiate writing-back and flushing of external caches."

[WRFSBASE r32]
opcode       = F3 0F AE /2
operand      = M
props        = R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = WRFSBASE
description  = "Load the FS base address with the 32-bit value in the source register."

[WRFSBASE r64]
opcode       = REX.W+ F3 0F AE /2
operand      = M
props        = R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = WRFSBASE
description  = "Load the FS base address with the 64-bit value in the source register."

[WRGSBASE r32]
opcode       = F3 0F AE /3
operand      = M
props        = R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = WRGSBASE
description  = "Load the GS base address with the 32-bit value in the source register."

[WRGSBASE r64]
opcode       = REX.W+ F3 0F AE /3
operand      = M
props        = R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = I
cpuid_flags  = FSGSBASE
preferred    = 0
att_mnemonic = WRGSBASE
description  = "Load the GS base address with the 64-bit value in the source register."

[WRMSR]
opcode       = 0F 30
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Write the value in EDX:EAX to MSR specified by ECX."

[XACQUIRE]
opcode       = F2
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = HLE
preferred    = 0
att_mnemonic = XACQUIRE
description  = "A hint used with an "XACQUIRE-enabled" instruction to start lock elision on the instruction memory operand address."

[XRELEASE]
opcode       = F3
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = HLE
preferred    = 0
att_mnemonic = XRELEASE
description  = "A hint used with an "XRELEASE-enabled" instruction to end lock elision on the instruction memory operand address."

[XABORT imm8]
opcode       = C6 F8 ib
operand      = I
props        = R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = RTM
preferred    = 0
att_mnemonic = XABORT
description  = "Causes an RTM abort if in RTM execution"

[XADD r/m8, r8]
opcode       = 0F C0 /r
operand      = MR
props        = RW, RW
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XADDB
description  = "Exchange r8 and r/m8; load sum into r/m8."

[XADD r/m8, r8]
opcode       = REX+ 0F C0 /r
operand      = MR
props        = RW, RW
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XADDB
description  = "Exchange r8 and r/m8; load sum into r/m8."

[XADD r/m16, r16]
opcode       = 0F C1 /r
operand      = MR
props        = RW, RW
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XADDW
description  = "Exchange r16 and r/m16; load sum into r/m16."

[XADD r/m32, r32]
opcode       = 0F C1 /r
operand      = MR
props        = RW, RW
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XADDL
description  = "Exchange r32 and r/m32; load sum into r/m32."

[XADD r/m64, r64]
opcode       = REX.W+ 0F C1 /r
operand      = MR
props        = RW, RW
iwrite       = E.OF E.SF E.ZF E.AF E.CF E.PF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XADDQ
description  = "Exchange r64 and r/m64; load sum into r/m64."

[XBEGIN rel16]
opcode       = C7 F8
operand      = A
props        = R
useful       = 0
protected    = 0
x64_mode     = NS
x32_compat   = V
cpuid_flags  = RTM
preferred    = 0
att_mnemonic = XBEGIN
description  = "Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."

[XBEGIN rel32]
opcode       = C7 F8
operand      = A
props        = R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = RTM
preferred    = 0
att_mnemonic = XBEGIN
description  = "Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."

[XCHG AX, r16]
opcode       = 90 +rw
operand      = O
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XCHGW
description  = "Exchange r16 with AX."

[XCHG r16, AX]
opcode       = 90 +rw
operand      = O
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XCHGW
description  = "Exchange AX with r16."

[XCHG EAX, r32]
opcode       = 90 +rd
operand      = O
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XCHGL
description  = "Exchange r32 with EAX."

[XCHG RAX, r64]
opcode       = REX.W+ 90 +rd
operand      = O
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XCHGQ
description  = "Exchange r64 with RAX."

[XCHG r32, EAX]
opcode       = 90 +rd
operand      = O
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XCHGL
description  = "Exchange EAX with r32."

[XCHG r64, RAX]
opcode       = REX.W+ 90 +rd
operand      = O
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XCHGQ
description  = "Exchange RAX with r64."

[XCHG r/m8, r8]
opcode       = 86 /r
operand      = MR
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XCHGB
description  = "Exchange r8 (byte register) with byte from r/m8."

[XCHG r/m8, r8]
opcode       = REX+ 86 /r
operand      = MR
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XCHGB
description  = "Exchange r8 (byte register) with byte from r/m8."

[XCHG r8, r/m8]
opcode       = 86 /r
operand      = RM
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XCHGB
description  = "Exchange byte from r/m8 with r8 (byte register)."

[XCHG r8, r/m8]
opcode       = REX+ 86 /r
operand      = RM
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XCHGB
description  = "Exchange byte from r/m8 with r8 (byte register)."

[XCHG r/m16, r16]
opcode       = 87 /r
operand      = MR
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XCHGW
description  = "Exchange r16 with word from r/m16."

[XCHG r16, r/m16]
opcode       = 87 /r
operand      = RM
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XCHGW
description  = "Exchange word from r/m16 with r16."

[XCHG r/m32, r32]
opcode       = 87 /r
operand      = MR
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XCHGL
description  = "Exchange r32 with doubleword from r/m32."

[XCHG r/m64, r64]
opcode       = REX.W+ 87 /r
operand      = MR
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = XCHGQ
description  = "Exchange r64 with quadword from r/m64."

[XCHG r32, r/m32]
opcode       = 87 /r
operand      = RM
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XCHGL
description  = "Exchange doubleword from r/m32 with r32."

[XCHG r64, r/m64]
opcode       = REX.W+ 87 /r
operand      = RM
props        = RW, RW
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XCHGQ
description  = "Exchange quadword from r/m64 with r64."

[XEND]
opcode       = 0F 01 D5
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = RTM
preferred    = 0
att_mnemonic = XEND
description  = "Specifies the end of an RTM code region."

[XGETBV]
opcode       = 0F 01 D0
operand      = NP
iread        = ECX
iwrite       = EAX EDX
useful       = 1
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = XSAVE
preferred    = 0
att_mnemonic = XGETBV
description  = "Reads an XCR specified by ECX into EDX:EAX."

[XLAT m8]
opcode       = D7
operand      = NP
props        = I
iread        = AL DS BX ebx
iwrite       = AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XLAT
description  = "Set AL to memory byte DS:[(E)BX + unsigned AL]."

[XLATB]
opcode       = D7
operand      = NP
iread        = AL DS BX ebx
iwrite       = AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XLATB
description  = "Set AL to memory byte DS:[(E)BX + unsigned AL]."

[XLATB]
opcode       = REX.W+ D7
operand      = NP
iread        = AL RBX
iwrite       = AL
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XLATB
description  = "Set AL to memory byte [RBX + unsigned AL]."

[XOR AL, imm8]
opcode       = 34 ib
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORB
description  = "AL XOR imm8."

[XOR AX, imm16]
opcode       = 35 iw
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORW
description  = "AX XOR imm16."

[XOR EAX, imm32]
opcode       = 35 id
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORL
description  = "EAX XOR imm32."

[XOR RAX, imm32]
opcode       = REX.W+ 35 id
operand      = I
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XORQ
description  = "RAX XOR imm32 (sign-extended)."

[XOR r/m8, imm8]
opcode       = 80 /6 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORB
description  = "r/m8 XOR imm8."

[XOR r/m8, imm8]
opcode       = REX+ 80 /6 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XORB
description  = "r/m8 XOR imm8."

[XOR r/m16, imm16]
opcode       = 81 /6 iw
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORW
description  = "r/m16 XOR imm16."

[XOR r/m32, imm32]
opcode       = 81 /6 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORL
description  = "r/m32 XOR imm32."

[XOR r/m64, imm32]
opcode       = REX.W+ 81 /6 id
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XORQ
description  = "r/m64 XOR imm32 (sign-extended)."

[XOR r/m16, imm8]
opcode       = 83 /6 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XORW
description  = "r/m16 XOR imm8 (sign-extended)."

[XOR r/m32, imm8]
opcode       = 83 /6 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XORL
description  = "r/m32 XOR imm8 (sign-extended)."

[XOR r/m64, imm8]
opcode       = REX.W+ 83 /6 ib
operand      = MI
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = XORQ
description  = "r/m64 XOR imm8 (sign-extended)."

[XOR r/m8, r8]
opcode       = 30 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XORB
description  = "r/m8 XOR r8."

[XOR r/m8, r8]
opcode       = REX+ 30 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = XORB
description  = "r/m8 XOR r8."

[XOR r/m16, r16]
opcode       = 31 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XORW
description  = "r/m16 XOR r16."

[XOR r/m32, r32]
opcode       = 31 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 1
att_mnemonic = XORL
description  = "r/m32 XOR r32."

[XOR r/m64, r64]
opcode       = REX.W+ 31 /r
operand      = MR
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 1
att_mnemonic = XORQ
description  = "r/m64 XOR r64."

[XOR r8, r/m8]
opcode       = 32 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORB
description  = "r8 XOR r/m8."

[XOR r8, r/m8]
opcode       = REX+ 32 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XORB
description  = "r8 XOR r/m8."

[XOR r16, r/m16]
opcode       = 33 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORW
description  = "r16 XOR r/m16."

[XOR r32, r/m32]
opcode       = 33 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
preferred    = 0
att_mnemonic = XORL
description  = "r32 XOR r/m32."

[XOR r64, r/m64]
opcode       = REX.W+ 33 /r
operand      = RM
props        = RW, R
iwrite       = E.OF E.SF E.ZF E.CF E.PF
iundef       = E.AF
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
preferred    = 0
att_mnemonic = XORQ
description  = "r64 XOR r/m64."

[XORPD xmm1, xmm2/m128]
opcode       = 66 0F 57 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE2
preferred    = 0
att_mnemonic = XORPD
description  = "Bitwise exclusive-OR of xmm2/m128 and xmm1."

[VXORPD xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.66.0F.WIG 57 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VXORPD
description  = "Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem."

[VXORPD ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.66.0F.WIG 57 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VXORPD
description  = "Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem."

[XORPS xmm1, xmm2/m128]
opcode       = 0F 57 /r
operand      = RM
props        = RW, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = SSE
preferred    = 0
att_mnemonic = XORPS
description  = "Bitwise exclusive-OR of xmm2/m128 and xmm1."

[VXORPS xmm1, xmm2, xmm3/m128]
opcode       = VEX.NDS.128.0F.WIG 57 /r
operand      = RVM
props        = Z, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VXORPS
description  = "Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem."

[VXORPS ymm1, ymm2, ymm3/m256]
opcode       = VEX.NDS.256.0F.WIG 57 /r
operand      = RVM
props        = W, R, R
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = AVX
preferred    = 0
att_mnemonic = VXORPS
description  = "Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem."

[XRSTOR mem]
opcode       = 0F AE /5
operand      = M
props        = R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = XSAVE
preferred    = 0
att_mnemonic = XRSTOR
description  = "Restore processor extended states from memory. The states are specified by EDX:EAX"

[XRSTOR64 mem]
opcode       = REX.W+ 0F AE /5
operand      = M
props        = R
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = XSAVE
preferred    = 0
att_mnemonic = XRSTOR64
description  = "Restore processor extended states from memory. The states are specified by EDX:EAX"

[XSAVE mem]
opcode       = 0F AE /4
operand      = M
props        = W
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = XSAVE
preferred    = 0
att_mnemonic = XSAVE
description  = "Save processor extended states to memory. The states are specified by EDX:EAX"

[XSAVE64 mem]
opcode       = REX.W+ 0F AE /4
operand      = M
props        = W
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = NE
cpuid_flags  = XSAVE
preferred    = 0
att_mnemonic = XSAVE64
description  = "Save processor extended states to memory. The states are specified by EDX:EAX"

[XSAVEOPT mem]
opcode       = 0F AE /6
operand      = M
props        = W
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = XSAVEOPT
preferred    = 0
att_mnemonic = XSAVEOPT
description  = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible."

[XSAVEOPT64 mem]
opcode       = REX.W+ 0F AE /6
operand      = M
props        = W
iread        = ???
iwrite       = ???
iundef       = ???
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = XSAVEOPT
preferred    = 0
att_mnemonic = XSAVEOPT64
description  = "Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible."

[XSETBV]
opcode       = 0F 01 D1
useful       = 0
protected    = 1
x64_mode     = V
x32_compat   = V
preferred    = 0
description  = "Write the value in EDX:EAX to the XCR specified by ECX."

[XTEST]
opcode       = 0F 01 D6
operand      = NP
useful       = 0
protected    = 0
x64_mode     = V
x32_compat   = V
cpuid_flags  = RTM
preferred    = 0
att_mnemonic = XTEST
description  = "Test if executing in a transactional region"

